<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.PowerShell.Commands.Management</name>
    </assembly>
    <members>
        <member name="T:Microsoft.PowerShell.Commands.AddContentCommand">
            <summary>
            A command that appends the specified content to the item at the specified path.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.AddContentCommand.SeekContentPosition(System.Collections.Generic.List{Microsoft.PowerShell.Commands.ContentCommandBase.ContentHolder})">
            <summary>
            Seeks to the end of the writer stream in each of the writers in the 
            content holders.
            </summary>
            
            <param name="contentHolders">
            The content holders that contain the writers to be moved.
            </param>
            
            <exception cref="T:System.Management.Automation.ProviderInvocationException">
            If calling Seek on the content writer throws an exception.
            </exception>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.AddContentCommand.CallShouldProcess(System.String)">
            <summary>
            Makes the call to ShouldProcess with appropriate action and target strings.
            </summary>
            
            <param name="path">
            The path to the item on which the content will be added.
            </param>
            
            <returns>
            True if the action should continue or false otherwise.
            </returns>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ClearContentCommand">
            <summary>
            A command that appends the specified content to the item at the specified path.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ClearContentCommand.ProcessRecord">
            <summary>
            Clears the contents from the item at the specified path.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearContentCommand.ProviderSupportsShouldProcess">
            <summary>
            Determines if the provider for the specified path supports ShouldProcess
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ClearContentCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            A virtual method for retrieving the dynamic parameters for a cmdlet. Derived cmdlets
            that require dynamic parameters should override this method and return the
            dynamic parameter object.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ClearItemPropertyCommand">
            <summary>
            A command to clear the value of a property of an item at a specified path
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearItemPropertyCommand.Path">
            <summary>
            Gets or sets the path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearItemPropertyCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearItemPropertyCommand.Name">
             <summary>
             The properties to clear from the item
             </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ClearItemPropertyCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            A virtual method for retrieving the dynamic parameters for a cmdlet. Derived cmdlets
            that require dynamic parameters should override this method and return the
            dynamic parameter object.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ClearItemPropertyCommand.property">
            <summary>
            The properties to be cleared.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ClearItemPropertyCommand.ProcessRecord">
            <summary>
            Clears the properties of an item at the specified path
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.JoinPathCommand">
            <summary>
            A command that adds the parent and child parts of a path together
            with the appropriate path separator.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.JoinPathCommand.Path">
            <summary>
            Gets or sets the path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.JoinPathCommand.ChildPath">
            <summary>
            Gets or sets the childPath parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.JoinPathCommand.Resolve">
            <summary>
            Determines if the path should be resolved after being joined
            </summary>
            <value></value>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.JoinPathCommand.paths">
            <summary>
            The path to resolve
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.JoinPathCommand.childPath">
            <summary>
            The child part of the path to be joined with the Path paramter
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.JoinPathCommand.resolve">
            <summary>
            Determines if the path should be resolved after being joined.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.JoinPathCommand.ProcessRecord">
            <summary>
            Parses the specified path and returns the portion determined by the 
            boolean parameters.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.CommandsCommon">
            <summary>
            The base class for all command processor classes. It provides
            abstract methods to execute a command.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CommandsCommon.CheckForSevereException(System.Management.Automation.Cmdlet,System.Exception)">
            <summary>
            Checks whether the exception is a severe exception which should
            cause immediate process failure.
            </summary>
            <param name="cmdlet"></param>
            <param name="e"></param>
            <remarks>
            CB says 02/23/2005: I personally would err on the side
            of treating OOM like an application exception, rather than
            a critical system failure.I think this will be easier to justify
            in Orcas, if we tease apart the two cases of OOM better.
            But even in Whidbey, how likely is it that we couldnt JIT
            some backout code?  At that point, the process or possibly
            the machine is likely to stop executing soon no matter
            what you do in this routine.  So I would just consider
            AccessViolationException.  (I understand why you have SO here,
            at least temporarily).
            </remarks>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ContentCommandBase">
            <summary>
            The base class for the */content commands
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ContentCommandBase.Path">
            <summary>
            Gets or sets the path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ContentCommandBase.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ContentCommandBase.Filter">
            <summary>
            Gets or sets the filter property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ContentCommandBase.Include">
            <summary>
            Gets or sets the include property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ContentCommandBase.Exclude">
            <summary>
            Gets or sets the exclude property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ContentCommandBase.Force">
             <summary>
             Gets or sets the force property
             </summary>
            
             <remarks>
             Gives the provider guidance on how vigorous it should be about performing
             the operation. If true, the provider should do everything possible to perform
             the operation. If false, the provider should attempt the operation but allow
             even simple errors to terminate the operation.
             For example, if the user tries to copy a file to a path that already exists and
             the destination is read-only, if force is true, the provider should copy over
             the existing read-only file. If force is false, the provider should write an error.
             </remarks>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ContentCommandBase.paths">
            <summary>
            The path to the item to ping
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ContentCommandBase.contentStreams">
            <summary>
            An array of content holder objects that contain the path information
            and content readers/writers for the item represented by the path information.
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ContentCommandBase.WriteContentObject(System.Object,System.Int64,System.Management.Automation.PathInfo,System.Management.Automation.CmdletProviderContext)">
            <summary>
            Wraps the content into a PSObject and adds context information as notes
            </summary>
            
            <param name="content">
            The content being written out.
            </param>
            
            <param name="readCount">
            The number of blocks that have been read so far.
            </param>
            
            <param name="pathInfo">
            The context the content was retrieved from.
            </param>
            
            <param name="context">
            The context the command is being run under.
            </param>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ContentCommandBase.currentContentItem">
            <summary>
            A cache of the notes that get added to the content items as they are written
            to the pipeline.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ContentCommandBase.ContentPathsCache">
            <summary>
            A class that stores a cache of the notes that get attached to content items
            as they get written to the pipeline. An instance of this cache class is
            only valid for a single path.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ContentCommandBase.ContentPathsCache.#ctor(System.Management.Automation.PathInfo)">
            <summary>
            Constructs a content cache item.
            </summary>
            
            <param name="pathInfo">
            The path information for which the cache will be bound.
            </param>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ContentCommandBase.ContentPathsCache.PathInfo">
            <summary>
            The path information for the cached item.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ContentCommandBase.ContentPathsCache.PSPath">
            <summary>
            The cached PSPath of the item.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ContentCommandBase.ContentPathsCache.ParentPath">
            <summary>
            The cached parent path of the item.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ContentCommandBase.ContentPathsCache.Drive">
            <summary>
            The cached drive for the item.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ContentCommandBase.ContentPathsCache.Provider">
            <summary>
            The cached provider of the item.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ContentCommandBase.ContentPathsCache.ChildName">
            <summary>
            The cached child name of the item.
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ContentCommandBase.ContentPathsCache.AttachNotes(System.Management.Automation.PSObject)">
            <summary>
            Attaches the cached notes to the specified PSObject.
            </summary>
            
            <param name="content">
            The PSObject to attached the cached notes to.
            </param>
            
            <returns>
            The PSObject that was passed in with the cached notes added.
            </returns>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ContentCommandBase.ContentHolder">
            <summary>
            A struct to hold the path information and the content readers/writers
            for an item.
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ContentCommandBase.CloseContent(System.Collections.Generic.List{Microsoft.PowerShell.Commands.ContentCommandBase.ContentHolder},System.Boolean)">
            <summary>
            Closes the content readers and writers in the content holder array
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ContentCommandBase.CallShouldProcess(System.String)">
            <summary>
            Overridden by derived classes to support ShouldProcess with
            the appropriate information.
            </summary>
            
            <param name="path">
            The path to the item from which the content writer will be
            retrieved.
            </param>
            
            <returns>
            True if the action should continue or false otherwise.
            </returns>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ContentCommandBase.GetContentReaders(System.String[],System.Management.Automation.CmdletProviderContext)">
            <summary>
            Gets the IContentReaders for the current path(s)
            </summary>
            
            <returns>
            An array of IContentReaders for the current path(s)
            </returns>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ContentCommandBase.ResolvePaths(System.String[],System.Boolean,System.Boolean,System.Management.Automation.CmdletProviderContext)">
            <summary>
            Resolves the specified paths to PathInfo objects
            </summary>
            
            <param name="pathsToResolve">
            The paths to be resolved. Each path may contain glob characters.
            </param>
            
            <param name="allowNonexistingPaths">
            If true, resolves the path even if it doesn't exist.
            </param>
            
            <param name="allowEmptyResult">
            If true, allows a wildcard that returns no results.
            </param>
            
            <param name="currentCommandContext">
            The context under which the command is running.
            </param>
            
            <returns>
            An array of PathInfo objects that are the resolved paths for the
            <paramref name="pathsToResolve"/> parameter.
            </returns>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ContentCommandBase.Dispose">
            <summary>
            Dispose method in IDisposeable
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ContentCommandBase.Finalize">
            <summary>
            Finalizer
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ConvertPathCommand">
            <summary>
            A command to convert a drive qualifed or provider qualified path to 
            a provider internal path.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertPathCommand.Path">
            <summary>
            Gets or sets the path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ConvertPathCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ConvertPathCommand.paths">
            <summary>
            The path(s) to the item(s) to convert
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ConvertPathCommand.ProcessRecord">
            <summary>
            Converts a drive qualified or provider qualified path to a provider
            internal path.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.CopyItemPropertyCommand">
            <summary>
            A command to copy a property on an item.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CopyItemPropertyCommand.Path">
            <summary>
            Gets or sets the path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CopyItemPropertyCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CopyItemPropertyCommand.Name">
             <summary>
             The name of the property to create on the item
             </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CopyItemPropertyCommand.Destination">
            <summary>
            The path to the destination item to copy the property to.
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CopyItemPropertyCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            A virtual method for retrieving the dynamic parameters for a cmdlet. Derived cmdlets
            that require dynamic parameters should override this method and return the
            dynamic parameter object.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CopyItemPropertyCommand.property">
            <summary>
            The property to be copied.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CopyItemPropertyCommand.destination">
            <summary>
            The destination path of the item to copy the property to.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CopyItemPropertyCommand.ProcessRecord">
            <summary>
            Copies the property from one item to another
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetChildItemCommand">
            <summary>
            The get-childitem command class.
            This command lists the contents of a container
            </summary>
            
            <remarks>
            </remarks>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetChildItemCommand.childrenSet">
            <summary>
            The string declaration for the Items parameter set in this command.
            </summary>
            <remarks>
            The "Items" parameter set includes the following parameters:
                -filter
                -recurse
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetChildItemCommand.Path">
            <summary>
            Gets or sets the path for the operation
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetChildItemCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetChildItemCommand.Filter">
            <summary>
            Gets or sets the filter property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetChildItemCommand.Include">
            <summary>
            Gets or sets the include property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetChildItemCommand.Exclude">
            <summary>
            Gets or sets the exclude property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetChildItemCommand.Recurse">
            <summary>
            Gets or sets the recurse switch
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetChildItemCommand.Depth">
            <summary>
            Gets or sets max depth of recursion; automatically sets Recurse parameter;
            Value '0' will show only contents of container specified by -Path (same result as running 'Get-ChildItem' without '-Recurse');
            Value '1' will show 1 level deep, etc...;
            Default is uint.MaxValue - it performs full recursion (this parameter has no effect).
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetChildItemCommand.Force">
             <summary>
             Gets or sets the force property
             </summary>
            
             <remarks>
             Gives the provider guidance on how vigorous it should be about performing
             the operation. If true, the provider should do everything possible to perform
             the operation. If false, the provider should attempt the operation but allow
             even simple errors to terminate the operation.
             For example, if the user tries to copy a file to a path that already exists and
             the destination is read-only, if force is true, the provider should copy over
             the existing read-only file. If force is false, the provider should write an error.
             </remarks>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetChildItemCommand.Name">
            <summary>
            Gets or sets the names switch
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetChildItemCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            A virtual method for retrieving the dynamic parameters for a cmdlet. Derived cmdlets
            that require dynamic parameters should override this method and return the
            dynamic parameter object.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetChildItemCommand.paths">
            <summary>
            The path for the get-location operation.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetChildItemCommand.recurse">
            <summary>
            Determines if the command should do recursion.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetChildItemCommand.depth">
            <summary>
            Limits the depth of recursion; used with Recurse parameter;
            Value '0' will show only contents of container specified by -Path (same result as running 'Get-ChildItem' without '-Recurse');
            Value '1' will show 1 level deep, etc...;
            Default is uint.MaxValue - it performs full recursion (this parameter has no effect).
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetChildItemCommand.childNames">
            <summary>
            The flag that specifies whether to retrieve the child names or the child items
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetChildItemCommand.ProcessRecord">
            <summary>
            The main execution method for the get-childitem command. 
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetContentCommand">
            <summary>
            A command to get the content of an item at a specified path
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetContentCommand.ReadCount">
             <summary>
             The number of content items to retrieve per block.
             By default this value is 1 which means read one block
             at a time.  To read all blocks at once, set this value
             to a negative number.
             </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetContentCommand.TotalCount">
             <summary>
             The number of content items to retrieve. By default this
             value is -1 which means read all the content
             </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetContentCommand.Tail">
            <summary>
            The number of content items to retrieve from the back of the file.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetContentCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            A virtual method for retrieving the dynamic parameters for a cmdlet. Derived cmdlets
            that require dynamic parameters should override this method and return the
            dynamic parameter object.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetContentCommand.readCount">
            <summary>
            The number of content items to retrieve per block.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetContentCommand.totalCount">
            <summary>
            The number of content items to retrieve.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetContentCommand.ProcessRecord">
            <summary>
            Gets the content of an item at the specified path
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetContentCommand.ScanForwardsForTail(Microsoft.PowerShell.Commands.ContentCommandBase.ContentHolder,System.Management.Automation.CmdletProviderContext)">
            <summary>
            Scan forwards to get the tail content
            </summary>
            <param name="holder"></param>
            <param name="currentContext"></param>
            <returns>
            true if no error occured
            false if there was an error
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetContentCommand.SeekPositionForTail(System.Management.Automation.Provider.IContentReader)">
            <summary>
            Seek position to the right place
            </summary>
            <param name="reader">
            reader should be able to be casted to FileSystemContentReader
            </param>
            <returns>
            true if the stream pointer is moved to the right place
            false if we cannot seek
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetContentCommand.EndProcessing">
            <summary>
            Be sure to clean up
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetItemPropertyCommand">
            <summary>
            A command to get the property of an item at a specified path
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetItemPropertyCommand.Path">
            <summary>
            Gets or sets the path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetItemPropertyCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetItemPropertyCommand.Name">
             <summary>
             The properties to retrieve from the item
             </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetItemPropertyCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            A virtual method for retrieving the dynamic parameters for a cmdlet. Derived cmdlets
            that require dynamic parameters should override this method and return the
            dynamic parameter object.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetItemPropertyCommand.property">
            <summary>
            The properties to be retrieved.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetItemPropertyCommand.ProcessRecord">
            <summary>
            Gets the properties of an item at the specified path
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetItemPropertyValueCommand">
            <summary>
            A command to get the property value of an item at a specified path.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetItemPropertyValueCommand.Path">
            <summary>
            Gets or sets the path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetItemPropertyValueCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetItemPropertyValueCommand.Name">
             <summary>
             The properties to retrieve from the item
             </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetItemPropertyValueCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            A virtual method for retrieving the dynamic parameters for a cmdlet. Derived cmdlets
            that require dynamic parameters should override this method and return the
            dynamic parameter object.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetItemPropertyValueCommand.property">
            <summary>
            The properties to be retrieved.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetItemPropertyValueCommand.ProcessRecord">
            <summary>
            Gets the values of the properties of an item at the specified path.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.MoveItemPropertyCommand">
            <summary>
            A command to move a property on an item to another item
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MoveItemPropertyCommand.Path">
            <summary>
            Gets or sets the path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MoveItemPropertyCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MoveItemPropertyCommand.Name">
             <summary>
             The name of the property to create on the item
             </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MoveItemPropertyCommand.Destination">
            <summary>
            The path to the destination item to copy the property to.
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MoveItemPropertyCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            A virtual method for retrieving the dynamic parameters for a cmdlet. Derived cmdlets
            that require dynamic parameters should override this method and return the
            dynamic parameter object.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.MoveItemPropertyCommand.property">
            <summary>
            The property to be created.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.MoveItemPropertyCommand.destination">
            <summary>
            The destination path of the item to copy the property to.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MoveItemPropertyCommand.ProcessRecord">
            <summary>
            Creates the property on the item
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.CoreCommandBase">
            <summary>
            The base command for the core commands.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CoreCommandBase.tracer">
             <summary>
             An instance of the PSTraceSource class used for trace output
             using "NavigationCommands" as the category.
             </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CoreCommandBase.CmdletProviderContext">
            <summary>
            The context for the command that is passed to the core command providers.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CoreCommandBase.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            A virtual method for retrieving the dynamic parameters for a cmdlet. Derived cmdlets
            that require dynamic parameters should override this method and return the
            dynamic parameter object.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CoreCommandBase.ProviderSupportsShouldProcess">
            <summary>
            Called by the base implementation that checks the SupportShouldProcess provider
            capability. This virtual method gives the 
            derived cmdlet a chance query the CmdletProvider capabilities to determine
            if the provider supports ShouldProcess
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CoreCommandBase.DoesProviderSupportShouldProcess(System.String[])">
            <summary>
            A helper for derived classes to call to determine if the paths specified
            are for a provider that supports ShouldProcess
            </summary>
            
            <param name="paths">
            The paths to check to see if the providers support ShouldProcess.
            </param>
            
            <returns>
            If the paths are to different providers, and any don't support
            ShouldProcess, then the return value is false. If they all
            support ShouldProcess then the return value is true.
            </returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CoreCommandBase.RetrievedDynamicParameters">
            <summary>
            The dynamic parameters which have already been retrieved from the provider
            and bound by the command processor.
            </summary>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CoreCommandBase.dynamicParameters">
            <summary>
            The dynamic parameters for the command. They are retrieved using the
            GetDynamicParameters virtual method.
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CoreCommandBase.StopProcessing">
             <summary>
             Stops the processing of the provider by using the 
             CmdletProviderContext to tunnel the stop message to 
             the provider instance.
             </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CoreCommandBase.Filter">
            <summary>
            Gets or sets the filter property
            </summary>
            
            <remarks>
            This is meant to be overridden by derived classes if
            they support the Filter parameter. This property is on
            the base class to simplify the creation of the CmdletProviderContext.
            </remarks>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CoreCommandBase.Include">
            <summary>
            Gets or sets the include property
            </summary>
            
            <remarks>
            This is meant to be overridden by derived classes if
            they support the Include parameter. This property is on
            the base class to simplify the creation of the CmdletProviderContext.
            </remarks>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CoreCommandBase.Exclude">
            <summary>
            Gets or sets the exclude property
            </summary>
            
            <remarks>
            This is meant to be overridden by derived classes if
            they support the Exclude parameter. This property is on
            the base class to simplify the creation of the CmdletProviderContext.
            </remarks>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CoreCommandBase.Force">
             <summary>
             Gets or sets the force property
             </summary>
            
             <remarks>
             Gives the provider guidance on how vigorous it should be about performing
             the operation. If true, the provider should do everything possible to perform
             the operation. If false, the provider should attempt the operation but allow
             even simple errors to terminate the operation.
             For example, if the user tries to copy a file to a path that already exists and
             the destination is read-only, if force is true, the provider should copy over
             the existing read-only file. If force is false, the provider should write an error.
             
             This is meant to be overridden by derived classes if
             they support the Force parameter. This property is on
             the base class to simplify the creation of the CmdletProviderContext.
             </remarks>
             
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CoreCommandBase.GetDynamicParameters">
            <summary>
            Retrieves the dynamic parameters for the command from
            the provider.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CoreCommandBase.SupportsShouldProcess">
             <summary>
             Determines if the cmdlet and CmdletProvider supports ShouldProcess
             </summary>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.CoreCommandWithCredentialsBase">
            <summary>
            The base class for core commands to extend when they require credentials
            to be passed as parameters.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CoreCommandWithCredentialsBase.Credential">
             <summary>
             Gets or sets the credential parameter
             </summary>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CoreCommandWithCredentialsBase.credential">
            <summary>
            The credentials to be used for the command.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CoreCommandWithCredentialsBase.CmdletProviderContext">
            <summary>
            The context for the command that is passed to the core command providers.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetLocationCommand">
            <summary>
            The get-location command class.
            This command does things like list the contents of a container, get
            an item at a given path, get the current working directory, etc.
            </summary>
            
            <remarks>
            </remarks>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetLocationCommand.locationSet">
            <summary>
            The string declaration for the Location parameter set in this command.
            </summary>
            <remarks>
            The "Location" parameter set includes the following parameters:
                -location
            </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetLocationCommand.stackSet">
            <summary>
            The string declaration for the Stack parameter set in this command.
            </summary>
            <remarks>
            The "Stack" parameter set includes the following parameters:
                -stack
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetLocationCommand.PSProvider">
             <summary>
             Gets or sets the provider from which to get the current location.
             </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetLocationCommand.PSDrive">
             <summary>
             Gets or sets the drive from which to get the current location.
             </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetLocationCommand.Stack">
            <summary>
            Gets or sets the Stack switch parameter which is used
            to disambiguate parameter sets
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetLocationCommand.StackName">
             <summary>
             Gets or sets the stack ID for the location stack that will
             be retrieved.
             </summary>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetLocationCommand.provider">
            <summary>
            The name of the provider from which to return the current location.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetLocationCommand.drives">
            <summary>
            The name of the drive from which to return the current location.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetLocationCommand.stackNames">
            <summary>
            The name of the location stack from which to return the stack.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetLocationCommand.ProcessRecord">
            <summary>
            The main execution method for the get-location command. Depending on
            the parameter set that is specified, the command can do many things.
                -locationSet gets the current working directory as a Monad path
                -stackSet gets the directory stack of directories that have been
                          pushed by the push-location command
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SetLocationCommand">
            <summary>
            The core command for setting/changing location.
            This is the equivalent of cd command.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetLocationCommand.pathSet">
            <summary>
            The string declaration for the Location parameter set in this command.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetLocationCommand.literalPathSet">
            <summary>
            The string declaration for the literal location parameter set in this command.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetLocationCommand.stackSet">
            <summary>
            The string declaration for the Stack parameter set in this command.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetLocationCommand.Path">
            <summary>
            Gets or sets the path property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetLocationCommand.LiteralPath">
            <summary>
            Gets or sets the path path property, when bound from the pipeline.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetLocationCommand.PassThru">
            <summary>
            Gets or sets the parameter -passThru which states output from
            the command should be placed in the pipeline.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetLocationCommand.StackName">
            <summary>
            Gets or sets the StackName parameter which determines which location stack
            to use for the push. If the parameter is missing or empty the default
            location stack is used.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetLocationCommand.path">
            <summary>
            The filter used when doing a dir
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetLocationCommand.passThrough">
            <summary>
            Determines if output should be passed through for
            set-location.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetLocationCommand.stackName">
            <summary>
            The ID of the stack to use for the pop. 
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetLocationCommand.ProcessRecord">
            <summary>
            The functional part of the code that does the changing of the current
            working directory.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.PushLocationCommand">
            <summary>
            The core command for setting/changing location and pushing it onto a location stack.
            This is the equivalent of the pushd command.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PushLocationCommand.Path">
            <summary>
            Gets or sets the path property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PushLocationCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PushLocationCommand.PassThru">
            <summary>
            Gets or sets the parameter -passThru which states output from
            the command should be placed in the pipeline.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PushLocationCommand.StackName">
            <summary>
            Gets or sets the StackName parameter which determines which location stack
            to use for the push. If the parameter is missing or empty the default
            location stack is used.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PushLocationCommand.path">
            <summary>
            The filter used when doing a dir
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PushLocationCommand.passThrough">
            <summary>
            Determines if output should be passed through for
            push-location.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PushLocationCommand.stackName">
            <summary>
            The ID of the stack to use for the pop. 
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PushLocationCommand.ProcessRecord">
            <summary>
            The functional part of the code that does the changing of the current
            working directory and pushes the container onto the stack.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.PopLocationCommand">
            <summary>
            The core command for pop-location.  This is the equivalent of the popd command.
            It pops a container from the stack and sets the current location to that container.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PopLocationCommand.PassThru">
            <summary>
            Gets or sets the parameter -passThru which states output from
            the command should be placed in the pipeline.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PopLocationCommand.StackName">
            <summary>
            Gets or sets the StackName parameter which determines which location stack
            to use for the pop. If the parameter is missing or empty the default
            location stack is used.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PopLocationCommand.passThrough">
            <summary>
            Determines if output should be passed through for
            pop-location.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PopLocationCommand.stackName">
            <summary>
            The ID of the stack to use for the pop. 
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PopLocationCommand.ProcessRecord">
            <summary>
            Gets the top container from the location stack and sets the
            location to it.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.NewPSDriveCommand">
            <summary>
            Mounts a drive in the Monad namespace.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewPSDriveCommand.Name">
             <summary>
             Gets or sets the name of the drive
             </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewPSDriveCommand.PSProvider">
             <summary>
             Gets or sets the provider ID
             </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewPSDriveCommand.Root">
             <summary>
             Gets or sets the root of the drive. This path should be
             a namespace specific path.
             </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewPSDriveCommand.Description">
            <summary>
            Gets or sets the description of the drive
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewPSDriveCommand.Scope">
            <summary>
            Gets or sets the scope identifier for the drive being created.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewPSDriveCommand.Persist">
            <summary>
            Gets or sets the Persist Switch parameter.
            If this switch parmter is set then the created PSDrive
            would be persisted across PowerShell sessions.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NewPSDriveCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            Gets the dynamic parameters for the new-psdrive cmdlet.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewPSDriveCommand.ProviderSupportsShouldProcess">
            <summary>
            new-psdrive always supports ShouldProcess
            </summary>
            <value></value>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NewPSDriveCommand.name">
            <summary>
            The name of the drive
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NewPSDriveCommand.provider">
            <summary>
            The provider ID for the drive
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NewPSDriveCommand.root">
            <summary>
            The namespace specific path of the root of the drive
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NewPSDriveCommand.description">
            <summary>
            A description for the drive
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NewPSDriveCommand.scope">
            <summary>
            The scope identifier for the scope to create the drive in.
            If null or empty the drive will be created in the current scope.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NewPSDriveCommand.ProcessRecord">
            <summary>
            Adds a new drive to the Monad namespace
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.DriveMatchingCoreCommandBase">
            <summary>
            Base class for Drive commands that need to glob drives on both the drive name
            and the provider name.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.DriveMatchingCoreCommandBase.GetMatchingDrives(System.String,System.String[],System.String)">
             <summary>
             Globs on both the drive name and the provider name to get a list of Drives
             that match the glob filters.
             </summary>
            
             <param name="driveName">
             The name of the drive(s) to returned. The name can contain glob characters.
             </param>
            
             <param name="providerNames">
             The name of the provider(s) to return. The name can contain glob characters.
             </param>
            
             <param name="scope">
             The scope to get the drives from. If this parameter is null or empty all drives
             will be retrieved.
             </param>
            
             <returns>
             A collection of the drives that match the filters.
             </returns>
             
             <exception cref="T:System.Management.Automation.DriveNotFoundException"></exception>
             <exception cref="T:System.Management.Automation.ProviderNotFoundException"></exception>
            
             <exception cref="T:System.ArgumentException">
             If <paramref name="scope"/> is less than zero, or not
             a number and not "script", "global", "local", or "private"
             </exception>
             
             <exception cref="T:System.ArgumentOutOfRangeException">
             If <paramref name="scope"/> is less than zero or greater than the number of currently
             active scopes.
             </exception>
             
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RemovePSDriveCommand">
            <summary>
            Removes a drive that is mounted in the Monad namespace.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemovePSDriveCommand.Name">
            <summary>
            Gets or sets the name of the drive to remove.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemovePSDriveCommand.LiteralName">
            <summary>
            Gets or sets the literal name parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemovePSDriveCommand.PSProvider">
            <summary>
            Gets or sets the name provider(s) for which the drives should be removed.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemovePSDriveCommand.Scope">
            <summary>
            Gets or sets the scope identifier from which to remove the drive.
            If the scope is null or empty, the scope hierarchy will be searched
            starting at the current scope through all the parent scopes to the
            global scope until a drive of the given name is found to remove.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemovePSDriveCommand.Force">
            <summary>
            Gets or sets the force property which determines if the drive
            should be removed even if there were errors.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemovePSDriveCommand.ProviderSupportsShouldProcess">
            <summary>
            Determines if the provider for the specified path supports ShouldProcess
            </summary>
            <value></value>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RemovePSDriveCommand.names">
            <summary>
            The name of the drive to remove.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RemovePSDriveCommand.provider">
            <summary>
            The name of the provider(s) for which to remove all drives.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RemovePSDriveCommand.scope">
            <summary>
            The scope identifier for the scope to remove the drive from.
            If null or empty the scope hierarchy will be searched starting
            from the current scope through the parents to the global scope
            until a drive of the specified name is found and removed.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RemovePSDriveCommand.ProcessRecord">
            <summary>
            Removes the specified drive from the Monad namespace using the name
            of the drive.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetPSDriveCommand">
            <summary>
            Gets a specified or listing of drives that are mounted in the Monad
            namespace.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetPSDriveCommand.Name">
             <summary>
             Gets or sets the drive name the user is looking for.
             </summary>
            
             <remarks>
             If the drive name is left empty, all drives will be
             returned. A globing or regular expression can also be
             supplied and any drive names that match the expression
             will be returned.
             </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetPSDriveCommand.LiteralName">
            <summary>
            Gets or sets the literal name parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetPSDriveCommand.Scope">
             <summary>
             Gets or sets the scope parameter to the command.
             </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetPSDriveCommand.PSProvider">
             <summary>
             Gets or sets the provider name for the
             drives that should be retrieved.
             </summary>
            
             <remarks>
             If the provider is left empty, all drives will be
             returned. A globing or regular expression can also be
             supplied and any drive with providers that match the expression
             will be returned.
             </remarks>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetPSDriveCommand.name">
            <summary>
            The name of the drive to be retrieved.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetPSDriveCommand.provider">
            <summary>
            The provider ID for the drives you want to see.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetPSDriveCommand.scope">
            <summary>
            The scope to get the drive(s) from.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetPSDriveCommand.BeginProcessing">
            <summary>
            Prepare the session for the Get-PSDrive command.
            Currently, auto-loads the core modules that define drives. Ideally,
            we could discover fake PSDriveInfo objects here based on drives exported
            from modules.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetPSDriveCommand.ProcessRecord">
            <summary>
            Retrieves the drives specified by the parameters. If the name is empty, all drives
            will be retrieved. If the provider is specified, only drives for that provider
            will be retrieved.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetItemCommand">
            <summary>
            Gets the specified item using the namespace providers.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetItemCommand.Path">
            <summary>
            Gets or sets the path to item to get.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetItemCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetItemCommand.Filter">
            <summary>
            Gets or sets the filter property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetItemCommand.Include">
            <summary>
            Gets or sets the include property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetItemCommand.Exclude">
            <summary>
            Gets or sets the exclude property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetItemCommand.Force">
             <summary>
             Gets or sets the force property
             </summary>
            
             <remarks>
             Gives the provider guidance on how vigorous it should be about performing
             the operation. If true, the provider should do everything possible to perform
             the operation. If false, the provider should attempt the operation but allow
             even simple errors to terminate the operation.
             For example, if the user tries to copy a file to a path that already exists and
             the destination is read-only, if force is true, the provider should copy over
             the existing read-only file. If force is false, the provider should write an error.
             </remarks>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetItemCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            Gets the dynamic parameters for the get-item cmdlet.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetItemCommand.paths">
            <summary>
            The path of the item to get.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetItemCommand.ProcessRecord">
            <summary>
            Gets the specified item.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.NewItemCommand">
            <summary>
            Creates the specified item using the namespace providers.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewItemCommand.Path">
            <summary>
            Gets or sets the container path to create the item in.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewItemCommand.Name">
            <summary>
            Gets or sets the name of the item to create
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewItemCommand.ItemType">
            <summary>
            Gets or sets the type of the item to create
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewItemCommand.Value">
            <summary>
            Gets or sets the content of the item to create
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewItemCommand.Force">
             <summary>
             Gets or sets the force property
             </summary>
            
             <remarks>
             Gives the provider guidance on how vigorous it should be about performing
             the operation. If true, the provider should do everything possible to perform
             the operation. If false, the provider should attempt the operation but allow
             even simple errors to terminate the operation.
             For example, if the user tries to copy a file to a path that already exists and
             the destination is read-only, if force is true, the provider should copy over
             the existing read-only file. If force is false, the provider should write an error.
             </remarks>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NewItemCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            Gets the dynamic parameters for the new-item cmdlet.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewItemCommand.ProviderSupportsShouldProcess">
            <summary>
            Determines if the provider for the specified path supports ShouldProcess
            </summary>
            <value></value>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NewItemCommand.paths">
            <summary>
            The path of the container to create the item in. It may
            contain glob characters.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NewItemCommand.name">
            <summary>
            The name of the item to create. It may not contain glob characters.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NewItemCommand.type">
            <summary>
            The type of the item to create. 
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NewItemCommand.content">
            <summary>
            The content to create the new item with.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NewItemCommand.ProcessRecord">
            <summary>
            Creates the specified item.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SetItemCommand">
            <summary>
            Sets the specified item using the namespace providers.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetItemCommand.Path">
            <summary>
            Gets or sets the path to item to set.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetItemCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetItemCommand.Value">
            <summary>
            Gets or sets the value of the item to be set
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetItemCommand.Force">
             <summary>
             Gets or sets the force property
             </summary>
            
             <remarks>
             Gives the provider guidance on how vigorous it should be about performing
             the operation. If true, the provider should do everything possible to perform
             the operation. If false, the provider should attempt the operation but allow
             even simple errors to terminate the operation.
             For example, if the user tries to copy a file to a path that already exists and
             the destination is read-only, if force is true, the provider should copy over
             the existing read-only file. If force is false, the provider should write an error.
             </remarks>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetItemCommand.PassThru">
            <summary>
            Gets or sets the pass through property which determines
            if the object that is set should be written to the pipeline.
            Defaults to false.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetItemCommand.Filter">
            <summary>
            Gets or sets the filter property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetItemCommand.Include">
            <summary>
            Gets or sets the include property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetItemCommand.Exclude">
            <summary>
            Gets or sets the exclude property
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetItemCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            Gets the dynamic parameters for the set-item cmdlet.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetItemCommand.ProviderSupportsShouldProcess">
            <summary>
            Determines if the provider for the specified path supports ShouldProcess
            </summary>
            <value></value>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetItemCommand.paths">
            <summary>
            The path of the item to set.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetItemCommand.newValue">
            <summary>
            The value of the item to be set.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetItemCommand.passThrough">
            <summary>
            Determines if the object being set should be written to the pipeline.
            Defaults to false.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetItemCommand.ProcessRecord">
            <summary>
            Sets the specified item.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RemoveItemCommand">
            <summary>
            Removes the specified item using the namespace providers.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveItemCommand.Path">
            <summary>
            Gets or sets the path property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveItemCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveItemCommand.Filter">
            <summary>
            Gets or sets the filter property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveItemCommand.Include">
            <summary>
            Gets or sets the include property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveItemCommand.Exclude">
            <summary>
            Gets or sets the exclude property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveItemCommand.Recurse">
            <summary>
            Gets or sets the recurse property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveItemCommand.Force">
             <summary>
             Gets or sets the force property
             </summary>
            
             <remarks>
             Gives the provider guidance on how vigorous it should be about performing
             the operation. If true, the provider should do everything possible to perform
             the operation. If false, the provider should attempt the operation but allow
             even simple errors to terminate the operation.
             For example, if the user tries to copy a file to a path that already exists and
             the destination is read-only, if force is true, the provider should copy over
             the existing read-only file. If force is false, the provider should write an error.
             </remarks>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RemoveItemCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            Gets the dynamic parameters for the remove-item cmdlet.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveItemCommand.ProviderSupportsShouldProcess">
            <summary>
            Determines if the provider for the specified path supports ShouldProcess
            </summary>
            <value></value>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RemoveItemCommand.paths">
            <summary>
            The path used when doing a delete
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RemoveItemCommand.recurse">
            <summary>
            Determines if the remove command should recurse into
            sub-containers.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RemoveItemCommand.ProcessRecord">
            <summary>
            Removes the specified items.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.MoveItemCommand">
            <summary>
            Moves an item from the specified location to the specified destination using
            the namespace providers.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MoveItemCommand.Path">
            <summary>
            Gets or sets the path property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MoveItemCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MoveItemCommand.Destination">
            <summary>
            Gets or sets the destination property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MoveItemCommand.Force">
             <summary>
             Gets or sets the force property
             </summary>
            
             <remarks>
             Gives the provider guidance on how vigorous it should be about performing
             the operation. If true, the provider should do everything possible to perform
             the operation. If false, the provider should attempt the operation but allow
             even simple errors to terminate the operation.
             For example, if the user tries to copy a file to a path that already exists and
             the destination is read-only, if force is true, the provider should copy over
             the existing read-only file. If force is false, the provider should write an error.
             </remarks>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MoveItemCommand.Filter">
            <summary>
            Gets or sets the filter property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MoveItemCommand.Include">
            <summary>
            Gets or sets the include property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MoveItemCommand.Exclude">
            <summary>
            Gets or sets the exclude property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MoveItemCommand.PassThru">
            <summary>
            Gets or sets the pass through property which determines
            if the object that is set should be written to the pipeline.
            Defaults to false.
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MoveItemCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            Gets the dynamic parameters for the move-item cmdlet.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MoveItemCommand.ProviderSupportsShouldProcess">
            <summary>
            Determines if the provider for the specified path supports ShouldProcess
            </summary>
            <value></value>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.MoveItemCommand.paths">
            <summary>
            The path of the item to move. It is set or retrieved via
            the Path property.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.MoveItemCommand.destination">
            <summary>
            The destination of the move
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.MoveItemCommand.passThrough">
            <summary>
            Determines if the object being set should be written to the pipeline.
            Defaults to false.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MoveItemCommand.ProcessRecord">
            <summary>
            Moves the specified item to the specified destination
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RenameItemCommand">
            <summary>
            Renames a specified item to a new name using the namespace providers
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameItemCommand.Path">
            <summary>
            Gets or sets the path property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameItemCommand.LiteralPath">
            <summary>
            Gets or sets the literal path property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameItemCommand.NewName">
            <summary>
            Gets or sets the newName property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameItemCommand.Force">
             <summary>
             Gets or sets the force property
             </summary>
            
             <remarks>
             Gives the provider guidance on how vigorous it should be about performing
             the operation. If true, the provider should do everything possible to perform
             the operation. If false, the provider should attempt the operation but allow
             even simple errors to terminate the operation.
             For example, if the user tries to copy a file to a path that already exists and
             the destination is read-only, if force is true, the provider should copy over
             the existing read-only file. If force is false, the provider should write an error.
             </remarks>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameItemCommand.PassThru">
            <summary>
            Gets or sets the pass through property which determines
            if the object that is set should be written to the pipeline.
            Defaults to false.
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RenameItemCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            Gets the dynamic parameters for the rename-item cmdlet.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameItemCommand.ProviderSupportsShouldProcess">
            <summary>
            Determines if the provider for the specified path supports ShouldProcess
            </summary>
            <value></value>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RenameItemCommand.path">
            <summary>
            The path of the item to rename. It is set or retrieved via
            the Path property.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RenameItemCommand.newName">
            <summary>
            The new name of the item being renamed
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RenameItemCommand.passThrough">
            <summary>
            Determines if the object being set should be written to the pipeline.
            Defaults to false.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RenameItemCommand.ProcessRecord">
            <summary>
            Moves the specified item to the specified destination
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.CopyItemCommand">
            <summary>
            Copies a specified item to a new location using the namespace providers
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CopyItemCommand.Path">
            <summary>
            Gets or sets the path property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CopyItemCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CopyItemCommand.Destination">
            <summary>
            Gets or sets the destination property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CopyItemCommand.Container">
            <summary>
            Gets or sets the container property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CopyItemCommand.Force">
             <summary>
             Gets or sets the force property
             </summary>
            
             <remarks>
             Gives the provider guidance on how vigorous it should be about performing
             the operation. If true, the provider should do everything possible to perform
             the operation. If false, the provider should attempt the operation but allow
             even simple errors to terminate the operation.
             For example, if the user tries to copy a file to a path that already exists and
             the destination is read-only, if force is true, the provider should copy over
             the existing read-only file. If force is false, the provider should write an error.
             </remarks>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CopyItemCommand.Filter">
            <summary>
            Gets or sets the filter property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CopyItemCommand.Include">
            <summary>
            Gets or sets the include property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CopyItemCommand.Exclude">
            <summary>
            Gets or sets the exclude property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CopyItemCommand.Recurse">
            <summary>
            Gets or sets the recurse property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CopyItemCommand.PassThru">
            <summary>
            Gets or sets the pass through property which determines
            if the object that is set should be written to the pipeline.
            Defaults to false.
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CopyItemCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            Gets the dynamic parameters for the copy-item cmdlet.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CopyItemCommand.ProviderSupportsShouldProcess">
            <summary>
            Determines if the provider for the specified path supports ShouldProcess
            </summary>
            <value></value>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CopyItemCommand.paths">
            <summary>
            The path of the item to copy. It is set or retrieved via
            the Path property.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CopyItemCommand.destination">
            <summary>
            The destination of the item being copied
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CopyItemCommand.container">
            <summary>
            Determines if the containers should be copied with the items or not.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CopyItemCommand.recurse">
            <summary>
            Determines if the copy command should recurse into
            sub-containers.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CopyItemCommand.passThrough">
            <summary>
            Determines if the object being set should be written to the pipeline.
            Defaults to false.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CopyItemCommand.ProcessRecord">
            <summary>
            Copies the specified item(s) to the specified destination
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ClearItemCommand">
            <summary>
            Clears an item at the specified location
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearItemCommand.Path">
            <summary>
            Gets or sets the path property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearItemCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearItemCommand.Force">
             <summary>
             Gets or sets the force property
             </summary>
            
             <remarks>
             Gives the provider guidance on how vigorous it should be about performing
             the operation. If true, the provider should do everything possible to perform
             the operation. If false, the provider should attempt the operation but allow
             even simple errors to terminate the operation.
             For example, if the user tries to copy a file to a path that already exists and
             the destination is read-only, if force is true, the provider should copy over
             the existing read-only file. If force is false, the provider should write an error.
             </remarks>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearItemCommand.Filter">
            <summary>
            Gets or sets the filter property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearItemCommand.Include">
            <summary>
            Gets or sets the include property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearItemCommand.Exclude">
            <summary>
            Gets or sets the exclude property
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ClearItemCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            Gets the dynamic parameters for the clear-item cmdlet.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearItemCommand.ProviderSupportsShouldProcess">
            <summary>
            Determines if the provider for the specified path supports ShouldProcess
            </summary>
            <value></value>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ClearItemCommand.paths">
            <summary>
            The path of the item to move. It is set or retrieved via
            the Path property.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ClearItemCommand.ProcessRecord">
            <summary>
            Clears the specified item
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.InvokeItemCommand">
            <summary>
            Invokes an item at the specified location
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.InvokeItemCommand.Path">
            <summary>
            Gets or sets the path property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.InvokeItemCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.InvokeItemCommand.Filter">
            <summary>
            Gets or sets the filter property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.InvokeItemCommand.Include">
            <summary>
            Gets or sets the include property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.InvokeItemCommand.Exclude">
            <summary>
            Gets or sets the exclude property
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.InvokeItemCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            Gets the dynamic parameters for the invoke-item cmdlet.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.InvokeItemCommand.ProviderSupportsShouldProcess">
            <summary>
            Determines if the provider for the specified path supports ShouldProcess
            </summary>
            <value></value>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.InvokeItemCommand.paths">
            <summary>
            The path of the item to move. It is set or retrieved via
            the Path property.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.InvokeItemCommand.ProcessRecord">
            <summary>
            Invokes the specified item
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetPSProviderCommand">
            <summary>
            Gets a core command provider by name
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetPSProviderCommand.PSProvider">
             <summary>
             Gets or sets the provider that will be removed.
             </summary>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetPSProviderCommand.provider">
            <summary>
            The string ID of the provider to remove.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetPSProviderCommand.ProcessRecord">
            <summary>
            Gets a provider from the core command namespace.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.NewItemPropertyCommand">
            <summary>
            A command to create a new property on an object.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewItemPropertyCommand.Path">
            <summary>
            Gets or sets the path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewItemPropertyCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewItemPropertyCommand.Name">
             <summary>
             The name of the property to create on the item
             </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewItemPropertyCommand.PropertyType">
            <summary>
            The type of the property to create on the item.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewItemPropertyCommand.Value">
            <summary>
            The value of the property to create on the item.
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewItemPropertyCommand.Force">
             <summary>
             Gets or sets the force property
             </summary>
            
             <remarks>
             Gives the provider guidance on how vigorous it should be about performing
             the operation. If true, the provider should do everything possible to perform
             the operation. If false, the provider should attempt the operation but allow
             even simple errors to terminate the operation.
             For example, if the user tries to copy a file to a path that already exists and
             the destination is read-only, if force is true, the provider should copy over
             the existing read-only file. If force is false, the provider should write an error.
             </remarks>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NewItemPropertyCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            A virtual method for retrieving the dynamic parameters for a cmdlet. Derived cmdlets
            that require dynamic parameters should override this method and return the
            dynamic parameter object.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NewItemPropertyCommand.property">
            <summary>
            The property to be created.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NewItemPropertyCommand.type">
            <summary>
            The type of the property to be created.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NewItemPropertyCommand.propertyValue">
            <summary>
            The value of the property to be created.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NewItemPropertyCommand.ProcessRecord">
            <summary>
            Creates the property on the item
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SplitPathCommand">
            <summary>
            A command to resolve MSH paths containing glob characters to
            MSH paths that match the glob strings.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SplitPathCommand.parentSet">
            <summary>
            The parameter set name to get the parent path
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SplitPathCommand.leafSet">
            <summary>
            The parameter set name to get the leaf name
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SplitPathCommand.qualifierSet">
            <summary>
            The parameter set name to get the qualifier set.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SplitPathCommand.noQualifierSet">
            <summary>
            The parameter set name to get the noqualifier set.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SplitPathCommand.isAbsoluteSet">
            <summary>
            The parameter set name to get the IsAbsolute set.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SplitPathCommand.literalPathSet">
            <summary>
            The parameter set name to get the LiteralPath set.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SplitPathCommand.Path">
            <summary>
            Gets or sets the path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SplitPathCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SplitPathCommand.Qualifier">
             <summary>
             Determines if the qualifier should be returned
             </summary>
            
             <value>
             If true the qualifier of the path will be returned.
             The qualifier is the drive or provider that is qualifing
             the MSH path.
             </value>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SplitPathCommand.NoQualifier">
             <summary>
             Determines if the qualifier should be returned
             </summary>
            
             <value>
             If true the qualifier of the path will be returned.
             The qualifier is the drive or provider that is qualifing
             the MSH path.
             </value>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SplitPathCommand.Parent">
             <summary>
             Determines if the parent path should be returned
             </summary>
            
             <value>
             If true the parent of the path will be returned.
             </value>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SplitPathCommand.Leaf">
             <summary>
             Determines if the leaf name should be returned
             </summary>
            
             <value>
             If true the leaf name of the path will be returned.
             </value>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SplitPathCommand.Resolve">
            <summary>
            Determines if the path should be resolved before being parsed.
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SplitPathCommand.IsAbsolute">
            <summary>
            Determines if the path is an absolute path.
            </summary>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SplitPathCommand.paths">
            <summary>
            The path to resolve
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SplitPathCommand.qualifier">
            <summary>
            Determines if the qualifier of the path should be returned.
            The qualifier is either the drive name or provider name that
            is qualifying the path.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SplitPathCommand.noqualifier">
            <summary>
            Determines if the qualifier of the path should be returned.
            If false, the qualifier will be returned. If true, it will
            be stripped from the path.
            The qualifier is either the drive name or provider name that
            is qualifying the path.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SplitPathCommand.parent">
            <summary>
            Determines if the parent path of the specified path should be returned.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SplitPathCommand.leaf">
            <summary>
            Determines if the leaf name of the specified path should be returned.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SplitPathCommand.resolve">
            <summary>
            Determines if the path(s) should be resolved before being parsed.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SplitPathCommand.isAbsolute">
            <summary>
            Determines if the path(s) are absolute paths.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SplitPathCommand.ProcessRecord">
            <summary>
            Parses the specified path and returns the portion determined by the 
            boolean parameters.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SplitPathCommand.RemoveQualifier(System.String)">
            <summary>
            Removes either the drive or provider qualifier or both from the path.
            </summary>
            
            <param name="path">
            The path to strip the provider qualifier from.
            </param>
            
            <returns>
            The path without the qualifier.
            </returns>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.PassThroughContentCommandBase">
            <summary>
            The base class for the */content commands that also take
            a passthrough parameter
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PassThroughContentCommandBase.PassThru">
            <summary>
            Gets or sets the passthrough parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PassThroughContentCommandBase.ProviderSupportsShouldProcess">
            <summary>
            Determines if the provider for the specified path supports ShouldProcess
            </summary>
            <value></value>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PassThroughContentCommandBase.passThrough">
            <summary>
            Determines if the content returned from the provider should
            be passed through to the pipeline.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PassThroughContentCommandBase.GetCurrentContext">
            <summary>
            Initializes a CmdletProviderContext instance to the current context of
            the command.
            </summary>
            
            <returns>
            A CmdletProviderContext instance initialized to the context of the current
            command.
            </returns>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.PassThroughItemPropertyCommandBase">
            <summary>
            The base class for the */property commands that also take
            a passthrough parameter
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PassThroughItemPropertyCommandBase.PassThru">
            <summary>
            Gets or sets the passthrough parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PassThroughItemPropertyCommandBase.Force">
             <summary>
             Gets or sets the force property
             </summary>
            
             <remarks>
             Gives the provider guidance on how vigorous it should be about performing
             the operation. If true, the provider should do everything possible to perform
             the operation. If false, the provider should attempt the operation but allow
             even simple errors to terminate the operation.
             For example, if the user tries to copy a file to a path that already exists and
             the destination is read-only, if force is true, the provider should copy over
             the existing read-only file. If force is false, the provider should write an error.
             </remarks>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PassThroughItemPropertyCommandBase.passThrough">
            <summary>
            Determines if the property returned from the provider should
            be passed through to the pipeline.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PassThroughItemPropertyCommandBase.ProviderSupportsShouldProcess">
            <summary>
            Determines if the provider for the specified path supports ShouldProcess
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PassThroughItemPropertyCommandBase.GetCurrentContext">
            <summary>
            Initializes a CmdletProviderContext instance to the current context of
            the command.
            </summary>
            
            <returns>
            A CmdletProviderContext instance initialized to the context of the current
            command.
            </returns>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.TestPathType">
            <summary>
            The valid values for the -PathType parameter for test-path
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.TestPathType.Any">
            <summary>
            If the item at the path exists, true will be returned.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.TestPathType.Container">
            <summary>
            If the item at the path exists and is a container, true will be returned.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.TestPathType.Leaf">
            <summary>
            If the item at the path exists and is not a container, true will be returned.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.TestPathCommand">
            <summary>
            A command to determine if an item exists at a specified path
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestPathCommand.Path">
            <summary>
            Gets or sets the path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestPathCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestPathCommand.Filter">
            <summary>
            Gets or sets the filter property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestPathCommand.Include">
            <summary>
            Gets or sets the include property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestPathCommand.Exclude">
            <summary>
            Gets or sets the exclude property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestPathCommand.PathType">
            <summary>
            Gets or sets the isContainer property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestPathCommand.IsValid">
            <summary>
            Gets or sets the IsValid parameter
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TestPathCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            A virtual method for retrieving the dynamic parameters for a cmdlet. Derived cmdlets
            that require dynamic parameters should override this method and return the
            dynamic parameter object.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.TestPathCommand.paths">
            <summary>
            The path to the item to ping
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.TestPathCommand.type">
            <summary>
            Determines if the command should check to see if any item exists at
            the specified path, a container exists at the specified path, or a 
            leaf item exists at the specified path.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.TestPathCommand.isValid">
            <summary>
            Determines if the path should be checked for validity.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TestPathCommand.ProcessRecord">
            <summary>
            Determines if an item at the specified path exists.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ItemPropertyCommandBase">
            <summary>
            The base class for the */property commands
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ItemPropertyCommandBase.Filter">
            <summary>
            Gets or sets the filter parameter
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ItemPropertyCommandBase.Include">
            <summary>
            Gets or sets the include property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ItemPropertyCommandBase.Exclude">
            <summary>
            Gets or sets the exclude property
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ItemPropertyCommandBase.paths">
            <summary>
            The path to the item
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RemoveItemPropertyCommand">
            <summary>
            A command to remove a property from an item.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveItemPropertyCommand.Path">
            <summary>
            Gets or sets the path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveItemPropertyCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveItemPropertyCommand.Name">
             <summary>
             The name of the property to create on the item
             </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveItemPropertyCommand.Force">
             <summary>
             Gets or sets the force property
             </summary>
            
             <remarks>
             Gives the provider guidance on how vigorous it should be about performing
             the operation. If true, the provider should do everything possible to perform
             the operation. If false, the provider should attempt the operation but allow
             even simple errors to terminate the operation.
             For example, if the user tries to copy a file to a path that already exists and
             the destination is read-only, if force is true, the provider should copy over
             the existing read-only file. If force is false, the provider should write an error.
             </remarks>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RemoveItemPropertyCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            A virtual method for retrieving the dynamic parameters for a cmdlet. Derived cmdlets
            that require dynamic parameters should override this method and return the
            dynamic parameter object.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RemoveItemPropertyCommand.property">
            <summary>
            The property to be created.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RemoveItemPropertyCommand.ProcessRecord">
            <summary>
            Removes the property from the item
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RenameItemPropertyCommand">
            <summary>
            A command to rename a property of an item at a specified path
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameItemPropertyCommand.Path">
            <summary>
            Gets or sets the path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameItemPropertyCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameItemPropertyCommand.Name">
             <summary>
             The properties to be renamed on the item
             </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameItemPropertyCommand.NewName">
             <summary>
             The new name of the property on the item
             </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RenameItemPropertyCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            A virtual method for retrieving the dynamic parameters for a cmdlet. Derived cmdlets
            that require dynamic parameters should override this method and return the
            dynamic parameter object.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RenameItemPropertyCommand.path">
            <summary>
            The path to rename the property on.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RenameItemPropertyCommand.property">
            <summary>
            The property to be renamed.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RenameItemPropertyCommand.newName">
            <summary>
            The new name of the item.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RenameItemPropertyCommand.ProcessRecord">
            <summary>
            Renames a property on an item.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ResolvePathCommand">
            <summary>
            A command to resolve MSH paths containing glob characters to
            MSH paths that match the glob strings.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ResolvePathCommand.Path">
            <summary>
            Gets or sets the path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ResolvePathCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ResolvePathCommand.Relative">
            <summary>
            Gets or sets the value that determines if the resolved path should
            be resolved to its relative version.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ResolvePathCommand.paths">
            <summary>
            The path to resolve
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ResolvePathCommand.ProcessRecord">
            <summary>
            Resolves the path containing glob characters to the MSH paths that it
            represents.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SetContentCommand">
            <summary>
            A command to set the content of an item at a specified path
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetContentCommand.BeforeOpenStreams(System.String[])">
            <summary>
            Called by the base class before the streams are open for the path.
            This override clears the content from the item. 
            </summary>
            
            <param name="paths">
            The path to the items that will be opened for writing content.
            </param>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetContentCommand.CallShouldProcess(System.String)">
            <summary>
            Makes the call to ShouldProcess with appropriate action and target strings.
            </summary>
            
            <param name="path">
            The path to the item on which the content will be set.
            </param>
            
            <returns>
            True if the action should continue or false otherwise.
            </returns>
            
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SetItemPropertyCommand">
            <summary>
            A command to set the property of an item at a specified path
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetItemPropertyCommand.Path">
            <summary>
            Gets or sets the path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetItemPropertyCommand.LiteralPath">
            <summary>
            Gets or sets the literal path parameter to the command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetItemPropertyCommand.Name">
             <summary>
             The name of the property to set.
             </summary>
            
             <value>
             This value type is determined by the InvokeProvider.
             </value>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetItemPropertyCommand.Value">
             <summary>
             The value of the property to set.
             </summary>
            
             <value>
             This value type is determined by the InvokeProvider.
             </value>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetItemPropertyCommand.InputObject">
            <summary>
            A PSObject that contains the properties and values to be set.
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetItemPropertyCommand.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            A virtual method for retrieving the dynamic parameters for a cmdlet. Derived cmdlets
            that require dynamic parameters should override this method and return the
            dynamic parameter object.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetItemPropertyCommand.content">
            <summary>
            The value of the property to be set.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetItemPropertyCommand.property">
            <summary>
            The name of the property to be set.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetItemPropertyCommand.propertyTable">
            <summary>
            The properties to be set contained within a PSObject
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetItemPropertyCommand.ProcessRecord">
            <summary>
            Sets the content of the item at the specified path
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WriteContentCommandBase">
            <summary>
            A base class for the commands that write content (set-content, add-content)
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteContentCommandBase.Value">
             <summary>
             The value of the content to set.
             </summary>
            
             <value>
             This value type is determined by the InvokeProvider.
             </value>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WriteContentCommandBase.content">
            <summary>
            The value of the content to be set.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WriteContentCommandBase.pipingPaths">
            <summary>
            This bool is used to determine if the path 
            parameter was specified on the command line or via the pipeline.
            </summary>
            
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WriteContentCommandBase.contentWritersOpen">
            <summary>
            True if the content writers have been open.
            This is used in conjunction with pipingPaths
            to determine if the content writers need to
            be closed each time ProgressRecord is called.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteContentCommandBase.BeginProcessing">
            <summary>
            Determines if the paths are specified on the command line
            or being piped in
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteContentCommandBase.ProcessRecord">
            <summary>
            Appends the content to the specified item.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteContentCommandBase.EndProcessing">
            <summary>
            Closes all the content writers
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteContentCommandBase.SeekContentPosition(System.Collections.Generic.List{Microsoft.PowerShell.Commands.ContentCommandBase.ContentHolder})">
            <summary>
            This method is called by the base class after getting the content writer
            from the provider. If the current position needs to be changed before writing
            the content, this method should be overriden to do that.
            </summary>
            
            <param name="contentHolders">
            The content holders that contain the writers to be moved.
            </param>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteContentCommandBase.BeforeOpenStreams(System.String[])">
            <summary>
            Called by the base class before the streams are open for the path. 
            </summary>
            
            <param name="paths">
            The path to the items that will be opened for writing content.
            </param>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteContentCommandBase.GetDynamicParameters(System.Management.Automation.CmdletProviderContext)">
            <summary>
            A virtual method for retrieving the dynamic parameters for a cmdlet. Derived cmdlets
            that require dynamic parameters should override this method and return the
            dynamic parameter object.
            </summary>
            
            <param name="context">
            The context under which the command is running.
            </param>
            
            <returns>
            An object representing the dynamic parameters for the cmdlet or null if there
            are none.
            </returns>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteContentCommandBase.GetContentWriters(System.String[],System.Management.Automation.CmdletProviderContext)">
            <summary>
            Gets the IContentWriters for the current path(s)
            </summary>
            
            <returns>
            An array of IContentWriters for the current path(s)
            </returns>
            
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteContentCommandBase.GetAcceptedPaths(System.String[],System.Management.Automation.CmdletProviderContext)">
            <summary>
            Gets the list of paths accepted by the user
            </summary>
            <param name="unfilteredPaths">The list of unfiltered paths</param>
            <param name="currentContext">The current context</param>
            <returns>The list of paths accepted by the user</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ProcessBaseCommand">
            <summary>
            This class implements the base for process commands
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ProcessBaseCommand.MatchMode">
            <summary>
            The various process selection modes
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ProcessBaseCommand.MatchMode.All">
            <summary>
            Select all processes
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ProcessBaseCommand.MatchMode.ByName">
            <summary>
            Select processes matching the supplied names
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ProcessBaseCommand.MatchMode.ById">
            <summary>
            Select the processes matching the id
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ProcessBaseCommand.MatchMode.ByInput">
            <summary>
            Select the processes specified as input.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ProcessBaseCommand.myMode">
            <summary>
            The current process selection mode.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ProcessBaseCommand.SuppliedComputerName">
            <summary>
            The computer from which to retrieve processes.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ProcessBaseCommand.processNames">
            <remarks>
            The Name parameter is declared in subclasses,
            since it is optional for GetProcess and mandatory for StopProcess.
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ProcessBaseCommand.InputObject">
            <summary>
            If the input is a stream of [collections of]
            Process objects, we bypass the Name and
            Id parameters and read the Process objects
            directly.  This allows us to deal with processes which
            have wildcard characters in their name.
            </summary>
            <value>Process objects</value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ProcessBaseCommand.MatchingProcesses">
            <summary>
            Retrieve the list of all processes matching the Name, Id
            and InputObject parameters, sorted by Id.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ProcessBaseCommand.ProcessComparison(System.Diagnostics.Process,System.Diagnostics.Process)">
            <summary>
            sort function to sort by Name first, then Id
            </summary>
            <param name="x">first Process object</param>
            <param name="y">second Process object</param>
            <returns>
            as String.Compare: returns less than zero if x less than y,
            greater than 0 if x greater than y, 0 if x == y
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ProcessBaseCommand.RetrieveMatchingProcessesByProcessName">
            <summary>
            Retrieves the list of all processes matching the Name
            parameter.
            Generates a non-terminating error for each specified
            process name which is not found even though it contains
            no wildcards.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ProcessBaseCommand.RetrieveMatchingProcessesById">
            <summary>
            Retrieves the list of all processes matching the Id
            parameter.
            Generates a non-terminating error for each specified
            process ID which is not found.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ProcessBaseCommand.RetrieveProcessesByInput">
            <summary>
            Retrieves the list of all processes matching the InputObject
            parameter.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ProcessBaseCommand.AllProcesses">
            <summary>
            Retrieve the master list of all processes
            </summary>
            <value></value>
            <exception cref="T:System.Security.SecurityException">
            MSDN does not document the list of exceptions,
            but it is reasonable to expect that SecurityException is
            among them.  Errors here will terminate the cmdlet.
            </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ProcessBaseCommand.AddIdempotent(System.Diagnostics.Process)">
            <summary>
            Add <paramref name="process"/> to <see cref="F:Microsoft.PowerShell.Commands.ProcessBaseCommand._matchingProcesses"/>,
            but only if it is not already on  <see cref="F:Microsoft.PowerShell.Commands.ProcessBaseCommand._matchingProcesses"/>.
            We use a Dictionary to optimize the check whether the object
            is already in the list.
            </summary>
            <param name="process">process to add to list</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ProcessBaseCommand.WriteNonTerminatingError(System.Diagnostics.Process,System.Exception,System.String,System.String,System.Management.Automation.ErrorCategory)">
            <summary>
            Writes a non-terminating error.
            </summary>
            <param name="process"></param>
            <param name="innerException"></param>
            <param name="resourceId"></param>
            <param name="errorId"></param>
            <param name="category"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ProcessBaseCommand.WriteNonTerminatingError(System.String,System.Int32,System.Object,System.Exception,System.String,System.String,System.Management.Automation.ErrorCategory)">
            <summary>
            Writes a non-terminating error.
            </summary>
            <param name="processName"></param>
            <param name="processId"></param>
            <param name="targetObject"></param>
            <param name="innerException"></param>
            <param name="resourceId"></param>
            <param name="errorId"></param>
            <param name="category"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ProcessBaseCommand.TryHasExited(System.Diagnostics.Process)">
            <summary>
            TryHasExited is a helper function used to detect if the process has aready exited or not.
            </summary>
            <param name="process">
            Process whose exit status has to be checked.
            </param>
            <returns>Tre if the process has exited or else returns false.</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetProcessCommand">
            <summary>
            This class implements the get-process command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetProcessCommand.Name">
            <summary>
            Has the list of process names on which to this command will work
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetProcessCommand.Id">
            <summary>
            gets/sets an array of process IDs
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetProcessCommand.InputObject">
            <summary>
            Input is a stream of [collections of] Process objects
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetProcessCommand.IncludeUserName">
            <summary>
            Include the UserName
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetProcessCommand.ComputerName">
            <summary>
            gets/sets the destination computer name
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetProcessCommand.Module">
            <summary>
            To display the modules of a process
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetProcessCommand.FileVersionInfo">
            <summary>
            To display the fileversioninfo of the main module of a process
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetProcessCommand.BeginProcessing">
            <summary>
            Check the elevation mode if IncludeUserName is specified
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetProcessCommand.ProcessRecord">
            <summary>
            Write the process objects
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetProcessCommand.TypeNameForProcessWithUserName">
            <summary>
            New PSTypeName added to the process object
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetProcessCommand.AddUserNameToProcess(System.Diagnostics.Process,System.Management.Automation.Cmdlet)">
            <summary>
            Add the 'UserName' NoteProperty to the Process object
            </summary>
            <param name="process"></param>
            <param name="cmdlet"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetProcessCommand.RetrieveProcessUserName(System.Diagnostics.Process,System.Management.Automation.Cmdlet)">
            <summary>
            Retrieve the UserName through PInvoke
            </summary>
            <param name="process"></param>
            <param name="cmdlet"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WaitProcessCommand">
            <summary>
            This class implements the Wait-process command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WaitProcessCommand.Id">
            <summary>
            Specifies the process IDs of the processes to be waited on.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WaitProcessCommand.Name">
            <summary>
            Name of the processes to wait on for termintation
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WaitProcessCommand.Timeout">
            <summary>
            If specified, wait for this number of seconds
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WaitProcessCommand.Dispose">
            <summary>
             Dispose method of IDisposable interface.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WaitProcessCommand.ProcessRecord">
            <summary>
            gets the list of process
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WaitProcessCommand.EndProcessing">
            <summary>
            Wait for the process to terminate
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WaitProcessCommand.StopProcessing">
            <summary>
            StopProcessing
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StopProcessCommand">
            <summary>
            This class implements the stop-process command
            </summary>
            <remarks>
            Processes will be sorted before being stopped.  PM confirms
            that this should be fine.
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StopProcessCommand.Name">
            <summary>
            Has the list of process names on which to this command will work
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StopProcessCommand.Id">
            <summary>
            gets/sets an array of process IDs
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StopProcessCommand.InputObject">
            <summary>
            gets/sets an array of objects
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StopProcessCommand.PassThru">
            <summary>
            The updated process object should be passed down the pipeline.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StopProcessCommand.Force">
            <summary>
            Specifies whether to force a process to kill
            even if it has dependent services.
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StopProcessCommand.ProcessRecord">
            <summary>
            Kill the processes.
            It is a non-terminating error if the Process.Kill() operation fails.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StopProcessCommand.EndProcessing">
            <summary>
            Kill the current process here.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StopProcessCommand.shouldKillCurrentProcess">
            <summary>
            should the current powershell process to be killed
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StopProcessCommand.yesToAll">
            <summary>
            Boolean variables to display the warning using shouldcontinue
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StopProcessCommand.noToAll">
            <summary>
            Boolean variables to display the warning using shouldcontinue
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.StopProcessCommand.currentUserName">
            <summary>
            Current windows user name
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StopProcessCommand.IsProcessOwnedByCurrentUser(System.Diagnostics.Process)">
            <summary>
            gets the owner of the process
            </summary>
            <param name="process"></param>
            <returns>returns the owner</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StopProcessCommand.StopDependentService(System.Diagnostics.Process)">
            <summary>
            Stop the service that depends on the process and its child services
            </summary>
            <param name="process"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StopProcessCommand.StopProcess(System.Diagnostics.Process)">
            <summary>
            stops the given process throws non terminating error if cant
            <param name="process" >process to be stopped</param>
            <returns>true if process stopped successfully else false</returns>
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.DebugProcessCommand">
            <summary>
            This class implements the Debug-process command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.DebugProcessCommand.Id">
            <summary>
            Specifies the process IDs of the processes to be waited on.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.DebugProcessCommand.Name">
            <summary>
            Name of the processes to wait on for termintation
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.DebugProcessCommand.ProcessRecord">
            <summary>
            gets the list of process and attach the debugger to the processes
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.DebugProcessCommand.AttachDebuggerToProcess(System.Diagnostics.Process)">
            <summary>
            Attach debugger to the process
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.DebugProcessCommand.MapReturnCodeToErrorMessage(System.Int32)">
            <summary>
            Map the return code from 'AttachDebugger' to error message
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StartProcessCommand">
            <summary>
            This class implements the Start-process command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StartProcessCommand.FilePath">
            <summary>
            Path/FileName of the process to start
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StartProcessCommand.ArgumentList">
            <summary>
            Arguments for the process
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StartProcessCommand.Credential">
            <summary>
            Credentials for the process
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StartProcessCommand.WorkingDirectory">
            <summary>
             working directory of the process
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StartProcessCommand.LoadUserProfile">
            <summary>
            load user profile from registry
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StartProcessCommand.NoNewWindow">
            <summary>
            starts process in a new window
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StartProcessCommand.PassThru">
            <summary>
            passthru parameter
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StartProcessCommand.RedirectStandardError">
            <summary>
            Redirect error
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StartProcessCommand.RedirectStandardInput">
            <summary>
            Redirect input 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StartProcessCommand.RedirectStandardOutput">
            <summary>
            Redirect output 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StartProcessCommand.Verb">
            <summary>
            Verb
            </summary>
            <remarks>
            The 'Verb' parameter is not supported in OneCore PowerShell 
            because 'UseShellExecute' is not supported in CoreCLR.
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StartProcessCommand.WindowStyle">
            <summary>
            Window style of the process window
            </summary>
            <remarks>
            The 'WindowStyle' is not supported in CoreCLR
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StartProcessCommand.Wait">
            <summary>
             wait for th eprocess to terminate
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StartProcessCommand.UseNewEnvironment">
            <summary>
             Default Environment
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StartProcessCommand.BeginProcessing">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StartProcessCommand.StopProcessing">
            <summary>
            Implements ^c, after creating a process.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StartProcessCommand.myProcess_Exited(System.Object,System.EventArgs)">
            <summary>
            When Process exits the wait handle is set. 
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StartProcessCommand.Dispose">
            <summary>
            Dispose WaitHandle used to honor -Wait parameter
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ProcessCollection">
            <summary>
            ProcessCollection is a helper class used by Start-Process -Wait cmdlet to monitor the
            child processes created by the main process hosted by the Start-process cmdlet.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ProcessCollection.jobObjectHandle">
            <summary>
            JobObjectHandle is a reference to the job object used to track 
            the child processes created by the main process hosted by the Start-Process cmdlet.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ProcessCollection.#ctor">
            <summary>
            ProcessCollection constructor.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ProcessCollection.AssignProcessToJobObject(System.Diagnostics.Process)">
            <summary>
            Start API assignes the process to the JobObject and starts monitoring 
            the child processes hosted by the process created by Start-Process cmdlet.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ProcessCollection.CheckJobStatus(System.Object)">
            <summary>
            Checks to see if the JobObject is empty (has no assigned processes).
            If job is empty the auto reset event supplied as input would be set.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ProcessCollection.WaitOne(System.Threading.ManualResetEvent)">
            <summary>
            WaitOne blocks the current thread until the current instance receives a signal, using
            a System.TimeSpan to measure the time interval and specifying whether to
            exit the synchronization domain before the wait.
            </summary>
            <param name="waitHandleToUse">
            WaitHandle to use for waiting on the job object.
            </param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.JOBOBJECT_BASIC_PROCESS_ID_LIST">
            <summary>
            JOBOBJECT_BASIC_PROCESS_ID_LIST Contains the process identifier list for a job object. 
            If the job is nested, the process identifier list consists of all 
            processes associated with the job and its child jobs.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.JOBOBJECT_BASIC_PROCESS_ID_LIST.NumberOfAssignedProcess">
            <summary>
            The number of process identifiers to be stored in ProcessIdList.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.JOBOBJECT_BASIC_PROCESS_ID_LIST.NumberOfProcessIdsInList">
            <summary>
            The number of process identifiers returned in the ProcessIdList buffer. 
            If this number is less than NumberOfAssignedProcesses, increase 
            the size of the buffer to accommodate the complete list.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.JOBOBJECT_BASIC_PROCESS_ID_LIST.ProcessIdList">
            <summary>
            A variable-length array of process identifiers returned by this call. 
            Array elements 0 through NumberOfProcessIdsInList 1 
            contain valid process identifiers.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SafeNativeMethods.PROCESS_INFORMATION.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SafeNativeMethods.PROCESS_INFORMATION.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ProcessCommandException">
            <summary>
            Non-terminating errors occurring in the process noun commands
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ProcessCommandException.#ctor">
            <summary>
            unimplemented standard constructor
            </summary>
            <returns> doesn't return </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ProcessCommandException.#ctor(System.String)">
            <summary>
            standard constructor
            </summary>
            <param name="message"></param>
            <returns> constructed object </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ProcessCommandException.#ctor(System.String,System.Exception)">
            <summary>
            standard constructor
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ProcessCommandException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            serialization constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
            <returns> constructed object </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ProcessCommandException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serializer
            </summary>
            <param name="info"> serialization information </param>
            <param name="context"> streaming context </param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ProcessCommandException.ProcessName">
            <summary>
            Name of the process which could not be found or operated upon
            </summary>
            <value></value>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ServiceBaseCommand">
            <summary>
            This class implements the base for service commands
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ServiceBaseCommand.ShouldProcessServiceOperation(System.ServiceProcess.ServiceController)">
            <summary>
            Confirm that the operation should proceed
            </summary>
            <param name="service">service object to be acted on</param>
            <returns> true if operation should continue, false otherwise </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ServiceBaseCommand.ShouldProcessServiceOperation(System.String,System.String)">
            <summary>
            Confirm that the operation should proceed
            </summary>
            <param name="displayName">display name of service to be acted on</param>
            <param name="serviceName">service name of service to be acted on</param>
            <returns> true if operation should continue, false otherwise </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ServiceBaseCommand.WriteNonTerminatingError(System.ServiceProcess.ServiceController,System.Exception,System.String,System.String,System.Management.Automation.ErrorCategory)">
            <summary>
            Writes a non-terminating error.
            </summary>
            <param name="service"></param>
            <param name="innerException"></param>
            <param name="errorId"></param>
            <param name="errorMessage"></param>
            <param name="category"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ServiceBaseCommand.WriteNonTerminatingError(System.String,System.String,System.Object,System.Exception,System.String,System.String,System.Management.Automation.ErrorCategory)">
            <summary>
            Writes a non-terminating error.
            </summary>
            <param name="serviceName"></param>
            <param name="displayName"></param>
            <param name="targetObject"></param>
            <param name="innerException"></param>
            <param name="errorId"></param>
            <param name="errorMessage"></param>
            <param name="category"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ServiceBaseCommand.WriteNonTerminatingError(System.ServiceProcess.ServiceController,System.String,System.Exception,System.String,System.String,System.Management.Automation.ErrorCategory)">
            <summary>
            Writes a non-terminating error on computer name.
            </summary>
            <param name="service"></param>
            <param name="computername"></param>
            <param name="innerException"></param>
            <param name="errorId"></param>
            <param name="errorMessage"></param>
            <param name="category"></param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.MultipleServiceCommandBase">
            <summary>
            This class implements the base for service commands which can
            operate on multiple services
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.MultipleServiceCommandBase.SelectionMode">
            <summary>
            The various process selection modes
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.MultipleServiceCommandBase.SelectionMode.Default">
            <summary>
            Select all services
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.MultipleServiceCommandBase.SelectionMode.DisplayName">
            <summary>
            Select services matching the supplied names
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.MultipleServiceCommandBase.SelectionMode.InputObject">
            <summary>
            Select services based on pipeline input
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.MultipleServiceCommandBase.SelectionMode.ServiceName">
            <summary>
            Select services by Service name
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.MultipleServiceCommandBase.selectionMode">
            <summary>
            Holds the selection mode setting.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.MultipleServiceCommandBase.serviceNames">
            <remarks>
            The ServiceName parameter is declared in subclasses,
            since it is optional for GetService and mandatory otherwise.
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MultipleServiceCommandBase.DisplayName">
            <summary>
            gets/sets an array of display names for services
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MultipleServiceCommandBase.Include">
            <summary>
            Lets you include particular services.  Services not matching
            one of these (if specified) are excluded.
            These are interpreted as either ServiceNames or DisplayNames
            according to the parameter set.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MultipleServiceCommandBase.Exclude">
            <summary>
            Lets you exclude particular services.  Services matching
            one of these (if specified) are excluded.
            These are interpreted as either ServiceNames or DisplayNames
            according to the parameter set.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MultipleServiceCommandBase.InputObject">
            <summary>
            If the input is a stream of [collections of]
            ServiceController objects, we bypass the ServiceName and
            DisplayName parameters and read the ServiceControllers
            directly.  This allows us to deal with services which
            have wildcard characters in their name (servicename or
            displayname).
            </summary>
            <value>ServiceController objects</value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MultipleServiceCommandBase.AllServices">
            <summary>
            Retrieve the master list of all services
            </summary>
            <value></value>
            <exception cref="T:System.Security.SecurityException">
            MSDN does not document the list of exceptions,
            but it is reasonable to expect that SecurityException is
            among them.  Errors here will terminate the cmdlet.
            </exception>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.MultipleServiceCommandBase.SuppliedComputerName">
            <summary>
            The computer from which to retrieve processes.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MultipleServiceCommandBase.MatchingServices">
            <summary>
            Retrieve the list of all services matching the ServiceName,
            DisplayName, Include and Exclude parameters, sorted by ServiceName.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MultipleServiceCommandBase.MatchingServicesByServiceName">
            <summary>
            Retrieves the list of all services matching the ServiceName,
            Include and Exclude parameters.
            Generates a non-terminating error for each specified
            service name which is not found even though it contains
            no wildcards.
            </summary>
            <returns></returns>
            <remarks>
            We do not use the ServiceController(string serviceName)
            constructor variant, since thr resultant
            ServiceController.ServiceName is the provided serviceName
            even when that differs from the real ServiceName by case.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MultipleServiceCommandBase.MatchingServicesByDisplayName">
            <summary>
            Retrieves the list of all services matching the DisplayName,
            Include and Exclude parameters.
            Generates a non-terminating error for each specified
            display name which is not found even though it contains
            no wildcards.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MultipleServiceCommandBase.MatchingServicesByInput">
            <summary>
            Retrieves the list of all services matching the InputObject,
            Include and Exclude parameters.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MultipleServiceCommandBase.IncludeExcludeAdd(System.Collections.Generic.List{System.ServiceProcess.ServiceController},System.ServiceProcess.ServiceController,System.Boolean)">
            <summary>
            Add <paramref name="service"/> to <paramref name="list"/>,
            but only if it passes the Include and Exclude filters (if present)
            and (if <paramref name="checkDuplicates"/>) if it is not
            already on  <paramref name="list"/>.
            </summary>
            <param name="list">list of services</param>
            <param name="service">service to add to list</param>
            <param name="checkDuplicates">check list for duplicates</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.MultipleServiceCommandBase.Matches(System.ServiceProcess.ServiceController,System.String[])">
            <summary>
            Check whether <paramref name="service"/> matches the list of
            patterns in <paramref name="matchList"/>.
            </summary>
            <param name="service"></param>
            <param name="matchList"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetServiceCommand">
            <summary>
            This class implements the get-service command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetServiceCommand.Name">
            <summary>
            gets/sets an array of service names
            </summary>
            <remarks>
            The ServiceName parameter is declared in subclasses,
            since it is optional for GetService and mandatory otherwise.
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetServiceCommand.ComputerName">
            <summary>
            gets/sets the destination computer name
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetServiceCommand.DependentServices">
            <summary>
            This returns the DependentServices of the specified service. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetServiceCommand.RequiredServices">
            <summary>
            This returns the ServicesDependedOn of the specified service.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetServiceCommand.ProcessRecord">
            <summary>
            Write the service objects
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ServiceOperationBaseCommand">
            <summary>
            This class implements the base for service commands which actually
            act on the service(s).
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ServiceOperationBaseCommand.Name">
            <summary>
            gets/sets an array of service names
            </summary>
            <remarks>
            The ServiceName parameter is declared in subclasses,
            since it is optional for GetService and mandatory otherwise.
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ServiceOperationBaseCommand.InputObject">
            <summary>
            Service controller objects
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ServiceOperationBaseCommand.PassThru">
            <summary>
            Specifies whether to write the objects successfully operated upon
            to the success stream.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ServiceOperationBaseCommand.DoWaitForStatus(System.ServiceProcess.ServiceController,System.ServiceProcess.ServiceControllerStatus,System.ServiceProcess.ServiceControllerStatus,System.String,System.String,System.String)">
            <summary>
            Waits forever for the service to reach the desired status, but
            writes a string to WriteWarning every 2 seconds.
            </summary>
            <param name="serviceController">service on which to operate</param>
            <param name="targetStatus">desired status</param>
            <param name="pendingStatus">
            This is the expected status while the operation is incomplete.
            If the service is in some other state, this means that the
            operation failed.
            </param>
            <param name="resourceIdPending">
            resourceId for a string to be written to verbose stream
            every 2 seconds
            </param>
            <param name="errorId">
            errorId for a nonterminating error if operation fails
            </param>
             <param name="errorMessage">
            errorMessage for a nonterminating error if operation fails
            </param>
            <returns>true if action succeeded</returns>
            <exception cref="T:System.Management.Automation.PipelineStoppedException">
            WriteWarning will throw this if the pipeline has been stopped.
            This means that the delay between hitting CTRL-C and stopping
            the cmdlet should be 2 seconds at most.
            </exception>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ServiceOperationBaseCommand.DoStartService(System.ServiceProcess.ServiceController)">
            <summary>
            This will start the service.
            </summary>
            <param name="serviceController">service to start</param>
            <returns>true iff the service was started</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ServiceOperationBaseCommand.DoStopService(System.ServiceProcess.ServiceController,System.Boolean,System.Boolean)">
            <summary>
            This will stop the service.
            </summary>
            <param name="serviceController">service to stop</param>
            <param name="force">stop dependent services</param>
            <param name="waitForServiceToStop"></param>
            <returns>true iff the service was stopped</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ServiceOperationBaseCommand.HaveAllDependentServicesStopped(System.Collections.Generic.ICollection{System.ServiceProcess.ServiceController})">
            <summary>
            Check if all dependent services are stopped
            </summary>
            <param name="dependentServices"></param>
            <returns>
            True if all dependent services are stopped
            False if not all dependent services are stopped
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ServiceOperationBaseCommand.RemoveNotStoppedServices(System.Collections.Generic.List{System.ServiceProcess.ServiceController})">
            <summary>
            This removes all services that are not stopped from a list of services
            </summary>
            <param name="services">a list of services</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ServiceOperationBaseCommand.DoPauseService(System.ServiceProcess.ServiceController)">
            <summary>
            This will pause the service.
            </summary>
            <param name="serviceController">service to pause</param>
            <returns>true iff the service was paused</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ServiceOperationBaseCommand.DoResumeService(System.ServiceProcess.ServiceController)">
            <summary>
            This will resume the service.
            </summary>
            <param name="serviceController">service to resume</param>
            <returns>true iff the service was resumed</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StopServiceCommand">
            <summary>
            This class implements the stop-service command
            </summary>
            <remarks>
            Note that the services will be sorted before being stopped.
            PM confirms that this is OK.
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StopServiceCommand.Force">
            <summary>
            Specifies whether to force a service to stop
            even if it has dependent services.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StopServiceCommand.NoWait">
            <summary>
            Specifies whether to wait for a service to reach the stopped state before returning
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StopServiceCommand.ProcessRecord">
            <summary>
            Stop the services.
            It is a non-terminating error if -Force is not specified and
             the service has dependent services, whether or not they
             are running.
            It is a non-terminating error if the service stop operation fails.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StartServiceCommand">
            <summary>
            This class implements the start-service command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StartServiceCommand.ProcessRecord">
            <summary>
            Start the services
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SuspendServiceCommand">
            <summary>
            This class implements the suspend-service command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SuspendServiceCommand.ProcessRecord">
            <summary>
            Start the services
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ResumeServiceCommand">
            <summary>
            This class implements the resume-service command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ResumeServiceCommand.ProcessRecord">
            <summary>
            Start the services
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RestartServiceCommand">
            <summary>
            This class implements the restart-service command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RestartServiceCommand.Force">
            <summary>
            Specifies whether to force a service to stop
            even if it has dependent services.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestartServiceCommand.ProcessRecord">
            <summary>
            Stop and restart the services.
            It is a non-terminating error if the service is running,
             -Force is not specified and the service has dependent services,
             whether or not the dependent services are running.
            It is a non-terminating error if the service stop operation fails.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SetServiceCommand">
            <summary>
            This class implements the set-service command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetServiceCommand.ComputerName">
            <summary>
            The following is the definition of the input parameter "ComputerName".
            Set the properties of service running on the list of computer names 
            specified. The default is the local computer.
            Type the NETBIOS name, an IP address, or a fully-qualified domain name of 
            one or more remote computers. To indicate the local computer, use the 
            computer name, "localhost" or a dot (.). When the computer is in a different 
            domain than the user, the fully-qualified domain name is required.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetServiceCommand.Name">
            <summary>
            service name
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetServiceCommand.DisplayName">
            <summary>
            The following is the definition of the input parameter "DisplayName".
            Specifies a new display name for the cmdlet.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetServiceCommand.Description">
            <summary>
            The following is the definition of the input parameter "Description".
            Specifies a new description for the service.
            The service description appears in Services in Computer Management. 
            Description is not a property of the ServiceController object that 
            Get-Service retrieve
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetServiceCommand.StartupType">
            <summary>
            The following is the definition of the input parameter "StartupType".
            Changes the starting mode of the service. Valid values for StartupType are: 
            -- Automatic: Start when the system starts.
            -- Manual   : Starts only when started by a user or program.
            -- Disabled : Can
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetServiceCommand.Status">
            <summary>
            The following is the definition of the input parameter "Status".
            This specifies what state the service should be in (e.g. Running, Stopped, 
            Paused).  If it is already in that state, do nothing.  If it is not, do the 
            appropriate action to bring about the desired result (start/stop/suspend the 
            service) and issue an error if this cannot be achieved. 
             Status can be  Paused ,  Running  and  Stopped
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetServiceCommand.InputObject">
            <summary>
            The following is the definition of the input parameter "InputObject".
            Specifies ServiceController object representing the services to be stopped. 
            Enter a variable that contains the objects or type a command or expression 
            that gets the objects.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetServiceCommand.Include">
            <summary>
            This is not a parameter for this cmdlet.
            </summary>        
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetServiceCommand.Exclude">
            <summary>
            This is not a parameter for this cmdlet.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetServiceCommand.ProcessRecord">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.NewServiceCommand">
            <summary>
            This class implements the set-service command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewServiceCommand.Name">
            <summary>
            Name of the service to create
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewServiceCommand.BinaryPathName">
            <summary>
            The executable which implements this service
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewServiceCommand.DisplayName">
            <summary>
            DisplayName of the service to create
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewServiceCommand.Description">
            <summary>
            Description of the service to create
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewServiceCommand.StartupType">
            <summary>
            Should the service start automatically?
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewServiceCommand.Credential">
            <summary>
            Account under which the service should run
            </summary>
            <value></value>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewServiceCommand.DependsOn">
            <summary>
            Other services on which the new service depends
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NewServiceCommand.BeginProcessing">
            <summary>
            Create the service
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ServiceCommandException">
            <summary>
            Non-terminating errors occurring in the service noun commands
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ServiceCommandException.#ctor">
            <summary>
            unimplemented standard constructor
            </summary>
            <returns> doesn't return </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ServiceCommandException.#ctor(System.String)">
            <summary>
            standard constructor
            </summary>
            <param name="message"></param>
            <returns> constructed object </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ServiceCommandException.#ctor(System.String,System.Exception)">
            <summary>
            standard constructor
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ServiceCommandException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            serialization constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
            <returns> constructed object </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ServiceCommandException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serializer
            </summary>
            <param name="info"> serialization information </param>
            <param name="context"> streaming context </param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ServiceCommandException.ServiceName">
            <summary>
            Name of the service which could not be found or operated upon
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NativeMethods.CreateJobObject(System.IntPtr,System.String)">
            <summary>
            CreateJobObject API creates or opens a job object.
            </summary>
            <param name="lpJobAttributes">
            A pointer to a SECURITY_ATTRIBUTES structure that specifies the security descriptor for the 
            job object and determines whether child processes can inherit the returned handle. 
            If lpJobAttributes is NULL, the job object gets a default security descriptor 
            and the handle cannot be inherited.
            </param>
            <param name="lpName">
            The name of the job.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the job object. 
            If the object existed before the function call, the function 
            returns a handle to the existing job object.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NativeMethods.AssignProcessToJobObject(System.Runtime.InteropServices.SafeHandle,System.IntPtr)">
            <summary>
            AssignProcessToJobObject API is used to assign a process to an existing job object.
            </summary>
            <param name="hJob">
            A handle to the job object to which the process will be associated.
            </param>
            <param name="hProcess">
            A handle to the process to associate with the job object.
            </param>
            <returns>If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NativeMethods.QueryInformationJobObject(System.Runtime.InteropServices.SafeHandle,System.Int32,Microsoft.PowerShell.Commands.JOBOBJECT_BASIC_PROCESS_ID_LIST@,System.Int32,System.IntPtr)">
            <summary>
            Retrieves job state information from the job object.
            </summary>
            <param name="hJob">
            A handle to the job whose information is being queried.
            </param>
            <param name="JobObjectInfoClass">
            The information class for the limits to be queried.
            </param>
            <param name="lpJobObjectInfo">
            The limit or job state information. 
            </param>
            <param name="cbJobObjectLength">
            The count of the job information being queried, in bytes.
            </param>
            <param name="lpReturnLength">
            A pointer to a variable that receives the length of 
            data written to the structure pointed to by the lpJobObjectInfo parameter.
            </param>
            <returns>If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero.
            </returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.TestConnectionCommand">
            <summary>
            This cmdlet is used to test whether a particular host is reachable across an 
            IP network. It works by sending ICMP "echo request" packets to the target 
            host and listening for ICMP "echo response" replies. This cmdlet prints a 
            statistical summary when finished.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestConnectionCommand.AsJob">
            <summary>
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestConnectionCommand.DcomAuthentication">
            <summary>
            The following is the definition of the input parameter "DcomAuthentication".
            Specifies the authentication level to be used with WMI connection. Valid 
            values are:
            
            Unchanged = -1,
            Default = 0,
            None = 1,
            Connect = 2,
            Call = 3,
            Packet = 4,
            PacketIntegrity = 5,
            PacketPrivacy = 6.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestConnectionCommand.WsmanAuthentication">
            <summary>
            The authentication options for CIM_WSMan connection
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestConnectionCommand.Protocol">
            <summary>
            Specify the protocol to use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestConnectionCommand.BufferSize">
            <summary>
            The following is the definition of the input parameter "BufferSize".
            Buffer size sent with the this command. The default value is 32.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestConnectionCommand.ComputerName">
            <summary>
            The following is the definition of the input parameter "ComputerName".
            Value of the address requested. The form of the value can be either the 
            computer name ("wxyz1234"), IPv4 address ("192.168.177.124"), or IPv6 
            address ("2010:836B:4179::836B:4179").
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestConnectionCommand.Count">
            <summary>
            The following is the definition of the input parameter "Count".
            Number of echo requests to send.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestConnectionCommand.Credential">
            <summary>
            The following is the definition of the input parameter "Credential".
            Specifies a user account that has permission to perform this action. Type a 
            user-name, such as "User01" or "Domain01\User01", or enter a PSCredential 
            object, such as one from the Get-Credential cmdlet
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestConnectionCommand.Source">
            <summary>
            The following is the definition of the input parameter "FromComputerName".
            Specifies the Computer names where the ping request is originated from.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestConnectionCommand.Impersonation">
            <summary>
            The following is the definition of the input parameter "Impersonation".
            Specifies the impersonation level to use when calling the WMI method. Valid 
            values are: 
            
            Default = 0,
            Anonymous = 1,
            Identify = 2,
            Impersonate = 3,
            Delegate = 4.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestConnectionCommand.ThrottleLimit">
            <summary>
            The following is the definition of the input parameter "ThrottleLimit".
            The number of concurrent computers on which the command will be allowed to 
            execute
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestConnectionCommand.TimeToLive">
            <summary>
            The following is the definition of the input parameter "TimeToLive".
            Life span of the packet in seconds. The value is treated as an upper limit. 
            All routers must decrement this value by 1 (one). When this value becomes 0 
            (zero), the packet is dropped by the router. The default value is 80 
            seconds. The hops between routers rarely take this amount of time.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestConnectionCommand.Delay">
            <summary>
            delay parameter
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestConnectionCommand.Quiet">
            <summary>
            quiet parameter
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TestConnectionCommand.BeginProcessing">
            <summary>
            To begin processing Test-connection
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TestConnectionCommand.ProcessRecord">
            <summary>
            Process Record
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TestConnectionCommand.StopProcessing">
            <summary>
            to implement ^C
            </summary> 
        </member>
        <member name="T:Microsoft.PowerShell.Commands.EnableComputerRestoreCommand">
            <summary>
            Cmdlet for Enable-ComputerRestore
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.EnableComputerRestoreCommand.Drive">
            <summary>
            Specifies the Drive on which the system restore will be enabled.
            The drive string should be of the form "C:\". 
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.EnableComputerRestoreCommand.Dispose">
            <summary>
            Dispose Method
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.EnableComputerRestoreCommand.Dispose(System.Boolean)">
            <summary>
            Dispose Method.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.EnableComputerRestoreCommand.BeginProcessing">
            <summary>
            To Enable the Restore Point of the drives
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.EnableComputerRestoreCommand.StopProcessing">
            <summary>
            to implement ^C
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.DisableComputerRestoreCommand">
            <summary>
            This cmdlet is to Disable Computer Restore points.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.DisableComputerRestoreCommand.Drive">
            <summary>
            Specifies the Drive on which the system restore will be enabled.
            The drive string should be of the form "C:\". 
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.DisableComputerRestoreCommand.Dispose">
            <summary>
            Dispose Method
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.DisableComputerRestoreCommand.Dispose(System.Boolean)">
            <summary>
            Dispose Method.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.DisableComputerRestoreCommand.BeginProcessing">
            <summary>
            To Disable the Restore Point of the drives
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.DisableComputerRestoreCommand.StopProcessing">
            <summary>
            to implement ^C
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.CheckpointComputerCommand">
            <summary>
            Creates the Restore Point for the Local computer 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CheckpointComputerCommand.Description">
            <summary>
            The description to be displayed so the user can easily identify a restore point. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.CheckpointComputerCommand.RestorePointType">
            <summary>
            The type of restore point. 
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CheckpointComputerCommand.exceptionfromnewthread">
            <summary>
            Shared Exception. Used when exception thrown from the Restore point thread.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CheckpointComputerCommand.Dispose">
            <summary>
            Dispose Method
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CheckpointComputerCommand.BeginProcessing">
            <summary>
            BeginProcessing method.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetComputerRestorePointCommand">
            <summary>
            This cmdlet is to Get Computer Restore points.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetComputerRestorePointCommand.RestorePoint">
            <summary>
            This cmdlet is to get Computer Restore points.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetComputerRestorePointCommand.LastStatus">
            <summary>
            This cmdlet is to get Computer Restore points.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetComputerRestorePointCommand.Dispose">
            <summary>
            Dispose Method
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetComputerRestorePointCommand.Dispose(System.Boolean)">
            <summary>
            Dispose Method.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetComputerRestorePointCommand.BeginProcessing">
            <summary>
            Gets the list of Computer Restore point.
            ID parameter id used to refer the sequence no. When given searched with particular 
            sequence no. and returns the restore point
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetComputerRestorePointCommand.StopProcessing">
            <summary>
            to implement ^C
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RestartComputerTimeoutException">
            <summary>
            This exception is thrown when the timeout expires before a computer finishes restarting
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RestartComputerTimeoutException.ComputerName">
            <summary>
            Name of the computer that is restarting
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RestartComputerTimeoutException.Timeout">
            <summary>
            The timeout value specified by the user. It indicates the seconds to wait before timeout.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestartComputerTimeoutException.#ctor(System.String,System.Int32,System.String,System.String)">
            <summary>
            Construct a RestartComputerTimeoutException.
            </summary>
            <param name="computerName"></param>
            <param name="timeout"></param>
            <param name="message"></param>
            <param name="errorId"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestartComputerTimeoutException.#ctor">
            <summary>
            Construct a RestartComputerTimeoutException
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestartComputerTimeoutException.#ctor(System.String)">
             <summary>
             Constructs a RestartComputerTimeoutException
             </summary>
            
             <param name="message">
             The message used in the exception.
             </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestartComputerTimeoutException.#ctor(System.String,System.Exception)">
             <summary>
             Constructs a RestartComputerTimeoutException
             </summary>
            
             <param name="message">
             The message used in the exception.
             </param>
            
             <param name="innerException"> 
             An exception that led to this exception.
             </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestartComputerTimeoutException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor for class RestartComputerTimeoutException
            </summary>
            
            <param name="info"> 
            serialization information 
            </param>
            
            <param name="context"> 
            streaming context 
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestartComputerTimeoutException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serializes the RestartComputerTimeoutException.
            </summary>
            
            <param name="info"> 
            serialization information 
            </param>
            
            <param name="context"> 
            streaming context 
            </param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WaitForServiceTypes">
            <summary>
            Defines the services that Restart-Computer can wait on
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WaitForServiceTypes.Wmi">
            <summary>
            Wait for the WMI service to be ready
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WaitForServiceTypes.WinRM">
            <summary>
            Wait for the WinRM service to be ready
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WaitForServiceTypes.PowerShell">
            <summary>
            Wait for the PowerShell to be ready
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RestartComputerCommand">
            <summary>
            Restarts  the computer 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RestartComputerCommand.AsJob">
            <summary>
            Used to start a command remotely as a Job. The Job results are collected 
            and stored in the global cache on the client machine. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RestartComputerCommand.DcomAuthentication">
            <summary>
            The following is the definition of the input parameter "Authentication".
            Specifies the authentication level to be used with WMI connection. Valid 
            values are:
            
            Unchanged = -1,
            Default = 0,
            None = 1,
            Connect = 2,
            Call = 3,
            Packet = 4,
            PacketIntegrity = 5,
            PacketPrivacy = 6.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RestartComputerCommand.Impersonation">
            <summary>
            The following is the definition of the input parameter "Impersonation".
            Specifies the impersonation level to use when calling the WMI method. Valid 
            values are: 
            
            Default = 0,
            Anonymous = 1,
            Identify = 2,
            Impersonate = 3,
            Delegate = 4.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RestartComputerCommand.WsmanAuthentication">
            <summary>
            The authentication options for CIM_WSMan connection
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RestartComputerCommand.Protocol">
            <summary>
            Specify the protocol to use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RestartComputerCommand.ComputerName">
            <summary>
            Specifies the computer (s)Name on which this command is executed. 
            When this parameter is omitted, this cmdlet restarts the local computer.
            Type the NETBIOS name, IP address, or fully-qualified domain name of one 
            or more computers in a comma-separated list. To specify the local computer, type the computername or "localhost". 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RestartComputerCommand.Credential">
            <summary>
            The following is the definition of the input parameter "Credential".
            Specifies a user account that has permission to perform this action. Type a 
            user-name, such as "User01" or "Domain01\User01", or enter a PSCredential 
            object, such as one from the Get-Credential cmdlet
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RestartComputerCommand.Force">
            <summary>
            Using Force in conjunction with Reboot on a 
            remote computer immediately reboots the remote computer.  
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RestartComputerCommand.ThrottleLimit">
            <summary>
            Allows the user of the cmdlet to specify a throttling value
            for throttling the number of remote operations that can
            be executed simultaneously.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RestartComputerCommand.Wait">
            <summary>
            Specify the Wait parameter. Prompt will be blocked is the Timeout is not 0
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RestartComputerCommand.Timeout">
            <summary>
            Specify the Timeout parameter. 
            Negative value indicates wait infinitely.
            Positive value indicates the seconds to wait before timeout.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RestartComputerCommand.For">
            <summary>
            Specify the For parameter.
            Wait for the specific service before unblocking the prompt.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RestartComputerCommand.Delay">
            <summary>
            Specify the Delay parameter.
            The specific time interval (in second) to wait between network pings or service queries.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RestartComputerCommand.TestPowershellScript">
            <summary>
            Script to test if the PowerShell is ready
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RestartComputerCommand._indicator">
            <summary>
            The indicator to use when show progress
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RestartComputerCommand._activityId">
            <summary>
            The activity id
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RestartComputerCommand.SecondsToWaitForRestartToBegin">
            <summary>
            After call 'Shutdown' on the target computer, wait a few
            seconds for the restart to begin.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RestartComputerCommand._timeoutInMilliseconds">
            <summary>
            Actual time out in seconds
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RestartComputerCommand._exit">
            <summary>
            Indicate to exit
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RestartComputerCommand._timeUp">
            <summary>
            Indicate to exit
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.RestartComputerCommand._waitHandler">
            <summary>
            A waithandler to wait on. Current thread will wait on it during the delay interval.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestartComputerCommand.Dispose">
            <summary>
            Dispose Method
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestartComputerCommand.Dispose(System.Boolean)">
            <summary>
            Dispose Method.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestartComputerCommand.ValidateComputerNames">
            <summary>
            Validate parameters for 'DefaultSet'
            1. When the Wait is specified, the computername cannot contain the local machine
            2. If the local machine is present, make sure it is at the end of the list (so the remote ones get restarted before the local machine reboot).
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestartComputerCommand.WriteProgress(System.String,System.String,System.Int32,System.Management.Automation.ProgressRecordType)">
            <summary>
            Write out progress
            </summary>
            <param name="activity"></param>
            <param name="status"></param>
            <param name="percent"></param>
            <param name="progressRecordType"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestartComputerCommand.CalculateProgressPercentage(System.String)">
            <summary>
            Calculate the progress percentage
            </summary>
            <param name="currentStage"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestartComputerCommand.OnTimedEvent(System.Object)">
            <summary>
            Event handler for the timer
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestartComputerCommand.TestWinrmConnection(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Threading.CancellationToken)">
            <summary>
            Test WinRM connectivity for the restarting machine
            </summary>
            <param name="computerNames"></param>
            <param name="nextTestList"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestartComputerCommand.TestPowerShell(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Management.Automation.PowerShell,System.Management.Automation.PSCredential)">
            <summary>
            Test the PowerShell state for the restarting computer
            </summary>
            <param name="computerNames"></param>
            <param name="nextTestList"></param>
            <param name="powershell"></param>
            <param name="credential"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestartComputerCommand.RestartOneComputerUsingDcom(System.Management.Automation.PSCmdlet,System.Boolean,System.String,System.Object[],System.Management.ConnectionOptions)">
            <summary>
            Restart one computer
            </summary>
            <param name="cmdlet"></param>
            <param name="isLocalhost"></param>
            <param name="computerName"></param>
            <param name="flags"></param>
            <param name="options"></param>
            <returns>
            True if the restart was successful
            False otherwise
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestartComputerCommand.BeginProcessing">
            <summary>
            BeginProcessing method.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestartComputerCommand.ProcessRecord">
            <summary>
            ProcessRecord method.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestartComputerCommand.StopProcessing">
            <summary>
            to implement ^C
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StopComputerCommand">
            <summary>
            cmdlet to stop computer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StopComputerCommand.AsJob">
            <summary>
            parameter
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StopComputerCommand.DcomAuthentication">
            <summary>
            The following is the definition of the input parameter "DcomAuthentication".
            Specifies the authentication level to be used with WMI connection. Valid 
            values are:
            
            Unchanged = -1,
            Default = 0,
            None = 1,
            Connect = 2,
            Call = 3,
            Packet = 4,
            PacketIntegrity = 5,
            PacketPrivacy = 6.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StopComputerCommand.WsmanAuthentication">
            <summary>
            The authentication options for CIM_WSMan connection
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StopComputerCommand.Protocol">
            <summary>
            Specify the protocol to use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StopComputerCommand.ComputerName">
            <summary>
            The following is the definition of the input parameter "ComputerName".
            Value of the address requested. The form of the value can be either the 
            computer name ("wxyz1234"), IPv4 address ("192.168.177.124"), or IPv6 
            address ("2010:836B:4179::836B:4179").
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StopComputerCommand.Credential">
            <summary>
            The following is the definition of the input parameter "Credential".
            Specifies a user account that has permission to perform this action. Type a 
            user-name, such as "User01" or "Domain01\User01", or enter a PSCredential 
            object, such as one from the Get-Credential cmdlet
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StopComputerCommand.Impersonation">
            <summary>
            The following is the definition of the input parameter "Impersonation".
            Specifies the impersonation level to use when calling the WMI method. Valid 
            values are: 
            
            Default = 0,
            Anonymous = 1,
            Identify = 2,
            Impersonate = 3,
            Delegate = 4.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StopComputerCommand.ThrottleLimit">
            <summary>
            The following is the definition of the input parameter "ThrottleLimit".
            The number of concurrent computers on which the command will be allowed to 
            execute
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StopComputerCommand.Force">
            <summary>
            The following is the definition of the input parameter "ThrottleLimit".
            The number of concurrent computers on which the command will be allowed to 
            execute
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StopComputerCommand.Dispose">
            <summary>
            Dispose Method
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StopComputerCommand.BeginProcessing">
            <summary>
            BeginProcessing
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StopComputerCommand.ProcessRecord">
            <summary>
            ProcessRecord
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StopComputerCommand.StopProcessing">
            <summary>
            to implement ^C
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RestoreComputerCommand">
            <summary>
            This cmdlet is to Restore Computer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RestoreComputerCommand.RestorePoint">
            <summary>
            Restorepoint parameter
            </summary>        
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestoreComputerCommand.Dispose">
            <summary>
            Dispose Method
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestoreComputerCommand.Dispose(System.Boolean)">
            <summary>
            Dispose Method.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestoreComputerCommand.BeginProcessing">
            <summary>
            Restores the computer with 
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RestoreComputerCommand.StopProcessing">
            <summary>
            to implement ^C
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.JoinOptions">
            <summary>
            Options for joining a computer to a domain
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.JoinOptions.AccountCreate">
            <summary>
            Create account on the domain
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.JoinOptions.Win9XUpgrade">
            <summary>
            Join operation is part of an upgrade
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.JoinOptions.UnsecuredJoin">
            <summary>
            Perform an unsecure join
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.JoinOptions.PasswordPass">
            <summary>
            Indicate that the password passed to the join operation is the local machine account password, not a user password.
            It's valid only for unsecure join
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.JoinOptions.DeferSPNSet">
            <summary>
            Writing SPN and DNSHostName attributes on the computer object should be deferred until the rename operation that 
            follows the join operation
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.JoinOptions.JoinWithNewName">
            <summary>
            Join the target machine with a new name queried from the registry. This options is used if the rename has been called prior
            to rebooting the machine
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.JoinOptions.JoinReadOnly">
            <summary>
            Use a readonly domain controller
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.JoinOptions.InstallInvoke">
            <summary>
            Invoke during insatll
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.AddComputerCommand">
            <summary>
            Adds the specified computer(s) to the Domain or Work Group. If the account 
            does not already exist on the domain, it also creates one (see notes for 
            implementation details).
            If the computer is already joined to a domain, it can be moved to a new 
            domain (see notes for implementation details).
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddComputerCommand.ComputerName">
            <summary>
            Target computer names
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddComputerCommand.LocalCredential">
            <summary>
            The local admin credential to the target computer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddComputerCommand.UnjoinDomainCredential">
            <summary>
            The domain credential used to unjoin a domain
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddComputerCommand.Credential">
            <summary>
            The domain credential.
            In DomainParameterSet, it is for the domain to join to.
            In WorkgroupParameterSet, it is for the doamin to disjoin from.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddComputerCommand.DomainName">
            <summary>
            Name of the domain to join
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddComputerCommand.OUPath">
            <summary>
            The organization unit (OU). It's the path on the AD under which the new account will
            be created
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddComputerCommand.Server">
            <summary>
            The name of a domain controller that performs the add.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddComputerCommand.Unsecure">
            <summary>
            Perform an unsecure join.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddComputerCommand.Options">
            <summary>
            Additional options for the "join domain" operation
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddComputerCommand.WorkgroupName">
            <summary>
            Name of the workgroup to join in.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddComputerCommand.Restart">
            <summary>
            Restart the target computer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddComputerCommand.PassThru">
            <summary>
            Emit the output.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddComputerCommand.NewName">
            <summary>
            New names for the target computers
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AddComputerCommand.Force">
            <summary>
            To suppress ShouldContinue
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.AddComputerCommand.UnjoinDomain(System.Management.ManagementObject,System.String,System.String,System.String,System.String)">
            <summary>
            Unjoin the computer from its current domain
            <remarks>
            In the DomainParameterSet, the UnjoinDomainCredential is our first choice to unjoin a domain.
            But if the UnjoinDomainCredential is not specified, the DomainCredential will be our second 
            choice. This is to keep the backward compatibility. In Win7, we can do:
                 Add-Computer -DomianName domain1 -Credential $credForDomain1AndDomain2
            to switch the local machine that is currently in domain2 to domain1.
            
            Since DomainCredential has an alias "Credential", the same command should still work for the
            new Add-Computer cmdlet.
            
            In the WorkgroupParameterSet, the UnjoinDomainCredential is the only choice.
            </remarks>
            </summary>
            <param name="computerSystem"></param>
            <param name="computerName"></param>
            <param name="curDomainName"></param>
            <param name="dUserName"></param>
            <param name="dPassword"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.AddComputerCommand.JoinDomain(System.Management.ManagementObject,System.String,System.String,System.String)">
            <summary>
            Join a domain from a workgroup
            </summary>
            <remarks>
            If a computer is already in a domain, we first unjoin it from its current domain, and
            then do the join operation to the new domain. So when this method is invoked, we are 
            currently in a workgroup
            </remarks>
            <param name="computerSystem"></param>
            <param name="computerName"></param>
            <param name="oldDomainName"></param>
            <param name="curWorkgroupName"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.AddComputerCommand.JoinWorkgroup(System.Management.ManagementObject,System.String,System.String)">
            <summary>
            Join in a new workgroup from the current workgroup
            </summary>
            <param name="computerSystem"></param>
            <param name="computerName"></param>
            <param name="oldDomainName"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.AddComputerCommand.RenameComputer(System.Management.ManagementObject,System.String,System.String)">
            <summary>
            Rename the computer in workgroup
            </summary>
            <param name="computerSystem"></param>
            <param name="computerName"></param>
            <param name="newName"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.AddComputerCommand.WriteErrorHelper(System.String,System.String,System.Object,System.Management.Automation.ErrorCategory,System.Boolean,System.Object[])">
            <summary>
            Helper method to write out non-terminating errors
            </summary>
            <param name="resourceString"></param>
            <param name="errorId"></param>
            <param name="targetObj"></param>
            <param name="category"></param>
            <param name="terminating"></param>
            <param name="args"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.AddComputerCommand.BeginProcessing">
            <summary>
            BeginProcessing method
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.AddComputerCommand.ProcessRecord">
            <summary>
            ProcessRecord method
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.AddComputerCommand.EndProcessing">
            <summary>
            EndProcessing method
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RemoveComputerCommand">
            <summary>
            Removes the Specified Computer(s) from the relevant Domain or Work Group 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveComputerCommand.UnjoinDomainCredential">
            <summary>
            The domain credential is used for authenticating to the domain controller.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveComputerCommand.LocalCredential">
            <summary>
            The local admin credential for authenticating to the target computer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveComputerCommand.Restart">
            <summary>
            Restart parameter
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveComputerCommand.ComputerName">
            <summary>
            The target computer names to remove from the domain
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveComputerCommand.Force">
            <summary>
            Force parameter (to suppress the shouldprocess and shouldcontinue)
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveComputerCommand.PassThru">
            <summary>
            Only emit if passthru is specified. One bool/string pair for each 
            computer that was joined. Bool = success/failure. String = ComputerName.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveComputerCommand.WorkgroupName">
            <summary>
            Specify the workgroup name to join in if the target machine is removed from
            the domain
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RemoveComputerCommand.ProcessRecord">
            <summary>
            ProcessRecord method.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RemoveComputerCommand.EndProcessing">
            <summary>
            EndProcessing method: deal with the local computer in the end
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RenameComputerCommand">
            <summary>
            Renames a domain computer and its corresponding domain account or a 
            workgroup computer. Use this command to rename domain workstations and local 
            machines only. It cannot be used to rename Domain Controllers.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameComputerCommand.ComputerName">
            <summary>
            Target computers to rename
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameComputerCommand.PassThru">
            <summary>
            Emit the output.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameComputerCommand.DomainCredential">
            <summary>
            The domain credential of the domain the target computer joined
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameComputerCommand.LocalCredential">
            <summary>
            The administrator credential of the target computer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameComputerCommand.NewName">
            <summary>
            New names for the target computers
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameComputerCommand.Force">
            <summary>
            Suppress the ShouldContinue
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameComputerCommand.Restart">
            <summary>
            To restart the target computer after rename it
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameComputerCommand.WsmanAuthentication">
            <summary>
            The authentication options for CIM_WSMan connection
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameComputerCommand.Protocol">
            <summary>
            Specify the protocol to use
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RenameComputerCommand.ValidateComputerName">
            <summary>
            Check to see if the target computer is the local machine
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RenameComputerCommand.BeginProcessing">
            <summary>
            Begin Processing
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RenameComputerCommand.ProcessRecord">
            <summary>
            ProcessRecord method.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RenameComputerCommand.EndProcessing">
            <summary>
            EndProcessing method
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.TestComputerSecureChannelCommand">
            <summary>
            This cmdlet queries the status of trust relationships and will remove and 
            rebuild the trust if specified.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestComputerSecureChannelCommand.Repair">
            <summary>
            Repair the secure channel between the local machine with the domain, if it's broken
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestComputerSecureChannelCommand.Server">
            <summary>
            The trusted domain controller to operate "Repair" on.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.TestComputerSecureChannelCommand.Credential">
            <summary>
            The domain credential for authenticating to the domain the local machine joined
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TestComputerSecureChannelCommand.BeginProcessing">
            <summary>
            BeginProcessing method
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TestComputerSecureChannelCommand.ProcessRecord">
            <summary>
            ProcessRecord method.
            Suppress the message about NetApiBufferFree. The retuned results are
            actually used, but only in checked builds
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ResetComputerMachinePasswordCommand">
            <summary>
            Resets the computer machine password used to authenticate with DCs.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ResetComputerMachinePasswordCommand.Server">
            <summary>
            The following is the definition of the input parameter "Server".
            Specifies the name of the domain controller to use for setting the machine 
            account password.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ResetComputerMachinePasswordCommand.Credential">
            <summary>
            The domain credential for authenticating to the domain the local machine joined
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ResetComputerMachinePasswordCommand.ThrowOutLsaError(System.UInt32,System.Management.Automation.PSCmdlet)">
            <summary>
            Throw out terminating error for LSA function invocations
            </summary>
            <param name="ret"></param>
            <param name="cmdlet"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ResetComputerMachinePasswordCommand.ResetMachineAccountPassword(System.String,System.String,System.String,System.Management.Automation.PSCredential,System.Management.Automation.PSCmdlet)">
            <summary>
            Reset machine account password
            </summary>
            <param name="domain"></param>
            <param name="localMachineName"></param>
            <param name="server"></param>
            <param name="credential"></param>
            <param name="cmdlet"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ResetComputerMachinePasswordCommand.BeginProcessing">
            <summary>
            BeginProcessing method.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ResetComputerMachinePasswordCommand.ProcessRecord">
            <summary>
            ProcessRecord method
            Suppress the message about LsaFreeMemory and LsaClose. The retuned results are
            actually used, but only in checked builds
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SAMAPI">
            <summary>
            the static class for calling the the NetJoinDomain function.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SAMAPI.LSA_UNICODE_STRING">
            <summary>
            Structure for the LSA unicode string
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SAMAPI.LSA_OBJECT_ATTRIBUTES">
            <summary>
            Structure for the LSA object attributes
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SAMAPI.LSA_ACCESS">
            <summary>
            The LSA access mask
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SAMAPI.LsaOpenPolicy(Microsoft.PowerShell.Commands.SAMAPI.LSA_UNICODE_STRING@,Microsoft.PowerShell.Commands.SAMAPI.LSA_OBJECT_ATTRIBUTES@,System.UInt32,System.IntPtr@)">
            <summary>
            LsaOpenPolicy function
            </summary>
            <param name="systemName"></param>
            <param name="objectAttributes"></param>
            <param name="desiredAccess"></param>
            <param name="policyHandle"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SAMAPI.LsaOpenSecret(System.IntPtr,Microsoft.PowerShell.Commands.SAMAPI.LSA_UNICODE_STRING@,System.UInt32,System.IntPtr@)">
            <summary>
            LsaOpenSecret function
            </summary>
            <param name="policyHandle"></param>
            <param name="secretName"></param>
            <param name="accessMask"></param>
            <param name="secretHandle"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SAMAPI.LsaCreateSecret(System.IntPtr,Microsoft.PowerShell.Commands.SAMAPI.LSA_UNICODE_STRING@,System.UInt32,System.IntPtr@)">
            <summary>
            LsaCreateSecret function
            </summary>
            <param name="policyHandle"></param>
            <param name="secretName"></param>
            <param name="desiredAccess"></param>
            <param name="secretHandle"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SAMAPI.LsaQuerySecret(System.IntPtr,System.IntPtr@,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            LsaQuerySecret function
            </summary>
            <param name="secretHandle"></param>
            <param name="currentValue"></param>
            <param name="currentValueSetTime"></param>
            <param name="oldValue"></param>
            <param name="oldValueSetTime"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SAMAPI.LsaSetSecret(System.IntPtr,Microsoft.PowerShell.Commands.SAMAPI.LSA_UNICODE_STRING@,Microsoft.PowerShell.Commands.SAMAPI.LSA_UNICODE_STRING@)">
            <summary>
            LsaSetSecret function
            </summary>
            <param name="secretHandle"></param>
            <param name="currentValue"></param>
            <param name="oldValue"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SAMAPI.LsaNtStatusToWinError(System.Int32)">
            <summary>
            LsaNtStatusToWinError function
            </summary>
            <param name="ntStatus"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SAMAPI.LsaClose(System.IntPtr)">
            <summary>
            LsaClose function
            </summary>
            <param name="policyHandle"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SAMAPI.LsaFreeMemory(System.IntPtr)">
            <summary>
            LsaFreeMemory function
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SAMAPI.InitLsaString(System.String,Microsoft.PowerShell.Commands.SAMAPI.LSA_UNICODE_STRING@)">
            <summary>
            Initialize a LSA_UNICODE_STRING
            </summary>
            <param name="s"></param>
            <param name="lus"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SAMAPI.FreeLsaString(Microsoft.PowerShell.Commands.SAMAPI.LSA_UNICODE_STRING@)">
            <summary>
            Free the LSA_UNICODE_STRING
            </summary>
            <param name="s"></param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SAMAPI.NetLogonInfo2">
            <summary>
            The NETLOGON_INFO_2 struct used for function I_NetLogonControl2
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SAMAPI.NetLogonInfo2.PdcConnectionStatus">
            <summary>
            Secure channel status with the primary domain controller
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SAMAPI.NetLogonInfo2.TrustedDcName">
            <summary>
            Name of the trusted domain controller
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SAMAPI.NetLogonInfo2.TdcConnectionStatus">
            <summary>
            Secure channel status with the specified trusted domain controller
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SAMAPI.I_NetLogonControl2(System.String,System.UInt32,System.UInt32,System.IntPtr@,System.IntPtr@)">
            <summary>
            To Reset a passowrd for a computer in domain.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ComputerChangeInfo">
            <summary>
            The object returned by SAM Computer cmdlets representing the status of the target machine.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerChangeInfo.HasSucceeded">
            <summary>
            The HasSuceeded which shows the operation was success or not
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerChangeInfo.ComputerName">
            <summary>
            The ComputerName on which the operation is done.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ComputerChangeInfo.ToString">
            <summary>
            Returns the string representation of this object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ComputerChangeInfo.FormatLine(System.String,System.String)">
            <summary>
            Formats a line for use in ToString.
            </summary>
            <param name="HasSucceeded"></param>
            <param name="computername"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RenameComputerChangeInfo">
            <summary>
            The object returned by Rename-Computer cmdlet representing the status of the target machine.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameComputerChangeInfo.HasSucceeded">
            <summary>
            The status which shows the operation was success or failure.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameComputerChangeInfo.NewComputerName">
            <summary>
            The NewComputerName which represents the target machine.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RenameComputerChangeInfo.OldComputerName">
            <summary>
            The OldComputerName which represented the target machine.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RenameComputerChangeInfo.ToString">
            <summary>
            Returns the string representation of this object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RenameComputerChangeInfo.FormatLine(System.String,System.String,System.String)">
            <summary>
            Formats a line for use in ToString.
            </summary>
            <param name="HasSucceeded"></param>
            <param name="newcomputername"></param>
            <param name="oldcomputername"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ComputerWMIHelper">
            <summary>
            Helper Class used by Stop-Computer,Restart-Computer and Test-Connection
            Also Contain constants used by System Restore related Cmdlets.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ComputerWMIHelper.NetBIOSNameMaxLength">
            <summary>
            The maximum length of a valid NetBIOS name
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ComputerWMIHelper.WMI_Class_SystemRestore">
            <summary>
            System Restore Class used by Cmdlets
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ComputerWMIHelper.WMI_Class_OperatingSystem">
            <summary>
            OperatingSystem WMI class used by Cmdlets
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ComputerWMIHelper.WMI_Class_Service">
            <summary>
            Service WMI class used by Cmdlets
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ComputerWMIHelper.WMI_Class_ComputerSystem">
            <summary>
            Win32_ComputerSystem WMI class used by Cmdlets
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ComputerWMIHelper.WMI_Class_PingStatus">
            <summary>
            Ping Class used by Cmdlet.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ComputerWMIHelper.WMI_Path_CIM">
            <summary>
            CIMV2 path
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ComputerWMIHelper.WMI_Path_Default">
            <summary>
            Default path
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ComputerWMIHelper.ErrorCode_Interface">
            <summary>
            The error says The interface is unknown.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ComputerWMIHelper.ErrorCode_Service">
            <summary>
            This error says An instance of the service is already running.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ComputerWMIHelper.SE_SHUTDOWN_NAME">
            <summary>
            The name of the privilege to shutdown a local system
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ComputerWMIHelper.SE_REMOTE_SHUTDOWN_NAME">
            <summary>
            The name of the privilege to shutdown a remote system
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ComputerWMIHelper.DcomProtocol">
            <summary>
            DCOM protocol
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ComputerWMIHelper.WsmanProtocol">
            <summary>
            WSMan protocol
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ComputerWMIHelper.CimUriPrefix">
            <summary>
            CimUriPrefix
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ComputerWMIHelper.CimOperatingSystemNamespace">
            <summary>
            CimOperatingSystemNamespace
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ComputerWMIHelper.CimOperatingSystemShutdownMethod">
            <summary>
            CimOperatingSystemShutdownMethod
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ComputerWMIHelper.CimQueryDialect">
            <summary>
            CimQueryDialect
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ComputerWMIHelper.localhostStr">
            <summary>
            Local host name
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ComputerWMIHelper.GetLocalAdminUserName(System.String,System.Management.Automation.PSCredential)">
            <summary>
            Get the local admin user name from a local NetworkCredential
            </summary>
            <param name="computerName"></param>
            <param name="psLocalCredential"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ComputerWMIHelper.GetRandomPassword(System.Int32)">
            <summary>
            Generate a random password
            </summary>
            <param name="passwordLength"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ComputerWMIHelper.GetConnectionOptions(System.Management.AuthenticationLevel,System.Management.ImpersonationLevel,System.Management.Automation.PSCredential)">
            <summary>
            Get the Connection Options
            </summary>
            <param name="Authentication"></param>
            <param name="Impersonation"></param>
            <param name="Credential"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ComputerWMIHelper.GetScopeString(System.String,System.String)">
            <summary>
            Gets the Scope
            
            </summary>
            <param name="computer"></param>
            <param name="namespaceParameter"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ComputerWMIHelper.IsValidDrive(System.String)">
            <summary>
            Returns true if it is a valid drive on the system.
            </summary>
            <param name="drive"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ComputerWMIHelper.ContainsSystemDrive(System.String[],System.String)">
            <summary>
            Chacks whether string[] contains System Drive.
            </summary>
            <param name="drives"></param>
            <param name="sysdrive"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ComputerWMIHelper.GetMachineNames(System.String[])">
            <summary>
            Returns the given computernames in a string
            </summary>
            <param name="computerNames"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ComputerWMIHelper.IsComputerNameValid(System.String)">
            <summary>
            Check whether the new computer name is valid
            </summary>
            <param name="computerName"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ComputerWMIHelper.SkipSystemRestoreOperationForARMPlatform(System.Management.Automation.PSCmdlet)">
            <summary>
            System Restore APIs are not supported on the ARM platform. Skip the system restore operation is necessary.
            </summary>
            <param name="cmdlet"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ComputerWMIHelper.InvokeWin32ShutdownUsingWsman(System.Management.Automation.PSCmdlet,System.Boolean,System.String,System.Object[],System.Management.Automation.PSCredential,System.String,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Invokes the Win32Shutdown command on provided target computer using WSMan
            over a CIMSession.  The flags parameter determines the type of shutdown operation
            such as shutdown, reboot, force etc.
            </summary>
            <param name="cmdlet">Cmdlet host for reporting errors</param>
            <param name="isLocalhost">True if local host computer</param>
            <param name="computerName">Target computer</param>
            <param name="flags">Win32Shutdown flags</param>
            <param name="credential">Optional credential</param>
            <param name="authentication">Optional authentication</param>
            <param name="formatErrorMessage">Error message format string that takes two parameters</param>
            <param name="ErrorFQEID">Fully qualified error Id</param>
            <param name="cancelToken">Cancel token</param>
            <returns>True on success</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ComputerWMIHelper.ValidateComputerName(System.String,System.String,System.String,System.Management.Automation.ErrorRecord@)">
            <summary>
            Returns valid computer name or null on failure.
            </summary>
            <param name="nameToCheck">Computer name to validate</param>
            <param name="shortLocalMachineName"></param>
            <param name="fullLocalMachineName"></param>
            <param name="error"></param>
            <returns>Valid computer name</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetComputerInfoCommand">
            <summary>
            The Get=ComputerInfo cmdlet gathers and reports information
            about a computer.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetComputerInfoCommand.namedProperties">
            <summary>
            Collection of property names from the Property parameter,
            including any names resulting from the expansion of wild-card
            patterns given. This list will itself contain no wildcard patterns.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetComputerInfoCommand.Property">
            <summary>
            The Property parameter contains the names of properties to be retrieved.
            If this parameter is given, the cmdlet returns a PSCustomObject
            containing only the requested properties.
            Wild-card patterns may be provided
            </summary>
            <remarks>
            <para>
            Any named properties that are not recognized are ignored. If no
            recognized properties are provided the cmdlet returns an empty
            PSCustomObject.
            </para>
            <para>
            If a provided wild-card pattern contains only an asterisk ("*"),
            the cmdlet will operate as if the parameter were not given at all
            and will return a fully-populated ComputerInfo object.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetComputerInfoCommand.BeginProcessing">
            <summary>
            Perform any first-stage processing
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetComputerInfoCommand.ProcessRecord">
            <summary>
            Performs the cmdlet's work
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetComputerInfoCommand.UpdateProgress(System.String)">
            <summary>
            Display progress
            </summary>
            <param name="status">
            Text to be displayed in status bar
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetComputerInfoCommand.GetHalVersion(Microsoft.Management.Infrastructure.CimSession,System.String)">
            <summary>
            Retrieves the version of the system's hal.dll.
            </summary>
            <param name="session">
            A <see cref="T:Microsoft.Management.Infrastructure.CimSession"/> object
            representing the CIM session to query.
            </param>
            <param name="systemDirectory">
            Path to the system directory, which should contain the hal.dll file.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetComputerInfoCommand.GetNetworkAdapters(Microsoft.Management.Infrastructure.CimSession)">
            <summary>
            Create an array of <see cref="T:Microsoft.PowerShell.Commands.NetworkAdapter"/> object from values in
            Win32_NetworkAdapter and Win32_NetworkAdapterConfiguration instances.
            </summary>
            <param name="session">
            A <see cref="T:Microsoft.Management.Infrastructure.CimSession"/> object representing
            a CIM session.
            </param>
            <returns>
            An array of NetworkAdapter objects.
            </returns>
            <remarks>
            This method matches network adapters associated network adapter configurations.
            The returned array contains entries only for matched adapter/configuration objects.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetComputerInfoCommand.GetProcessors(Microsoft.Management.Infrastructure.CimSession)">
            <summary>
            Create an array of <see cref="T:Microsoft.PowerShell.Commands.Processor"/> objects, using data acquired
            from WMI via the Win32_Processor class.
            </summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetComputerInfoCommand.GetDeviceGuard(Microsoft.Management.Infrastructure.CimSession)">
            <summary>
            Retrieve information related to Device Guard
            </summary>
            <param name="session">
            A <see cref="T:Microsoft.Management.Infrastructure.CimSession"/> object representing
            a CIM session.
            </param>
            <returns>
            A <see cref="T:Microsoft.PowerShell.Commands.DeviceGuard"/> object containing information related to
            the Device Guard feature
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetComputerInfoCommand.GetBooleanProperty(Microsoft.Management.Infrastructure.CimInstance,System.String)">
            <summary>
            A helper method used by GetHyperVisorInfo to retrieve a boolean
            property value.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetComputerInfoCommand.GetHyperVisorInfo(Microsoft.Management.Infrastructure.CimSession)">
            <summary>
            Retrieve information related to HyperVisor
            </summary>
            <param name="session">
            A <see cref="T:Microsoft.Management.Infrastructure.CimSession"/> object representing
            a CIM session.
            </param>
            <returns>
            A <see cref="T:Microsoft.PowerShell.Commands.GetComputerInfoCommand.HyperVInfo"/> object containing information related to
            HyperVisor
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetComputerInfoCommand.GetOtherInfo(Microsoft.Management.Infrastructure.CimSession)">
            <summary>
            Retrieve miscellaneous system information
            </summary>
            <param name="session">
            A <see cref="T:Microsoft.Management.Infrastructure.CimSession"/> object representing
            a CIM session.
            </param>
            <returns>
            A <see cref="T:Microsoft.PowerShell.Commands.GetComputerInfoCommand.MiscInfoGroup"/> object containing miscellaneous
            system information
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetComputerInfoCommand.CreateFullOutputObject(Microsoft.PowerShell.Commands.GetComputerInfoCommand.SystemInfoGroup,Microsoft.PowerShell.Commands.GetComputerInfoCommand.OSInfoGroup,Microsoft.PowerShell.Commands.GetComputerInfoCommand.MiscInfoGroup)">
            <summary>
            Create a new ComputerInfo object populated with the specified data objects.
            </summary>
            <param name="systemInfo">
            A <see cref="T:Microsoft.PowerShell.Commands.GetComputerInfoCommand.SystemInfoGroup"/> object containing system-related info
            such as BIOS, mother-board, computer system, etc.
            </param>
            <param name="osInfo">
            An <see cref="T:Microsoft.PowerShell.Commands.GetComputerInfoCommand.OSInfoGroup"/> object containing operating-system information.
            </param>
            <param name="otherInfo">
            A <see cref="T:Microsoft.PowerShell.Commands.GetComputerInfoCommand.MiscInfoGroup"/> object containing other information to be reported.
            </param>
            <returns>
            A new ComputerInfo object to be output to PowerShell.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetComputerInfoCommand.CreateCustomOutputObject(Microsoft.PowerShell.Commands.ComputerInfo,System.Collections.Generic.List{System.String})">
            <summary>
            Create a new PSObject, containing only those properties named in the
            namedProperties parameter
            </summary>
            <param name="info">
            A <see cref="T:Microsoft.PowerShell.Commands.ComputerInfo"/> containing all the acquired system information
            </param>
            <param name="namedProperties">
            A list of property names to be included in the returned object
            </param>
            <returns>
            A new PSObject with the properties specified in the <paramref name="namedProperties"/>
            parameter
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetComputerInfoCommand.GetComputerInfoPropertyNames">
            <summary>
            Get the names of all <see cref="T:Microsoft.PowerShell.Commands.ComputerInfo"/> properties. This is
            part of the processes of validating property names provided by the user.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetComputerInfoCommand.ExpandWildcardPropertyNames(System.Collections.Generic.List{System.String},System.String)">
            <summary>
            Expand any wild-card patterns into known property names
            </summary>
            <param name="propertyNames">
            List of known property names
            </param>
            <param name="pattern">
            The wild-card pattern used to perform globbing
            </param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetComputerInfoCommand.CollectPropertyNames(System.String[])">
            <summary>
            Produce a list of known, valid property names from property-name
            parameters. These parameter may use wild-card patterns and may
            contain invalid property names. This method expands wild-card
            patterns and filter out any invalid property names.
            </summary>
            <param name="requestedProperties"></param>
            <returns>
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.Conversion.TryParseHex(System.String,System.UInt32@)">
            <summary>
            Attempt to convert a string representation of a base-16 value
            into an integer.
            </summary>
            <param name="hexString">
            A string containing the text to be parsed.
            </param>
            <param name="value">
            An integer into which the parsed value is stored. If the string
            cannot be converted, this parameter is set to 0.
            </param>
            <returns>
            Returns true if the conversion was successful, false otherwise.
            </returns>
            <remarks>
            The hexString parameter must contain a hexadecimal value, with no
            base-indication prefix. For example, the string "0409" will be
            parsed into the base-10 integer value 1033, while the string "0x0409"
            will fail to parse due to the "0x" base-indication prefix.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.Conversion.MakeLocale(System.String)">
            <summary>
            Attempt to create a <see cref="T:System.Globalization.CultureInfo"/>
            object from a locale string as retrieved from WMI.
            </summary>
            <param name="locale">
            A string containing WMI's notion (usually) of a locale.
            </param>
            <returns>
            A CultureInfo object if successful, null otherwise.
            </returns>
            <remarks>
            This method first tries to convert the string to a hex value
            and get the CultureInfo object from that value.
            Failing that it attempts to retrieve the CultureInfo object
            using the locale string as passed.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.Conversion.UnixSecondsToDateTime(System.Int64)">
            <summary>
            Convert a Unix time, expressed in seconds, to a <see cref="T:System.DateTime"/>.
            </summary>
            <param name="seconds">Number of seconds since the Unix epoch.</param>
            <returns>
            A DateTime object representing the date and time represented by the
            <paramref name="seconds"/> parameter.
            </returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.EnumConverter`1">
            <summary>
            The EnumConverter<typeparamref name="T"/> class contains a method
            for converting an integer to a nullable enum of the type specified
            in T.
            </summary>
            <typeparam name="T">
            The type of enum to be the destination of the conversion.
            </typeparam>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.EnumConverter`1.Convert(System.Nullable{System.Int32})">
            <summary>
            Convert an integer to a Nullable enum of type T
            </summary>
            <param name="value">
            The integer value to be converted to the specified enum type.
            </param>
            <returns>
            A Nullable<typeparamref name="T"/> enum object. If the value
            is convertable to a valid enum value, the returned object's
            value will contain the converted value, otherwise the returned
            object will be null.
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.EnumConverter`1.MakeConverter">
            <summary>
            Create a converter using Linq Expression classes.
            </summary>
            <returns>
            A generic Func{} object to convert an int to the specified enum type.
            </returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WmiClassBase">
            <summary>
            Base class for some of the other Intermediate WMI classes,
            providing some shared methods.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WmiClassBase.GetLanguageName(System.Nullable{System.UInt32})">
            <summary>
            Get a language name from a language identifier.
            </summary>
            <param name="language">
            A nullable integer containing the language ID for the desired language.
            </param>
            <returns>
            A string containing the display name of the language identified by
            the language parameter. If the language parameter is null or has a
            value that is not a valid language ID, the method returns null.
            </returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.DeviceGuard">
            <summary>
            Provides information about Device Guard
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.DeviceGuard.RequiredSecurityProperties">
            <summary>
            Array of required security properties
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.DeviceGuard.AvailableSecurityProperties">
            <summary>
            Array of available security properties
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.DeviceGuard.SecurityServicesConfigured">
            <summary>
            Indicates which security services have been configured
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.DeviceGuard.SecurityServicesRunning">
            <summary>
            Indicates which security services are running
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.DeviceGuard.CodeIntegrityPolicyEnforcementStatus">
            <summary>
            Indicates the status of the Device Guard Code Integrity policy
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.DeviceGuard.UserModeCodeIntegrityPolicyEnforcementStatus">
            <summary>
            Indicates the status of the Device Guard user mode Code Integrity policy
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.HotFix">
            <summary>
            Describes a Quick-Fix Engineering update
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.HotFix.HotFixID">
            <summary>
            Unique identifier associated with a particular update.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.HotFix.Description">
            <summary>
            Description of the update
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.HotFix.InstalledOn">
            <summary>
            String containing the date that the update was installed
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.HotFix.FixComments">
            <summary>
            Additional comments that relate to the update
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.NetworkAdapter">
            <summary>
            Provides information about a network adapter
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NetworkAdapter.Description">
            <summary>
            Description of the network adapter
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NetworkAdapter.ConnectionID">
            <summary>
            Name of the network connection as it appears in the Network
            Connections Control Panel program
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NetworkAdapter.DHCPEnabled">
            <summary>
            Indicates whether the DHCP server automatically assigns an IP address
            to the computer system when establishing a network connection
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NetworkAdapter.DHCPServer">
            <summary>
            IP Address of the DHCP server
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NetworkAdapter.ConnectionStatus">
            <summary>
            State of the network adapter connection to the network
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NetworkAdapter.IPAddresses">
            <summary>
            Array of all of the IP addresses associated with the current network adapter.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.Processor">
            <summary>
            Describes a processor on the computer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Processor.Name">
            <summary>
            Name of the processor
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Processor.Manufacturer">
            <summary>
            Name of the processor manufacturer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Processor.Description">
            <summary>
            Description of the processor
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Processor.Architecture">
            <summary>
            Processor architecture used by the platform
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Processor.AddressWidth">
            <summary>
            Address width of the processor
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Processor.DataWidth">
            <summary>
            Data width of the processor
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Processor.MaxClockSpeed">
            <summary>
            Maximum speed of the processor, in MHz
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Processor.CurrentClockSpeed">
            <summary>
            Current speed of the processor, in MHz
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Processor.NumberOfCores">
            <summary>
            Number of cores for the current instance of the processor.
            </summary>
            <remarks>
            A core is a physical processor on the integrated circuit
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Processor.NumberOfLogicalProcessors">
            <summary>
            Number of logical processors for the current instance of the processor.
            </summary>
            <remarks>
            For processors capable of hyperthreading, this value includes only the
            processors which have hyperthreading enabled
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Processor.ProcessorID">
            <summary>
            Processor information that describes the processor features.
            </summary>
            <remarks>
            For an x86 class CPU, the field format depends on the processor support
            of the CPUID instruction. If the instruction is supported, the property
            contains 2 (two) DWORD formatted values. The first is an offset of 08h-0Bh,
            which is the EAX value that a CPUID instruction returns with input EAX set
            to 1. The second is an offset of 0Ch-0Fh, which is the EDX value that the
            instruction returns. Only the first two bytes of the property are significant
            and contain the contents of the DX register at CPU resetall others are set
            to 0 (zero), and the contents are in DWORD format
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Processor.SocketDesignation">
            <summary>
            Type of chip socket used on the circuit
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Processor.ProcessorType">
            <summary>
            Primary function of the processor
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Processor.Role">
            <summary>
            Role of the processor
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Processor.Status">
            <summary>
            Current status of the processor
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Processor.CpuStatus">
            <summary>
            Current status of the processor.
            Status changes indicate processor usage, but not the physical
            condition of the processor
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.Processor.Availability">
            <summary>
            Availability and status of the processor
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ComputerInfo">
            <summary>
             The ComputerInfo class is output to the PowerShell pipeline.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.WindowsBuildLabEx">
            <summary>
            Windows build lab information, from the Windows Registry.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.WindowsCurrentVersion">
            <summary>
            Windows version number, from the Windows Registry.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.WindowsEditionId">
            <summary>
            Windows edition, from the Windows Registry.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.WindowsInstallationType">
            <summary>
            Windows installation type, from the Windows Registry.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.WindowsInstallDateFromRegistry">
            <summary>
            The data Windows was installed, from the Windows Registry.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.WindowsProductId">
            <summary>
            The Windows product ID, from the Windows Registry.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.WindowsProductName">
            <summary>
            The Windows product name, from the Windows Registry.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.WindowsRegisteredOrganization">
            <summary>
            Name of the organization that this installation of Windows is registered to, from the Windows Registry.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.WindowsRegisteredOwner">
            <summary>
            Name of the registered owner of this installation of Windows, from the Windows Registry.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.WindowsSystemRoot">
            <summary>
            Path to the operating system's root directory, from the Windows Registry.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.WindowsVersion">
            <summary>
            The Windows ReleaseId, from the Windows Registry.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosCharacteristics">
            <summary>
            Array of BIOS characteristics supported by the system as defined by
            the System Management BIOS Reference Specification
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosBIOSVersion">
            <summary>
            Array of the complete system BIOS information. In many computers
            there can be several version strings that are stored in the registry
            and represent the system BIOS information
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosBuildNumber">
            <summary>
            Internal identifier for this compilation of the BIOS firmware
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosCaption">
            <summary>
            Short description of the BIOS.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosCodeSet">
            <summary>
            Code set used by the BIOS
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosCurrentLanguage">
            <summary>
            Name of the current BIOS language
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosDescription">
            <summary>
            Description of the BIOS
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosEmbeddedControllerMajorVersion">
            <summary>
            Major version of the embedded controller firmware
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosEmbeddedControllerMinorVersion">
            <summary>
            Minor version of the embedded controller firmware
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosFirmwareType">
            <summary>
            Firmware type of the local computer.
            </summary>
            <remarks>
            This is acquired via the GetFirmwareType Windows API function
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosIdentificationCode">
            <summary>
            Manufacturer's identifier for this software element.
            Often this will be a stock keeping unit (SKU) or a part number
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosInstallableLanguages">
            <summary>
            Number of languages available for installation on this system.
            Language may determine properties such as the need for Unicode and bidirectional text
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosInstallDate">
            <summary>
            Date and time the object was installed.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosLanguageEdition">
            <summary>
            Language edition of the BIOS firmware.
            The language codes defined in ISO 639 should be used.
            Where the software element represents a multilingual or international
            version of a product, the string "multilingual" should be used
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosListOfLanguages">
            <summary>
            Array of names of available BIOS-installable languages
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosManufacturer">
            <summary>
            Manufacturer of the BIOS
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosName">
            <summary>
            Name used to identify the BIOS
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosOtherTargetOS">
            <summary>
            Records the manufacturer and operating system type for the BIOS when
            the BiosTargetOperatingSystem property has a value of 1 (Other).
            When TargetOperatingSystem has a value of 1, BiosOtherTargetOS must
            have a nonnull value. For all other values of BiosTargetOperatingSystem,
            BiosOtherTargetOS is NULL
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosPrimaryBIOS">
            <summary>
            If true, this is the primary BIOS of the computer system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosReleaseDate">
            <summary>
            Release date of the Windows BIOS
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosSeralNumber">
            <summary>
            Assigned serial number of the BIOS
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosSMBIOSBIOSVersion">
            <summary>
            BIOS version as reported by SMBIOS
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosSMBIOSMajorVersion">
            <summary>
            SMBIOS major version number. This property is null if SMBIOS is not found
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosSMBIOSMinorVersion">
            <summary>
            SMBIOS minor version number. This property is null if SMBIOS is not found
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosSMBIOSPresent">
            <summary>
            If true, the SMBIOS is available on this computer system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosSoftwareElementState">
            <summary>
            State of a BIOS software element
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosStatus">
            <summary>
            Status of the BIOS
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosSystemBiosMajorVersion">
            <summary>
            Major elease of the System BIOS
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosSystemBiosMinorVersion">
            <summary>
            Minor release of the System BIOS
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosTargetOperatingSystem">
            <summary>
            Target operating system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.BiosVersion">
            <summary>
            Version of the BIOS.
            This string is created by the BIOS manufacturer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsAdminPasswordStatus">
            <summary>
            System hardware security settings for administrator password status
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsAutomaticManagedPagefile">
            <summary>
            If true, the system manages the page file
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsAutomaticResetBootOption">
            <summary>
            If True, the automatic reset boot option is enabled
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsAutomaticResetCapability">
            <summary>
            If True, the automatic reset is enabled
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsBootOptionOnLimit">
            <summary>
            Boot option limit is ON. Identifies the system action when the
            CsResetLimit value is reached
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsBootOptionOnWatchDog">
            <summary>
            Type of reboot action after the time on the watchdog timer is elapsed
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsBootROMSupported">
            <summary>
            If true, indicates whether a boot ROM is supported
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsBootStatus">
            <summary>
            Status and Additional Data fields that identify the boot status
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsBootupState">
            <summary>
            System is started. Fail-safe boot bypasses the user startup filesalso called SafeBoot
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsCaption">
            <summary>
            The name of this computer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsChassisBootupState">
            <summary>
            Boot up state of the chassis
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsChassisSKUNumber">
            <summary>
            The chassis or enclosure SKU number as a string
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsCurrentTimeZone">
            <summary>
            Amount of time the unitary computer system is offset from Coordinated
            Universal Time (UTC).
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsDaylightInEffect">
            <summary>
            If True, the daylight savings mode is ON
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsDescription">
            <summary>
            Description of the computer system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsDNSHostName">
            <summary>
            Name of local computer according to the domain name server
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsDomain">
            <summary>
            Name of the domain to which a computer belongs.
            </summary>
            <remarks>
            If the computer is not part of a domain, then the name of the workgroup is returned
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsDomainRole">
            <summary>
            Role of a computer in an assigned domain workgroup. A domain workgroup
            is a collection of computers on the same network. For example,
            a DomainRole property may show that a computer is a member workstation
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsEnableDaylightSavingsTime">
            <summary>
            Enables daylight savings time on a computer. A value of True indicates
            that the system time changes to an hour ahead or behind when DST starts
            or ends. A value of False indicates that the system time does not change
            to an hour ahead or behind when DST starts or ends. A value of NULL
            indicates that the DST status is unknown on a system.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsFrontPanelResetStatus">
            <summary>
            Hardware security setting for the reset button on a computer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsHypervisorPresent">
            <summary>
            If True, a hypervisor is present
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsInfraredSupported">
            <summary>
            If True, an infrared port exists on a computer system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsInitialLoadInfo">
            <summary>
            Data required to find the initial load device or boot service to request that the operating system start up
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsInstallDate">
            <summary>
            Object is installed. An object does not need a value to indicate that it is installed
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsKeyboardPasswordStatus">
            <summary>
            System hardware security setting for Keyboard Password Status
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsLastLoadInfo">
            <summary>
            Array entry of the CsInitialLoadInfo property that contains the data
            to start the loaded operating system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsManufacturer">
            <summary>
            Name of the computer manufacturer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsModel">
            <summary>
            Product name that a manufacturer gives to a computer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsName">
            <summary>
            Key of a CIM_System instance in an enterprise environment
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsNetworkAdapters">
            <summary>
            An array of <see cref="T:Microsoft.PowerShell.Commands.NetworkAdapter"/> objects describing any
            network adapters on the system.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsNetworkServerModeEnabled">
            <summary>
            If True, the network Server Mode is enabled
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsNumberOfLogicalProcessors">
            <summary>
            Number of logical processors available on the computer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsNumberOfProcessors">
            <summary>
            Number of physical processors currently available on a system.
            </summary>
            <remarks>
            This is the number of enabled processors for a system, which
            does not include the disabled processors. If a computer system
            has two physical processors each containing two logical processors,
            then the value of CsNumberOfProcessors is 2 and CsNumberOfLogicalProcessors
            is 4. The processors may be multicore or they may be hyperthreading processors
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsProcessors">
            <summary>
            Array of <see cref="T:Microsoft.PowerShell.Commands.Processor"/> objects describing each processor on the system.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsOEMStringArray">
            <summary>
            Array of free-form strings that an OEM defines.
            For example, an OEM defines the part numbers for system reference
            documents, manufacturer contact information, and so on
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsPartOfDomain">
            <summary>
            If True, the computer is part of a domain.
            If the value is NULL, the computer is not in a domain or the status is unknown
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsPauseAfterReset">
            <summary>
            Time delay before a reboot is initiated, in milliseconds.
            It is used after a system power cycle, local or remote system reset,
            and automatic system reset. A value of 1 (minus one) indicates that
            the pause value is unknown
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsPCSystemType">
            <summary>
            Type of the computer in use, such as laptop, desktop, or tablet
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsPCSystemTypeEx">
            <summary>
            Type of the computer in use, such as laptop, desktop, or tablet.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsPowerManagementCapabilities">
            <summary>
            Array of the specific power-related capabilities of a logical device
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsPowerManagementSupported">
            <summary>
            If True, device can be power-managed, for example, a device can be
            put into suspend mode, and so on.
            </summary>
            <remarks>
            This property does not indicate that power management features are
            enabled currently, but it does indicate that the logical device is
            capable of power management
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsPowerOnPasswordStatus">
            <summary>
            System hardware security setting for Power-On Password Status
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsPowerState">
            <summary>
            Current power state of a computer and its associated operating system.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsPowerSupplyState">
            <summary>
            State of the power supply or supplies when last booted
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsPrimaryOwnerContact">
            <summary>
            Contact information for the primary system owner.
            For example, phone number, email address, and so on
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsPrimaryOwnerName">
            <summary>
            Name of the primary system owner
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsResetCapability">
            <summary>
            Indicates if the computer system can be resut.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsResetCount">
            <summary>
            Number of automatic resets since the last reset.
            A value of 1 (minus one) indicates that the count is unknown
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsResetLimit">
            <summary>
            Number of consecutive times a system reset is attempted.
            A value of 1 (minus one) indicates that the limit is unknown
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsRoles">
            <summary>
            Array that specifies the roles of a system in the information
            technology environment
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsStatus">
            <summary>
            Statis pf the computer system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsSupportContactDescription">
            <summary>
            Array of the support contact information for the Windows operating system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsSystemFamily">
            <summary>
            The family to which a particular computer belongs.
            A family refers to a set of computers that are similar but not
            identical from a hardware or software point of view
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsSystemSKUNumber">
            <summary>
            Identifies a particular computer configuration for sale.
            It is sometimes also called a product ID or purchase order number
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsSystemType">
            <summary>
            System running on the Windows-based computer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsThermalState">
            <summary>
            Thermal state of the system when last booted
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsTotalPhysicalMemory">
            <summary>
            Total size of physical memory.
            </summary>
            <remarks>
            Be aware that, under some circumstances, this property may not
            return an accurate value for the physical memory. For example,
            it is not accurate if the BIOS is using some of the physical memory
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsPhyicallyInstalledMemory">
            <summary>
            Size of physically installed memory, as reported by the Windows API
            function GetPhysicallyInstalledSystemMemory
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsUserName">
            <summary>
            Name of a user that is logged on currently.
            </summary>
            <remarks>
            In a terminal services session, CsUserName is the name of the user
            that is logged on to the consolenot the user logged on during the
            terminal service session
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsWakeUpType">
            <summary>
            Event that causes the system to power up
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.CsWorkgroup">
            <summary>
            Name of the workgroup for this computer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsName">
            <summary>
            Name of the operating system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsType">
            <summary>
            Type of operating system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsOperatingSystemSKU">
            <summary>
            SKU number for the operating system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsVersion">
            <summary>
            Version number of the operating system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsCSDVersion">
            <summary>
            String that indicates the latest service pack installed on a computer.
            If no service pack is installed, the string is NULL
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsBuildNumber">
            <summary>
            Build number of the operating system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsHotFixes">
            <summary>
            Array of <see cref="T:Microsoft.PowerShell.Commands.HotFix"/> objects containing information about
            any Quick-Fix Enginnering patches (Hot Fixes) applied to the operating
            system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsBootDevice">
            <summary>
            Name of the disk drive from which the Windows operating system starts
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsSystemDevice">
            <summary>
            Physical disk partition on which the operating system is installed
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsSystemDirectory">
            <summary>
            System directory of the operating system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsSystemDrive">
            <summary>
            Letter of the disk drive on which the operating system resides
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsWindowsDirectory">
            <summary>
            Windows directory of the operating system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsCountryCode">
            <summary>
            Code for the country/region that an operating system uses
            </summary>
            <remarks>
            Values are based on international phone dialing prefixesalso
            referred to as IBM country/region codes
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsCurrentTimeZone">
            <summary>
            Number, in minutes, an operating system is offset from Greenwich
            mean time (GMT). The number is positive, negative, or zero
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsLocaleID">
            <summary>
            Language identifier used by the operating system.
            </summary>
            <remarks>
            A language identifier is a standard international numeric abbreviation
            for a country/region. Each language has a unique language identifier (LANGID),
            a 16-bit value that consists of a primary language identifier and a secondary
            language identifier
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsLocale">
            <summary>
            The culture name, such as "en-US", derived from the <see cref="P:Microsoft.PowerShell.Commands.ComputerInfo.OsLocaleID"/> property
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsLocalDateTime">
            <summary>
            Operating system version of the local date and time-of-day
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsLastBootUpTime">
            <summary>
            Date and time the operating system was last restarted
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsUptime">
            <summary>
            The interval between the time the operating system was last
            restarted and the current time
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsBuildType">
            <summary>
            Type of build used for the operating system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsCodeSet">
            <summary>
            Code page value the operating system uses
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsDataExecutionPreventionAvailable">
            <summary>
            If true, then the data execution prevention hardware feature is available
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsDataExecutionPrevention32BitApplications">
            <summary>
            When the data execution prevention hardware feature is available,
            this property indicates that the feature is set to work for 32-bit
            applications if true
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsDataExecutionPreventionDrivers">
            <summary>
            When the data execution prevention hardware feature is available,
            this property indicates that the feature is set to work for drivers
            if true
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsDataExecutionPreventionSupportPolicy">
            <summary>
            Indicates which Data Execution Prevention (DEP) setting is applied.
            The DEP setting specifies the extent to which DEP applies to 32-bit
            applications on the system. DEP is always applied to the Windows kernel
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsDebug">
            <summary>
            If true, the operating system is a checked (debug) build
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsDistributed">
            <summary>
            If True, the operating system is distributed across several computer
            system nodes. If so, these nodes should be grouped as a cluster
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsEncryptionLevel">
            <summary>
            Encryption level for secure transactions: 40-bit, 128-bit, or n-bit.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsForegroundApplicationBoost">
            <summary>
            Increased priority given to the foreground application
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsTotalVisibleMemorySize">
            <summary>
            Total amount, in kilobytes, of physical memory available to the
            operating system.
            </summary>
            <remarks>
            This value does not necessarily indicate the true amount of 
            physical memory, but what is reported to the operating system
            as available to it.
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsFreePhysicalMemory">
            <summary>
            Number, in kilobytes, of physical memory currently unused and available
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsTotalVirtualMemorySize">
            <summary>
            Number, in kilobytes, of virtual memory
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsFreeVirtualMemory">
            <summary>
            Number, in kilobytes, of virtual memory currently unused and available
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsInUseVirtualMemory">
            <summary>
            Number, in kilobytes, of virtual memory currently in use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsTotalSwapSpaceSize">
            <summary>
            Total swap space in kilobytes
            </summary>
            <remarks>
            This value may be NULL (unspecified) if the swap space is not
            distinguished from page files. However, some operating systems
            distinguish these concepts. For example, in UNIX, whole processes
            can be swapped out when the free page list falls and remains below
            a specified amount
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsSizeStoredInPagingFiles">
            <summary>
            Total number of kilobytes that can be stored in the operating system
            paging files0 (zero) indicates that there are no paging files.
            Be aware that this number does not represent the actual physical
            size of the paging file on disk
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsFreeSpaceInPagingFiles">
            <summary>
            Number, in kilobytes, that can be mapped into the operating system
            paging files without causing any other pages to be swapped out
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsPagingFiles">
            <summary>
            Array of fiel paths to the operating system's paging files
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsHardwareAbstractionLayer">
            <summary>
            Version of the operating system's Hardware Abstraction Layer (HAL)
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsInstallDate">
            <summary>
            Indicates the install date
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsManufacturer">
            <summary>
            Name of the operating system manufacturer.
            For Windows-based systems, this value is "Microsoft Corporation"
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsMaxNumberOfProcesses">
            <summary>
            Maximum number of process contexts the operating system can support
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsMaxProcessMemorySize">
            <summary>
            Maximum number, in kilobytes, of memory that can be allocated to a process
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsMuiLanguages">
            <summary>
            Array of Multilingual User Interface Pack (MUI Pack) languages installed
            on the computer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsNumberOfLicensedUsers">
            <summary>
            Number of user licenses for the operating system.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsNumberOfProcesses">
            <summary>
            Number of process contexts currently loaded or running on the operating system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsNumberOfUsers">
            <summary>
            Number of user sessions for which the operating system is storing
            state information currently
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsOrganization">
            <summary>
            Company name for the registered user of the operating system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsArchitecture">
            <summary>
            Architecture of the operating system, as opposed to the processor
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsLanguage">
            <summary>
            Language version of the operating system installed
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsProductSuites">
            <summary>
            Array of <see cref="T:Microsoft.PowerShell.Commands.OSProductSuite"/> objects indicating installed
            and licensed product additions to the operating system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsOtherTypeDescription">
            <summary>
            Additional description for the current operating system version
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsPAEEnabled">
            <summary>
            If True, the physical address extensions (PAE) are enabled by the
            operating system running on Intel processors
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsPortableOperatingSystem">
            <summary>
            Specifies whether the operating system booted from an external USB device.
            If true, the operating system has detected it is booting on a supported
            locally connected storage device
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsPrimary">
            <summary>
            Specifies whether this is the primary operating system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsProductType">
            <summary>
            Additional system information
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsRegisteredUser">
            <summary>
            Name of the registered user of the operating system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsSerialNumber">
            <summary>
            Operating system product serial identification number
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsServicePackMajorVersion">
            <summary>
            Major version of the service pack installed on the computer system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsServicePackMinorVersion">
            <summary>
            Minor version of the service pack installed on the computer system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsStatus">
            <summary>
            Current status
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsSuites">
            <summary>
            Product suites available on the operating system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.OsServerLevel">
            <summary>
            Server level of the operating system, if the operating system is a server
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.KeyboardLayout">
            <summary>
            Layout of the (first) keyboard attached to the system
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.TimeZone">
            <summary>
            Name of the system's current time zone
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.LogonServer">
            <summary>
            Path to the system's logon server
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.PowerPlatformRole">
            <summary>
            Power platform role
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.HyperVisorPresent">
            <summary>
            If true, a HyperVisor was detected
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.HyperVRequirementDataExecutionPreventionAvailable">
            <summary>
            If a HyperVisor is not present, indicates the state of the
            requirement that the Data Execution Prevention feature is available
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.HyperVRequirementSecondLevelAddressTranslation">
            <summary>
            If a HyperVisor is not present, indicates the state of the
            requirement that the processor supports address translation
            extensions used for virtualization
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.HyperVRequirementVirtualizationFirmwareEnabled">
            <summary>
            If a HyperVisor is not present, indicates the state of the
            requirement that the firmware has enabled virtualization
            extensions
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.HyperVRequirementVMMonitorModeExtensions">
            <summary>
            If a HyperVisor is not present, indicates the state of the
            requirement that the processor supports  Intel or AMD Virtual
            Machine Monitor extensions
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.DeviceGuardSmartStatus">
            <summary>
            Indicates the status of the Device Guard features
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.DeviceGuardRequiredSecurityProperties">
            <summary>
            Required Device Guard security properties
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.DeviceGuardAvailableSecurityProperties">
            <summary>
            Available Device Guard security properties
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.DeviceGuardSecurityServicesConfigured">
            <summary>
            Configured Device Guard security services
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.DeviceGuardSecurityServicesRunning">
            <summary>
            Running Device Guard security services
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.DeviceGuardCodeIntegrityPolicyEnforcementStatus">
            <summary>
            Status of the Device Guard Code Integrity policy enforcement
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ComputerInfo.DeviceGuardUserModeCodeIntegrityPolicyEnforcementStatus">
            <summary>
            Status of the Device Guard user mode Code Integrity policy enforcement
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.AdminPasswordStatus">
            <summary>
            System hardware security settings for administrator password status
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.AdminPasswordStatus.Disabled">
            <summary>
            Feature is disabled
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.AdminPasswordStatus.Enabled">
            <summary>
            Feature is Enabled
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.AdminPasswordStatus.NotImplemented">
            <summary>
            Feature is not implemented
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.AdminPasswordStatus.Unknown">
            <summary>
            Status is unknown
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.BootOptionAction">
            <summary>
            Actions related to the BootOptionOn* properties of the Win32_ComputerSystem
            CIM class
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.BootOptionAction.OperatingSystem">
            <summary>
            Boot into operating system
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.BootOptionAction.SystemUtilities">
            <summary>
            Boot into system utilities
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.BootOptionAction.DoNotReboot">
            <summary>
            Do not reboot
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SystemElementState">
            <summary>
            Indicates the state of a system element
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SystemElementState.Other">
            <summary>
            The element state is something other than those in this Enum
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SystemElementState.Unknown">
            <summary>
            The element state is unknown
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SystemElementState.Safe">
            <summary>
            The element is in Safe state
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SystemElementState.Warning">
            <summary>
            The element is in Warning state
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SystemElementState.Critical">
            <summary>
            The element is in Critical state
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SystemElementState.NonRecoverable">
            <summary>
            The element is in Non-Recoverable state
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.CpuArchitecture">
            <summary>
            Specifies the processor architecture
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuArchitecture.x86">
            <summary>
            Architecture is Intel x86
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuArchitecture.MIPs">
            <summary>
            Architecture is MIPS
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuArchitecture.Alpha">
            <summary>
            Architecture is DEC Alpha
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuArchitecture.PowerPC">
            <summary>
            Architecture is Motorolla PowerPC
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuArchitecture.ARM">
            <summary>
            Architecture is ARM
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuArchitecture.ia64">
            <summary>
            Architecture is Itanium-based 64-bit
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuArchitecture.x64">
            <summary>
            Architecture is Intel 64-bit
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.CpuAvailability">
            <summary>
            Specifies a CPU's availability and status
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.Other">
            <summary>
            A state other than those specified in CpuAvailability
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.Unknown">
            <summary>
            Availability status is unknown
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.RunningOrFullPower">
            <summary>
            The device is running or at full power
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.Warning">
            <summary>
            Device is in a Warning state
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.InTest">
            <summary>
            Availability status is In Test
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.NotApplicable">
            <summary>
            Status is not applicable to this device
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.PowerOff">
            <summary>
            The device is powered off
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.OffLine">
            <summary>
            Availability status is Offline
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.OffDuty">
            <summary>
            Availability status is Off-Duty
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.Degraded">
            <summary>
            Availability status is Degraded
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.NotIntalled">
            <summary>
            Availability status is Not Installed
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.InstallError">
            <summary>
            Availability status is Install Error
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.PowerSaveUnknown">
            <summary>
            The device is known to be in a power save state, but its exact status is unknown
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.PowerSaveLowPowerMode">
            <summary>
            The device is in a power save state, but is still functioning,
            and may exhibit decreased performance
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.PowerSaveStandby">
            <summary>
            The device is not functioning, but can be brought to full power quickly
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.PowerCycle">
            <summary>
            The device is in a power-cycle state
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.PowerSaveWarning">
            <summary>
            The device is in a warning state, though also in a power save state
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.Paused">
            <summary>
            The device is paused
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.NotReady">
            <summary>
            The device is not ready
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.NotConfigured">
            <summary>
            The device is not configured
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuAvailability.Quiesced">
            <summary>
            The device is quiet
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.CpuStatus">
            <summary>
            Specifies that current status of the processor
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuStatus.Unknown">
            <summary>
            CPU status is Unknown
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuStatus.Enabled">
            <summary>
            CPU status is Enabled
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuStatus.DisabledByUser">
            <summary>
            CPU status is Disabled by User via BIOS Setup
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuStatus.DisabledByBIOS">
            <summary>
            CPU status is Disabled by BIOS
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuStatus.Idle">
            <summary>
            CPU is Idle
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.CpuStatus.Other">
            <summary>
            CPU is in another state
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.DataExecutionPreventionSupportPolicy">
            <summary>
            Data Execution Prevention (DEP) settings
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DataExecutionPreventionSupportPolicy.AlwaysOff">
            <summary>
            DEP is turned off for all 32-bit applications on the computer with no exceptions
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DataExecutionPreventionSupportPolicy.AlwaysOn">
            <summary>
            DEP is enabled for all 32-bit applications on the computer
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DataExecutionPreventionSupportPolicy.OptIn">
            <summary>
            DEP is enabled for a limited number of binaries, the kernel, and all
            Windows-based services. However, it is off by default for all 32-bit
            applications. A user or administrator must explicitly choose either
            the Always On or the Opt Out setting before DEP can be applied to
            32-bit applications
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DataExecutionPreventionSupportPolicy.OptOut">
            <summary>
            DEP is enabled by default for all 32-bit applications. A user or
            administrator can explicitly remove support for a 32-bit
            application by adding the application to an exceptions list
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.DeviceGuardSmartStatus">
            <summary>
            Status of the Device Guard feature
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DeviceGuardSmartStatus.Off">
            <summary>
            Device Guard is off
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DeviceGuardSmartStatus.Configured">
            <summary>
            Device Guard is Configured
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DeviceGuardSmartStatus.Running">
            <summary>
            Device Guard is Running
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.DeviceGuardConfigCodeIntegrityStatus">
            <summary>
            Configuration status of the Device Guard Code Integrity
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DeviceGuardConfigCodeIntegrityStatus.Off">
            <summary>
            Code Integrity is off
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DeviceGuardConfigCodeIntegrityStatus.AuditMode">
            <summary>
            Code Integrity uses Audit mode
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DeviceGuardConfigCodeIntegrityStatus.EnforcementMode">
            <summary>
            Code Integrity uses Enforcement mode
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.DeviceGuardHardwareSecure">
            <summary>
            Device Guard hardware security properties
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DeviceGuardHardwareSecure.BaseVirtualizationSupport">
            <summary>
            Base Virtualization Support
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DeviceGuardHardwareSecure.SecureBoot">
            <summary>
            Secure Boot
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DeviceGuardHardwareSecure.DMAProtection">
            <summary>
            DMA Protection
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DeviceGuardHardwareSecure.SecureMemoryOverwrite">
            <summary>
            Secure Memory Overwrite
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.DeviceGuardSoftwareSecure">
            <summary>
            Device Guard software security properties
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DeviceGuardSoftwareSecure.CredentialGuard">
            <summary>
            Credential Guard
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DeviceGuardSoftwareSecure.HypervisorEnforcedCodeIntegrity">
            <summary>
            Hypervisor enforced Code Integrity
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.DomainRole">
            <summary>
            Role of a computer in an assigned domain workgroup
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DomainRole.StandaloneWorkstation">
            <summary>
            Standalone Workstation
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DomainRole.MemberWorkstation">
            <summary>
            Member Workstation
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DomainRole.StandaloneServer">
            <summary>
            Standalone Server
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DomainRole.MemberServer">
            <summary>
            Member Server
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DomainRole.BackupDomainController">
            <summary>
            Backup Domain Controller
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.DomainRole.PrimaryDomainController">
            <summary>
            Primary Domain Controller 
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.FirmwareType">
            <summary>
            Specifies a firmware type
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.FirmwareType.Unknown">
            <summary>
            The firmware type is unknown
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.FirmwareType.Bios">
            <summary>
            The computer booted in legacy BIOS mode
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.FirmwareType.Uefi">
            <summary>
            The computer booted in UEFI mode
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.FirmwareType.Max">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ForegroundApplicationBoost">
            <summary>
            Increase in priority given to the foreground application
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ForegroundApplicationBoost.None">
            <summary>
            The system boosts the quantum length by 6
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ForegroundApplicationBoost.Minimum">
            <summary>
            The system boosts the quantum length by 12
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ForegroundApplicationBoost.Maximum">
            <summary>
            The system boosts the quantum length by 18
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.FrontPanelResetStatus">
            <summary>
            hardware security settings for the reset button on a computer
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.FrontPanelResetStatus.Disabled">
            <summary>
            Reset button is disabled
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.FrontPanelResetStatus.Enabled">
            <summary>
            Reset button is enabled
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.FrontPanelResetStatus.NotImplemented">
            <summary>
            Hardware security settings are not implement
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.FrontPanelResetStatus.Unknown">
            <summary>
            Unknown security setting
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.HardwareSecurity">
            <summary>
            Indicates a hardware security setting
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.HardwareSecurity.Disabled">
            <summary>
            Hardware security is disabled
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.HardwareSecurity.Enabled">
            <summary>
            Hardware security is enabled
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.HardwareSecurity.NotImplemented">
            <summary>
            Hardware security is not implemented
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.HardwareSecurity.Unknown">
            <summary>
            Hardware security setting is unknown
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.NetConnectionStatus">
            <summary>
            State of the network adapter connection to the network
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NetConnectionStatus.Disconnected">
            <summary>
            Adapter is disconnected
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NetConnectionStatus.Connecting">
            <summary>
            Adapter is connecting
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NetConnectionStatus.Connected">
            <summary>
            Adapter is connected
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NetConnectionStatus.Disconnecting">
            <summary>
            Adapter is disconnecting
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NetConnectionStatus.HardwareNotPresent">
            <summary>
            Adapter hardware is not present
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NetConnectionStatus.HardwareDisabled">
            <summary>
            Adapter hardware is disabled
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NetConnectionStatus.HardwareMalfunction">
            <summary>
            Adapter has a hardware malfunction
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NetConnectionStatus.MediaDisconnected">
            <summary>
            Media is disconnected
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NetConnectionStatus.Authenticating">
            <summary>
            Adapter is authenticating
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NetConnectionStatus.AuthenticationSucceeded">
            <summary>
            Authentication has succeeded
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NetConnectionStatus.AuthenticationFailed">
            <summary>
            Authentication has failed
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NetConnectionStatus.InvalidAddress">
            <summary>
            Address is invalid
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NetConnectionStatus.CredentialsRequired">
            <summary>
            Credentials are required
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NetConnectionStatus.Other">
            <summary>
            Other unspecified state
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.OSEncryptionLevel">
            <summary>
            Encryption level for secure transactions: 40-bit, 128-bit, or n-bit.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSEncryptionLevel.Encrypt40Bits">
            <summary>
            40-bit encription
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSEncryptionLevel.Encrypt128Bits">
            <summary>
            128-bit encription
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSEncryptionLevel.EncryptNBits">
            <summary>
            n-bit encription
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.OSProductSuite">
            <summary>
            Indicates installed and licensed system product additions to the operating system
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSProductSuite.SmallBusinessServer">
            <summary>
            Microsoft Small Business Server was once installed, but may have
            been upgraded to another version of Windows
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSProductSuite.Server2008Enterprise">
            <summary>
            Windows Server 2008 Enterprise is installed
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSProductSuite.BackOfficeComponents">
            <summary>
            Windows BackOffice components are installed
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSProductSuite.CommunicationsServer">
            <summary>
            Communication Server is installed
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSProductSuite.TerminalServices">
            <summary>
            Terminal Services is installed
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSProductSuite.SmallBusinessServerRestricted">
            <summary>
            Microsoft Small Business Server is installed with the restrictive
            client license
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSProductSuite.WindowsEmbedded">
            <summary>
            Windows Embedded is installed
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSProductSuite.DatacenterEdition">
            <summary>
            A Datacenter edition is installed
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSProductSuite.TerminalServicesSingleSession">
            <summary>
            Terminal Services is installed, but only one interactive session is supported
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSProductSuite.HomeEdition">
            <summary>
            Windows Home Edition is installed
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSProductSuite.WebServerEdition">
            <summary>
            Web Server Edition is installed
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSProductSuite.StorageServerEdition">
            <summary>
            Storage Server Edition is installed
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSProductSuite.ComputeClusterEdition">
            <summary>
            Compute Cluster Edition is installed
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.OperatingSystemSKU">
            <summary>
            Indicates the operating system Stock Keeping Unit (SKU)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.Undefined">
            <summary>
            The SKU is undefined
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.UltimateEdition">
            <summary>
            SKU is Ultimate Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.HomeBasicEdition">
            <summary>
            SKU is Home Basic Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.HomePremiumEdition">
            <summary>
            SKU is Home Premium Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.EnterpriseEdition">
            <summary>
            SKU is Enterprise Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.HomeBasicNEdition">
            <summary>
            SKU is Home Basic N Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.BusinessEdition">
            <summary>
            SKU is Business Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.StandardServerEdition">
            <summary>
            SKU is Standard Server Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.DatacenterServerEdition">
            <summary>
            SKU is Datacenter Server Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.SmallBusinessServerEdition">
            <summary>
            SKU is Small Business Server Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.EnterpriseServerEdition">
            <summary>
            SKU is Enterprise Server Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.StarterEdition">
            <summary>
            SKU is Starter Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.DatacenterServerCoreEdition">
            <summary>
            SKU is Datacenter Server Core Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.StandardServerCoreEdition">
            <summary>
            SKU is Standard Server Core Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.EnterpriseServerCoreEdition">
            <summary>
            SKU is Enterprise Server Core Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.EnterpriseServerIA64Edition">
            <summary>
            SKU is Enterprise Server IA64 Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.BusinessNEdition">
            <summary>
            SKU is Business N Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WebServerEdition">
            <summary>
            SKU is Web Server Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.ClusterServerEdition">
            <summary>
            SKU is Cluster Server Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.HomeServerEdition">
            <summary>
            SKU is Home Server Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.StorageExpressServerEdition">
            <summary>
            SKU is Storage Express Server Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.StorageStandardServerEdition">
            <summary>
            SKU is Storage Standard Server Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.StorageWorkgroupServerEdition">
            <summary>
            SKU is Storage Workgroup Server Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.StorageEnterpriseServerEdition">
            <summary>
            SKU is Storage Enterprise Server Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.ServerForSmallBusinessEdition">
            <summary>
            SKU is Server For Small Business Edition
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.SmallBusinessServerPremiumEdition">
            <summary>
            SKU is Small Business Server Premium Edition 
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.TBD">
            <summary>
            SKU is to be determined
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WindowsEnterprise">
            <summary>
            SKU is Windows Enterprise
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WindowsUltimate">
            <summary>
            SKU is Windows Ultimate
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WebServerCore">
            <summary>
            SKU is Web Server (core installation)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.ServerFoundation">
            <summary>
            SKU is Server Foundation
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WindowsHomeServer">
            <summary>
            SKU is Windows Home Server
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WindowsServerStandardNoHyperVFull">
            <summary>
            SKU is Windows Server Standard without Hyper-V
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WindowsServerDatacenterNoHyperVFull">
            <summary>
            SKU is Windows Server Datacenter without Hyper-V (full installation)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WindowsServerEnterpriseNoHyperVFull">
            <summary>
            SKU is Windows Server Enterprise without Hyper-V (full installation)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WindowsServerDatacenterNoHyperVCore">
            <summary>
            SKU is Windows Server Datacenter without Hyper-V (core installation)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WindowsServerStandardNoHyperVCore">
            <summary>
            SKU is Windows Server Standard without Hyper-V (core installation)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WindowsServerEnterpriseNoHyperVCore">
            <summary>
            SKU is Windows Server Enterprise without Hyper-V (core installation)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.MicrosoftHyperVServer">
            <summary>
            SKU is Microsoft Hyper-V Server
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.StorageServerExpressCore">
            <summary>
            SKU is Storage Server Express (core installation)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.StorageServerStandardCore">
            <summary>
            SKU is Storage Server Standard (core installation)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.StorageServerWorkgroupCore">
            <summary>
            SKU is Storage Server Workgroup (core installation)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.StorageServerEnterpriseCore">
            <summary>
            SKU is Storage Server Enterprise (core installation)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WindowsSmallBusinessServer2011Essentials">
            <summary>
            SKU is Windows Small Business Server 2011 Essentials
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.SmallBusinessServerPremiumCore">
            <summary>
            SKU is Small Business Server Premium (core installation)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WindowsServerHyperCoreV">
            <summary>
            SKU is Windows Server Hyper Core V
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WindowsThinPC">
            <summary>
            SKU is Windows Thin PC
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WindowsEmbeddedIndustry">
            <summary>
            SKU is Windows Embedded Industry
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WindowsRT">
            <summary>
            SKU is Windows RT
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WindowsHome">
            <summary>
            SKU is Windows Home
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WindowsProfessionalWithMediaCenter">
            <summary>
            SKU is Windows Professional with Media Center
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WindowsMobile">
            <summary>
            SKU is Windows Mobile
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WindowsEmbeddedHandheld">
            <summary>
            SKU is Windows Embedded Handheld
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OperatingSystemSKU.WindowsIotCore">
            <summary>
            SKU is Windows IoT (Internet of Things) Core
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.OSType">
            <summary>
            Type of operating system
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.Unknown">
            <summary>
            OS is unknown
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.Other">
            <summary>
            OS is one other than covered by this Enum
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.MACROS">
            <summary>
            OS is MacOS
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.ATTUNIX">
            <summary>
            OS is AT&amp;T UNIX
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.DGUX">
            <summary>
            OS is DG/UX
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.DECNT">
            <summary>
            OS is DECNT
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.DigitalUNIX">
            <summary>
            OS is Digital UNIX
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.OpenVMS">
            <summary>
            OS is OpenVMS
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.HPUX">
            <summary>
            OS is HP-UX
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.AIX">
            <summary>
            OS is AIX
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.MVS">
            <summary>
            OS is MVS
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.OS400">
            <summary>
            OS is OS/400
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.OS2">
            <summary>
            OS is OS/2
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.JavaVM">
            <summary>
            OS is Java Virtual Machine
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.MSDOS">
            <summary>
            OS is MS-DOS
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.WIN3x">
            <summary>
            OS is Windows 3x
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.WIN95">
            <summary>
            OS is Windows 95
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.WIN98">
            <summary>
            OS is Windows 98
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.WINNT">
            <summary>
            OS is Windows NT
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.WINCE">
            <summary>
            OS is Windows CE
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.NCR3000">
            <summary>
            OS is NCR System 3000
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.NetWare">
            <summary>
            OS is NetWare
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.OSF">
            <summary>
            OS is OSF
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.DC_OS">
            <summary>
            OS is DC/OS
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.ReliantUNIX">
            <summary>
            OS is Reliant UNIX
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.SCOUnixWare">
            <summary>
            OS is SCO UnixWare
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.SCOOpenServer">
            <summary>
            OS is SCO OpenServer
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.Sequent">
            <summary>
            OS is Sequent
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.IRIX">
            <summary>
            OS is IRIX
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.Solaris">
            <summary>
            OS is Solaris
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.SunOS">
            <summary>
            OS is SunOS
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.U6000">
            <summary>
            OS is U6000
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.ASERIES">
            <summary>
            OS is ASERIES
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.TandemNSK">
            <summary>
            OS is Tandem NSK
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.TandemNT">
            <summary>
            OS is Tandem NT
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.BS2000">
            <summary>
            OS is BS2000
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.LINUX">
            <summary>
            OS is Linux
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.Lynx">
            <summary>
            OS is Lynx
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.XENIX">
            <summary>
            OS is XENIX
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.VM_ESA">
            <summary>
            OS is VM/ESA
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.InteractiveUNIX">
            <summary>
            OS is Interactive UNIX
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.BSDUNIX">
            <summary>
            OS is BSD UNIX
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.FreeBSD">
            <summary>
            OS is FreeBSD
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.NetBSD">
            <summary>
            OS is NetBSD
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.GNUHurd">
            <summary>
            OS is GNU Hurd
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.OS9">
            <summary>
            OS is OS 9
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.MACHKernel">
            <summary>
            OS is Mach Kernel
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.Inferno">
            <summary>
            OS is Inferno
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.QNX">
            <summary>
            OS is QNX
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.EPOC">
            <summary>
            OS is EPOC
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.IxWorks">
            <summary>
            OS is IxWorks
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.VxWorks">
            <summary>
            OS is VxWorks
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.MiNT">
            <summary>
            OS is MiNT
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.BeOS">
            <summary>
            OS is BeOS
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.HP_MPE">
            <summary>
            OS is HP MPE
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.NextStep">
            <summary>
            OS is NextStep
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.PalmPilot">
            <summary>
            OS is PalmPilot
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.Rhapsody">
            <summary>
            OS is Rhapsody
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.Windows2000">
            <summary>
            OS is Windows 2000
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.Dedicated">
            <summary>
            OS is Dedicated
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.OS_390">
            <summary>
            OS is OS/390
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.VSE">
            <summary>
            OS is VSE
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.OSType.TPF">
            <summary>
            OS is TPF
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.PCSystemType">
            <summary>
            Specifies the type of the computer in use, such as laptop, desktop, or Tablet
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PCSystemType.Unspecified">
            <summary>
            System type is unspecified
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PCSystemType.Desktop">
            <summary>
            System is a desktop
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PCSystemType.Mobile">
            <summary>
            System is a mobile device
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PCSystemType.Workstation">
            <summary>
            System is a workstation
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PCSystemType.EnterpriseServer">
            <summary>
            System is an Enterprise Server
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PCSystemType.SOHOServer">
            <summary>
            System is a Small Office and Home Office (SOHO) Server
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PCSystemType.AppliancePC">
            <summary>
            System is an appliance PC
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PCSystemType.PerformanceServer">
            <summary>
            System is a performance server
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PCSystemType.Maximum">
            <summary>
            Maximum enum value
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.PCSystemTypeEx">
            <summary>
            Specifies the type of the computer in use, such as laptop, desktop, or Tablet.
            This is an extended verion of PCSystemType
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PCSystemTypeEx.Unspecified">
            <summary>
            System type is unspecified
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PCSystemTypeEx.Desktop">
            <summary>
            System is a desktop
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PCSystemTypeEx.Mobile">
            <summary>
            System is a mobile device
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PCSystemTypeEx.Workstation">
            <summary>
            System is a workstation
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PCSystemTypeEx.EnterpriseServer">
            <summary>
            System is an Enterprise Server
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PCSystemTypeEx.SOHOServer">
            <summary>
            System is a Small Office and Home Office (SOHO) Server
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PCSystemTypeEx.AppliancePC">
            <summary>
            System is an appliance PC
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PCSystemTypeEx.PerformanceServer">
            <summary>
            System is a performance server
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PCSystemTypeEx.Slate">
            <summary>
            System is a Slate
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PCSystemTypeEx.Maximum">
            <summary>
            Maximum enum value
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.PowerManagementCapabilities">
            <summary>
            Specifies power-related capabilities of a logical device
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerManagementCapabilities.Unknown">
            <summary>
            Unknown capability
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerManagementCapabilities.NotSupported">
            <summary>
            Power management not supported
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerManagementCapabilities.Disabled">
            <summary>
            Power management features are currently disabled
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerManagementCapabilities.Enabled">
            <summary>
            The power management features are currently enabled,
            but the exact feature set is unknown or the information is unavailable
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerManagementCapabilities.PowerSavingModesEnteredAutomatically">
            <summary>
            The device can change its power state based on usage or other criteria
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerManagementCapabilities.PowerStateSettable">
            <summary>
            The power state may be set through the Win32_LogicalDevice class
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerManagementCapabilities.PowerCyclingSupported">
            <summary>
            Power may be done through the Win32_LogicalDevice class
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerManagementCapabilities.TimedPowerOnSupported">
            <summary>
            Timed power-on is supported
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.PowerState">
            <summary>
            Specified power states
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerState.Unknown">
            <summary>
            Power state is unknown
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerState.FullPower">
            <summary>
            Full power
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerState.PowerSaveLowPowerMode">
            <summary>
            Power Save - Low Power mode 
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerState.PowerSaveStandby">
            <summary>
            Power Save - Standby
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerState.PowerSaveUnknown">
            <summary>
            Unknown Power Save mode
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerState.PowerCycle">
            <summary>
            Power Cycle
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerState.PowerOff">
            <summary>
            Power Off
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerState.PowerSaveWarning">
            <summary>
            Power Save - Warning
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerState.PowerSaveHibernate">
            <summary>
            Power Save - Hibernate
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerState.PowerSaveSoftOff">
            <summary>
            Power Save - Soft off
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ProcessorType">
            <summary>
            Specifies the primary function of a processor
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ProcessorType.Other">
            <summary>
            Processor ype is other than provided in these enumeration values
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ProcessorType.Unknown">
            <summary>
            Proccessor type is 
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ProcessorType.CentralProcessor">
            <summary>
            Proccessor is a Central Processing Unit (CPU)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ProcessorType.MathProcessor">
            <summary>
            Proccessor is a Math processor
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ProcessorType.DSPProcessor">
            <summary>
            Proccessor is a Digital Signal processor (DSP)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ProcessorType.VideoProcessor">
            <summary>
            Proccessor is a Video processor
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ResetCapability">
            <summary>
            Specifies a computer's reset capability
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ResetCapability.Other">
            <summary>
            Capability is a value other than provided in these enumerated values
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ResetCapability.Unknown">
            <summary>
            Reset capability is unknown
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ResetCapability.Disabled">
            <summary>
            Capability is disabled
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ResetCapability.Enabled">
            <summary>
            Capability is enabled
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ResetCapability.NotImplemented">
            <summary>
            Capability is not implemented
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WakeUpType">
            <summary>
            Specifies the kind of event that causes a computer to power up
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WakeUpType.Other">
            <summary>
            An event other than specified in this enumeration
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WakeUpType.Unknown">
            <summary>
            Event type is unknown
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WakeUpType.APMTimer">
            <summary>
            Event is APM timer
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WakeUpType.ModemRing">
            <summary>
            Event is a Modem Ring
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WakeUpType.LANRemote">
            <summary>
            Event is a LAN Remove
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WakeUpType.PowerSwitch">
            <summary>
            Event is a power switch
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WakeUpType.PCIPME">
            <summary>
            Event is a PCI PME# signal
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WakeUpType.ACPowerRestored">
            <summary>
            AC power was restored
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.PowerPlatformRole">
            <summary>
            Indicates the OEM's preferred power management profile
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerPlatformRole.Unspecified">
            <summary>
            The OEM did not specify a specific role
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerPlatformRole.Desktop">
            <summary>
            The OEM specified a desktop role
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerPlatformRole.Mobile">
            <summary>
            The OEM specified a mobile role (for example, a laptop)
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerPlatformRole.Workstation">
            <summary>
            The OEM specified a workstation role
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerPlatformRole.EnterpriseServer">
            <summary>
            The OEM specified an enterprise server role
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerPlatformRole.SOHOServer">
            <summary>
            The OEM specified a single office/home office (SOHO) server role
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerPlatformRole.AppliancePC">
            <summary>
            The OEM specified an appliance PC role
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerPlatformRole.PerformanceServer">
            <summary>
            The OEM specified a performance server role
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerPlatformRole.Slate">
            <summary>
            The OEM specified a tablet form factor role
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.PowerPlatformRole.MaximumEnumValue">
            <summary>
            Max enum value
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ProductType">
            <summary>
            Additional system information, from Win32_OperatingSystem
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ProductType.Unknown">
            <summary>
            Product type is unknown
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ProductType.WorkStation">
            <summary>
            System is a workstation
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ProductType.DomainController">
            <summary>
            System is a domain controller
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ProductType.Server">
            <summary>
            System is a server
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ServerLevel">
            <summary>
            Specifies the system server level
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ServerLevel.Unknown">
            <summary>
            An unknown or unrecognized level was dected
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ServerLevel.NanoServer">
            <summary>
            Nano server
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ServerLevel.ServerCore">
            <summary>
            Server core
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ServerLevel.ServerCoreWithManagementTools">
            <summary>
            Server core with management tools
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ServerLevel.FullServer">
            <summary>
            Full server
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SoftwareElementState">
            <summary>
            State of a software element
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SoftwareElementState.Deployable">
            <summary>
            Software element is deployable
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SoftwareElementState.Installable">
            <summary>
            Software element is installable
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SoftwareElementState.Executable">
            <summary>
            Software element is executable
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SoftwareElementState.Running">
            <summary>
            Software element is running
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.Native.PowerDeterminePlatformRoleEx(System.UInt32)">
            <summary>
            Import WINAPI function PowerDeterminePlatformRoleEx
            </summary>
            <param name="version">The version of the POWER_PLATFORM_ROLE enumeration for the platform</param>
            <returns>POWER_PLATFORM_ROLE enumeration</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.Native.GetPhysicallyInstalledSystemMemory(System.UInt64@)">
            <summary>
            Retrieve the amount of RAM physically installed in the computer
            </summary>
            <param name="MemoryInKilobytes"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.Native.GetFirmwareType(Microsoft.PowerShell.Commands.FirmwareType@)">
            <summary>
            Retrieve the firmware type of the local computer
            </summary>
            <param name="firmwareType">
            A reference to a <see cref="T:Microsoft.PowerShell.Commands.FirmwareType"/> enumeration to contain
            the resultant firmware type
            </param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.Native.LCIDToLocaleName(System.UInt32,System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Convert a Local Identifier to a Locale name
            </summary>
            <param name="localeID">The Locale ID (LCID) to be converted</param>
            <param name="localeName">Destination of the Locale name</param>
            <param name="localeNameSize">Capacity of <paramref name="localeName"/></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.Native.SLGetWindowsInformationDWORD(System.String,System.Int32@)">
            <summary>    
            Gets the data specified for the passed in property name from the
            Software Licensing API
            </summary>
            <param name="licenseProperty">Name of the licensing property to get.</param>    
            <param name="propertyValue">Out parameter for the value.</param>    
            <returns>An hresult indicating success or failure.</returns>    
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CIMHelper.WqlQueryAll(System.String)">
            <summary>
            Create a WQL query string to retrieve all properties from
            the specified WMI class.
            </summary>
            <param name="from">A string containing the WMI class name.</param>
            <returns>
            A string containing the WQL query string
            </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CIMHelper.GetFirst``1(Microsoft.Management.Infrastructure.CimSession,System.String,System.String)">
            <summary>
            Retrieve a new object of type T, whose properties and fields are
            populated from an instance of the named WMI class. If the CIM
            query results in multiple instances, only the first instance is
            returned.
            </summary>
            <typeparam name="T">
            The type of the object to be created. Must be a default-constructable
            reference type.
            </typeparam>
            <param name="session">
            The CIM session to be queried.
            </param>
            <param name="nameSpace">
            A string containing the namespace to run the query against
            </param>
            <param name="wmiClassName">
            A string containing the name of the WMI class from which to populate
            the resultant object.
            </param>
            <returns>
            A new object of type T if successful, null otherwise.
            </returns>
            <remarks>
            This method matches property and field names of type T with identically
            named properties in the WMI class instance. The WMI property is converted
            to the type of T's property or field.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CIMHelper.GetAll``1(Microsoft.Management.Infrastructure.CimSession,System.String,System.String)">
            <summary>
            Retrieve an array of new objects of type T, whose properties and fields are
            populated from an instance of the specified WMI class on the specified CIM
            session.
            </summary>
            <typeparam name="T">
            The type of the object to be created. Must be a default-constructable
            reference type.
            </typeparam>
            <param name="session">
            The CIM session to be queried.
            </param>
            <param name="nameSpace">
            A string containing the namespace to run the query against
            </param>
            <param name="wmiClassName">
            A string containing the name of the WMI class from which to populate
            the resultant array elements.
            </param>
            <returns>
            An array of new objects of type T if successful, null otherwise.
            </returns>
            <remarks>
            This method matches property and field names of type T with identically
            named properties in the WMI class instance. The WMI property is converted
            to the type of T's property or field.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CIMHelper.GetAll``1(Microsoft.Management.Infrastructure.CimSession,System.String)">
            <summary>
            Retrieve an array of new objects of type T, whose properties and fields are
            populated from an instance of the specified WMI class on the specified CIM
            session.
            </summary>
            <typeparam name="T">
            The type of the object to be created. Must be a default-constructable
            reference type.
            </typeparam>
            <param name="session">
            The CIM session to be queried.
            </param>
            <param name="wmiClassName">
            A string containing the name of the WMI class from which to populate
            the resultant array elements.
            </param>
            <returns>
            An array of new objects of type T if successful, null otherwise.
            </returns>
            <remarks>
            This method matches property and field names of type T with identically
            named properties in the WMI class instance. The WMI property is converted
            to the type of T's property or field.
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CIMHelper.EscapePath(System.String)">
            <summary>
            Escape any backslash (\) characters in a path with an additional
            backslash, allowing the path to be used within a WMI query.
            </summary>
            <param name="path">
            A string that may contain backslash characters.
            </param>
            <returns>
            A new string in which any backshlash characters have been "escaped"
            by prefacing then with an additional backslash
            </returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetTimeZoneCommand">
            <summary>
            A cmdlet to retrieve time zone information.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetTimeZoneCommand.Id">
            <summary>
            A list of the local time zone ids that the cmdlet should look up.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetTimeZoneCommand.ListAvailable">
            <summary>
            Specifies that the cmdlet should produce a collection of the 
            TimeZoneInfo objects that are available on the system.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetTimeZoneCommand.Name">
            <summary>
            A list of the local time zone names that the cmdlet should look up.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetTimeZoneCommand.ProcessRecord">
            <summary>
            Implementation of the ProcessRecord method for Get-TimeZone
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SetTimeZoneCommand">
            <summary>
            A cmdlet to set the system's local time zone.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetTimeZoneCommand.Id">
            <summary>
            The name of the local time zone that the system should use.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetTimeZoneCommand.InputObject">
            <summary>
            A TimeZoneInfo object identifying the local time zone that the system should use.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetTimeZoneCommand.Name">
            <summary>
            The name of the local time zone that the system should use.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetTimeZoneCommand.PassThru">
            <summary>
            Request return of the new local time zone as a TimeZoneInfo object
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetTimeZoneCommand.ProcessRecord">
            <summary>
            Implementation of the ProcessRecord method for Get-TimeZone
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetTimeZoneCommand.HasAccess">
            <summary>
            True if the current process has access to change the time zone setting.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetTimeZoneCommand.SetAccessToken(System.Boolean)">
            <summary>
            Set the SeTimeZonePrivilege, which controls access to the SetDynamicTimeZoneInformation API
            </summary>
            <param name="enable">Set to true to enable (or false to disable) the privilege.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetTimeZoneCommand.ThrowWin32Error">
            <summary>
            Get the Win32 error code from GetLastError and throw an exception.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.#ctor">
            <summary>
            Private constructor to prevent instantiation
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.SystemTime">
            <summary>
            Used to marshal win32 SystemTime structure to managed code layer
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.SystemTime.Year">
            <summary>
            The year.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.SystemTime.Month">
            <summary>
            The month.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.SystemTime.DayOfWeek">
            <summary>
            The day of the week.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.SystemTime.Day">
            <summary>
            The day of the month.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.SystemTime.Hour">
            <summary>
            The hour.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.SystemTime.Minute">
            <summary>
            The minute.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.SystemTime.Second">
            <summary>
            The second.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.SystemTime.Milliseconds">
            <summary>
            The millisecond.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.DYNAMIC_TIME_ZONE_INFORMATION">
            <summary>
            Used to marshal win32 DYNAMIC_TIME_ZONE_INFORMATION structure to managed code layer
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.DYNAMIC_TIME_ZONE_INFORMATION.Bias">
            <summary>
            The current bias for local time translation on this computer, in minutes.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.DYNAMIC_TIME_ZONE_INFORMATION.StandardName">
            <summary>
            A description for standard time.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.DYNAMIC_TIME_ZONE_INFORMATION.StandardDate">
            <summary>
            A SystemTime structure that contains a date and local time when the transition from daylight saving time to standard time occurs on this operating system.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.DYNAMIC_TIME_ZONE_INFORMATION.StandardBias">
            <summary>
            The bias value to be used during local time translations that occur during standard time.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.DYNAMIC_TIME_ZONE_INFORMATION.DaylightName">
            <summary>
            A description for daylight saving time (DST).
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.DYNAMIC_TIME_ZONE_INFORMATION.DaylightDate">
            <summary>
            A SystemTime structure that contains a date and local time when the transition from standard time to daylight saving time occurs on this operating system.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.DYNAMIC_TIME_ZONE_INFORMATION.DaylightBias">
            <summary>
            The bias value to be used during local time translations that occur during daylight saving time.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.DYNAMIC_TIME_ZONE_INFORMATION.TimeZoneKeyName">
            <summary>
            The name of the time zone registry key on the local computer.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.DYNAMIC_TIME_ZONE_INFORMATION.DynamicDaylightTimeDisabled">
            <summary>
            Indicates whether dynamic daylight saving time is disabled.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.TIME_ZONE_INFORMATION">
            <summary>
            Used to marshal win32 TIME_ZONE_INFORMATION structure to managed code layer
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.TIME_ZONE_INFORMATION.Bias">
            <summary>
            The current bias for local time translation on this computer, in minutes.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.TIME_ZONE_INFORMATION.StandardName">
            <summary>
            A description for standard time.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.TIME_ZONE_INFORMATION.StandardDate">
            <summary>
            A SystemTime structure that contains a date and local time when the transition from daylight saving time to standard time occurs on this operating system.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.TIME_ZONE_INFORMATION.StandardBias">
            <summary>
            The bias value to be used during local time translations that occur during standard time.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.TIME_ZONE_INFORMATION.DaylightName">
            <summary>
            A description for daylight saving time (DST).
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.TIME_ZONE_INFORMATION.DaylightDate">
            <summary>
            A SystemTime structure that contains a date and local time when the transition from standard time to daylight saving time occurs on this operating system.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.TIME_ZONE_INFORMATION.DaylightBias">
            <summary>
            The bias value to be used during local time translations that occur during daylight saving time.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.SetDynamicTimeZoneInformation(Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.DYNAMIC_TIME_ZONE_INFORMATION@)">
            <summary>
            PInvoke SetDynamicTimeZoneInformation API
            </summary>
            <param name="lpTimeZoneInformation">A DYNAMIC_TIME_ZONE_INFORMATION structure representing the desired local time zone.</param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.TOKEN_QUERY">
            <summary>
            Definition of TOKEN_QUERY constant from Win32 API
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.TOKEN_ADJUST_PRIVILEGES">
            <summary>
            Definition of TOKEN_ADJUST_PRIVILEGES constant from Win32 API
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.SE_PRIVILEGE_ENABLED">
            <summary>
            Definition of SE_PRIVILEGE_ENABLED constant from Win32 API
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.SE_TIME_ZONE_NAME">
            <summary>
            Definition of SE_TIME_ZONE_NAME constant from Win32 API
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.GetCurrentProcess">
            <summary>
            PInvoke GetCurrentProcess API
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.OpenProcessToken(System.IntPtr,System.Int32,System.IntPtr@)">
            <summary>
            PInvoke OpenProcessToken API
            </summary>
            <param name="ProcessHandle"></param>
            <param name="DesiredAccess"></param>
            <param name="TokenHandle"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.LookupPrivilegeValue(System.String,System.String,System.Int64@)">
            <summary>
            PInvoke LookupPrivilegeValue API
            </summary>
            <param name="lpSystemName"></param>
            <param name="lpName"></param>
            <param name="lpLuid"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.PrivilegeCheck(System.IntPtr,Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.PRIVILEGE_SET@,System.Boolean@)">
            <summary>
            PInvoke PrivilegeCheck API
            </summary>
            <param name="ClientToken"></param>
            <param name="RequiredPrivileges"></param>
            <param name="pfResult"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.AdjustTokenPrivileges(System.IntPtr,System.Boolean,Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.TOKEN_PRIVILEGES@,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            PInvoke AdjustTokenPrivilege API
            </summary>
            <param name="TokenHandle"></param>
            <param name="DisableAllPrivilegs"></param>
            <param name="NewState"></param>
            <param name="BufferLength"></param>
            <param name="PreviousState"></param>
            <param name="ReturnLength"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.CloseHandle(System.IntPtr)">
            <summary>
            PInvoke CloseHandle API
            </summary>
            <param name="hObject"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.PRIVILEGE_SET">
            <summary>
            Used to marshal win32 PRIVILEGE_SET structure to managed code layer
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.TOKEN_PRIVILEGES">
            <summary>
            Used to marshal win32 TOKEN_PRIVILEGES structure to managed code layer
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.WM_SETTINGCHANGE">
            <summary>
            Definition of WM_SETTINGCHANGE constant from Win32 API
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.HWND_BROADCAST">
            <summary>
            Definition of HWND_BROADCAST constant from Win32 API
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.SMTO_ABORTIFHUNG">
            <summary>
            Definition of SMTO_ABORTIFHUNG constant from Win32 API
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetTimeZoneCommand.NativeMethods.SendMessageTimeout(System.IntPtr,System.Int32,System.IntPtr,System.String,System.Int32,System.Int32,System.Int32@)">
            <summary>
            PInvoke SendMessageTimeout API
            </summary>
            <param name="hWnd"></param>
            <param name="Msg"></param>
            <param name="wParam"></param>
            <param name="lParam"></param>
            <param name="fuFlags"></param>
            <param name="uTimeout"></param>
            <param name="lpdwResult"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.TimeZoneHelper">
            <summary>
            static Helper class for working with system time zones.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TimeZoneHelper.ClearCachedData">
            <summary>
            Clear the cached TimeZoneInfo data.  Note that since TimeZoneInfo.ClearCachedData
            does not exist in .NET Core there is an alternative mechanism (which doesn't seem
            to affect clearing out the cache under the full desktop version of .NET)
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.TimeZoneHelper.LookupSystemTimeZoneInfoByName(System.String)">
            <summary>
            Find the system time zone by checking first against StandardName and then, 
            if no matches were found, against the DaylightName.
            </summary>
            <param name="name">The name (or wildcard pattern) of the system time zone to find.</param>
            <returns>A TimeZoneInfo object array containing information about the specified system time zones.</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ClearRecycleBinCommand">
            <summary>
            Defines the implementation of the 'Clear-RecycleBin' cmdlet.
            This cmldet clear all files in the RecycleBin for the given DriveLetter. 
            If not DriveLetter is specified, then the RecycleBin for all drives are cleared. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearRecycleBinCommand.DriveLetter">
            <summary>  
            Property that sets DriveLetter parameter.
            </summary>  
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearRecycleBinCommand.Force">
            <summary>  
            Property that sets force parameter. This will allow to clear the recyclebin.  
            </summary>  
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ClearRecycleBinCommand.BeginProcessing">
            <summary>
            This method implements the BeginProcessing method for Clear-RecycleBin command.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ClearRecycleBinCommand.ProcessRecord">
            <summary>
            This method implements the ProcessRecord method for Clear-RecycleBin command.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ClearRecycleBinCommand.ValidDrivePath(System.String)">
            <summary>
            Returns true if the given drive is 'fixed' and its path exist; otherwise, return false.
            </summary>
            <param name="drivePath"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ClearRecycleBinCommand.IsValidPattern(System.String)">
            <summary>
            Returns true if the given input is of the form c, c:, c:\, C, C: or C:\ 
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ClearRecycleBinCommand.GetDrivePath(System.String)">
            <summary>
            Returns a drive path of the form C:\ for the given drive driveName. 
            Supports the following inputs: C, C:, C:\
            </summary>
            <param name="driveName"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ClearRecycleBinCommand.EmptyRecycleBin(System.String)">
            <summary>
            Clear the recyclebin for the given drive name. 
            If no driveName is provided, it clears the recyclebin for all drives.
            </summary>
            <param name="drivePath"></param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SetClipboardCommand">
            <summary>
            Defines the implementation of the 'Set-Clipboard' cmdlet.
            This cmldet get the content from system clipboard. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetClipboardCommand.Value">
            <summary>  
            Property that sets clipboard content.
            </summary>  
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetClipboardCommand.Append">
            <summary>  
            Property that sets append parameter. This will allow to append clipboard without clear it. 
            </summary>  
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetClipboardCommand.Path">
            <summary>  
            Property that sets Path parameter. This will allow to set file formats to Clipboard. 
            </summary>  
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetClipboardCommand.LiteralPath">
            <summary>  
            Property that sets LiteralPath parameter. This will allow to set file formats to Clipboard. 
            </summary>  
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetClipboardCommand.AsHtml">
            <summary>  
            Property that sets html parameter. This will allow html content rendered as html to clipboard.
            </summary>  
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetClipboardCommand.BeginProcessing">
            <summary>
            This method implements the BeginProcessing method for Set-Clipboard command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetClipboardCommand.ProcessRecord">
            <summary>
            This method implements the ProcessRecord method for Set-Clipboard command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetClipboardCommand.EndProcessing">
            <summary>
            This method implements the EndProcessing method for Set-Clipboard command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetClipboardCommand.SetClipboardContent(System.Collections.Generic.List{System.String},System.Boolean,System.Boolean)">
            <summary>
            Set the clipboard content.
            </summary>
            <param name="contentList"></param>
            <param name="append"></param>
            <param name="asHtml"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetClipboardCommand.CopyFilesToClipboard(System.Collections.Generic.List{System.String},System.Boolean,System.Boolean)">
            <summary>
            Copy the file format to clipboard.
            </summary>
            <param name="fileList"></param>
            <param name="append"></param>
            <param name="isLiteralPath"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetClipboardCommand.GetHtmlDataString(System.String)">
            <summary>      
            Generate HTML fragment data string with  header that is required for the clipboard.      
            </summary>      
            <param name="html">the  html to generate for</param>      
            <returns>the resulted  string</returns>      
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetClipboardCommand.GetByteCount(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>      
            Calculates the number of bytes produced  by encoding the string in the string builder in UTF-8 and not .NET default  string encoding.      
            </summary>      
            <param name="sb">the  string builder to count its string</param>      
            <param  name="start">optional: the start index to calculate from (default  - start of string)</param>      
            <param  name="end">optional: the end index to calculate to (default - end  of string)</param>      
            <returns>the number of bytes  required to encode the string in UTF-8</returns>      
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ClipboardFormat">
            <summary>
            Defines the different type supported by the clipboard.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ClipboardFormat.Text">
            Text format as default.
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ClipboardFormat.FileDropList">
            File format.
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ClipboardFormat.Image">
            Image format.
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ClipboardFormat.Audio">
            Audio format.
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetClipboardCommand">
            <summary>
            Defines the implementation of the 'Get-Clipboard' cmdlet.
            This cmdlet get the content from system clipboard. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetClipboardCommand.Format">
            <summary>  
            Property that sets clipboard type. This will return the required format from clipboard 
            </summary>  
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetClipboardCommand.TextFormatType">
            <summary>  
            Property that sets format type when the return type is text.
            </summary>  
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetClipboardCommand.Raw">
            <summary>  
            Property that sets raw parameter. This will allow clipboard return text or file list as one string.
            </summary>  
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetClipboardCommand.BeginProcessing">
            <summary>
            This method implements the ProcessRecord method for Get-Clipboard command
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetClipboardCommand.GetClipboardContentAsText(System.Windows.Forms.TextDataFormat)">
            <summary>
            Returns the clipboard content as text format.
            </summary>
            <param name="textFormat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetClipboardCommand.GetClipboardContentAsFileList">
            <summary>
            Returns the clipboard content as file info.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetClipboardCommand.WrapOutputInPSObject(System.IO.FileInfo,System.String)">
            <summary>
            Wraps the item in a PSObject and attaches some notes to the
            object that deal with path information.
            </summary>
            <param name="item"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ControlPanelItem">
            <summary>
            Represent a control panel item
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ControlPanelItem.Name">
            <summary>
            Control panel applet name
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ControlPanelItem.CanonicalName">
            <summary>
            Control panel applet canonical name
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ControlPanelItem.Category">
            <summary>
            Control panel applet category
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ControlPanelItem.Description">
            <summary>
            Control panel applet description
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ControlPanelItem.Path">
            <summary>
            Control panel applet path
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ControlPanelItem.#ctor(System.String,System.String,System.String[],System.String,System.String)">
            <summary>
            Internal constructor for ControlPanelItem
            </summary>
            <param name="name"></param>
            <param name="canonicalName"></param>
            <param name="category"></param>
            <param name="description"></param>
            <param name="path"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ControlPanelItem.ToString">
            <summary>
            ToString method
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ControlPanelItemBaseCommand">
            <summary>
            This class implements the base for ControlPanelItem commands
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ControlPanelItemBaseCommand.VerbActionOpenName">
            <summary>
            Locale specific verb action Open string exposed by the control panel item.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.ControlPanelItemBaseCommand.RegionCanonicalName">
            <summary>
            Canonical name of the control panel item used as a refernece to fetch the verb
            action Open string. This control panel item exists on all SKU's.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ControlPanelItemBaseCommand.AllControlPanelItems">
            <summary>
            Get all executable control panel items
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ControlPanelItemBaseCommand.BeginProcessing">
            <summary>
            Does the preprocessing for ControlPanelItem cmdlets
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ControlPanelItemBaseCommand.ContainVerbOpen(Shell32.ShellFolderItem)">
            <summary>
            Test if an item can be invoked
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ControlPanelItemBaseCommand.CompareVerbActionOpen(System.String)">
            <summary>
            CompareVerbActionOpen is a helper function used to perform locale specific
            comparision of the verb action Open exposed by various control panel items.
            </summary>
            <param name="verbActionName">Locale spcific verb action exposed by the control panel item.</param>
            <returns>True if the control panel item supports verb action open or else returns false.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ControlPanelItemBaseCommand.IsServerCoreOrHeadLessServer">
            <summary>
            IsServerCoreORHeadLessServer is a helper function that checks if the current SKU is a 
            Server Core machine or if the Server-GUI-Shell feature is removed on the machine.
            </summary>
            <returns>True if the current SKU is a Server Core machine or if the Server-GUI-Shell 
            feature is removed on the machine or else returns false.</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ControlPanelItemBaseCommand.GetCategoryMap">
            <summary>
            Get the category number and name map
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ControlPanelItemBaseCommand.GetControlPanelItemByCategory(System.Collections.Generic.List{Shell32.ShellFolderItem})">
            <summary>
            Get control panel item by the category
            </summary>
            <param name="controlPanelItems"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ControlPanelItemBaseCommand.GetControlPanelItemByName(System.Collections.Generic.List{Shell32.ShellFolderItem},System.Boolean)">
            <summary>
            Get control panel item by the regular name
            </summary>
            <param name="controlPanelItems"></param>
            <param name="withCategoryFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ControlPanelItemBaseCommand.GetControlPanelItemByCanonicalName(System.Collections.Generic.List{Shell32.ShellFolderItem},System.Boolean)">
            <summary>
            Get control panel item by the canonical name
            </summary>
            <param name="controlPanelItems"></param>
            <param name="withCategoryFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ControlPanelItemBaseCommand.GetControlPanelItemsByInstance(System.Collections.Generic.List{Shell32.ShellFolderItem})">
            <summary>
            Get control panel item by the ControlPanelItem instances
            </summary>
            <param name="controlPanelItems"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetControlPanelItemCommand">
            <summary>
            Get all control panel items that is available in the "All Control Panel Items" category
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetControlPanelItemCommand.Name">
            <summary>
            Control panel item names
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetControlPanelItemCommand.CanonicalName">
            <summary>
            Canonical names of control panel items
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetControlPanelItemCommand.Category">
            <summary>
            Category of control panel items
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetControlPanelItemCommand.ProcessRecord">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ShowControlPanelItemCommand">
            <summary>
            Show the specified control panel applet
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowControlPanelItemCommand.Name">
            <summary>
            Control panel item names
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowControlPanelItemCommand.CanonicalName">
            <summary>
            Canonical names of control panel items
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowControlPanelItemCommand.InputObject">
            <summary>
            Control panel items returned by Get-ControlPanelItem
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowControlPanelItemCommand.ProcessRecord">
            <summary>
            
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetEventLogCommand">
            <summary>
            This class implements the Get-EventLog command
            </summary>
            <remarks>
            The CLR EventLogEntryCollection class has problems with managing
            rapidly spinning logs (i.e. logs set to "Overwrite" which are
            rapidly getting new events and discarding old events).
            In particular, if you enumerate forward
                EventLogEntryCollection entries = log.Entries;
                foreach (EventLogEntry entry in entries)
            it will occasionally skip an entry.  Conversely, if you are
            enumerating backward
                EventLogEntryCollection entries = log.Entries;
                int count = entries.Count;
                for (int i = count-1; i >= 0; i--) {
                    EventLogEntry entry = entries[i];
            it will occasionally repeat an entry.  Accordingly, we enumerate
            backward and try to leave off the repeated entries.
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetEventLogCommand.LogName">
            <summary>
            Read eventlog entries from this log
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetEventLogCommand.ComputerName">
            <summary>
            Read eventlog entries from this computer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetEventLogCommand.Newest">
            <summary>
            Read only this number of entries
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetEventLogCommand.After">
            <summary>
            Return entries "after " this date.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetEventLogCommand.Before">
            <summary>
            Return entries "Before" this date.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetEventLogCommand.UserName">
            <summary>
            Return entries for this user.Wild characters is supported.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetEventLogCommand.InstanceId">
            <summary>
            match eventlog entries by the InstanceIds
            gets or sets an array of instanceIds
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetEventLogCommand.Index">
            <summary>
            match eventlog entries by the Index
            gets or sets an array of indexes
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetEventLogCommand.EntryType">
            <summary>
            match eventlog entries by the EntryType
            gets or sets an array of EntryTypes
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetEventLogCommand.Source">
            <summary>
            get or sets an array of Source
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetEventLogCommand.Message">
            <summary>
            Get or Set Message string to searched in EventLog
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetEventLogCommand.AsBaseObject">
            <summary>
            returns Log Entry as base object
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetEventLogCommand.List">
            <summary>
            Return the Eventlog objects rather than the log contents
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetEventLogCommand.AsString">
            <summary>
            Return the log names rather than the EventLog objects
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.GetEventLogCommand.isFilterSpecified">
            <summary>
            Sets true when Filter is Specified
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetEventLogCommand.BeginProcessing">
            <summary>
            Process the specified logs
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ClearEventLogCommand">
            <summary>
            This class implements the Clear-EventLog command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearEventLogCommand.LogName">
            <summary>
            Clear these logs.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ClearEventLogCommand.ComputerName">
            <summary>
            Clear eventlog entries from these Computers.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ClearEventLogCommand.BeginProcessing">
            <summary>
            Does the processing
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WriteEventLogCommand">
            <summary>
            This class implements the Write-EventLog command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteEventLogCommand.LogName">
            <summary>
            Write eventlog entries in this log
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteEventLogCommand.Source">
            <summary>
            The source by which the application is registered on the specified computer.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteEventLogCommand.EntryType">
            <summary>
            String which represents One of the EventLogEntryType values. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteEventLogCommand.Category">
            <summary>
            The application-specific subcategory associated with the message. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteEventLogCommand.EventId">
            <summary>
            The application-specific identifier for the event.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteEventLogCommand.Message">
            <summary>
            The message goes here.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteEventLogCommand.RawData">
            <summary>
            Write eventlog entries of this log
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WriteEventLogCommand.ComputerName">
            <summary>
            Write eventlog entries of this log
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WriteEventLogCommand.BeginProcessing">
            <summary>
            Does the processing
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.LimitEventLogCommand">
            <summary>
            This class implements the Limit-EventLog command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.LimitEventLogCommand.LogName">
            <summary>
            Limit the properties of this log.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.LimitEventLogCommand.ComputerName">
            <summary>
            Limit eventlog entries of this computer.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.LimitEventLogCommand.RetentionDays">
            <summary>
            Minimum retention days for this log.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.LimitEventLogCommand.OverflowAction">
            <summary>
            Overflow action to be taken.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.LimitEventLogCommand.MaximumSize">
            <summary>
            Maximum size of this log.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.LimitEventLogCommand.BeginProcessing">
            <summary>
            Does the processing
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.ShowEventLogCommand">
            <summary>
            This class implements the Show-EventLog command
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.ShowEventLogCommand.ComputerName">
            <summary>
            show eventviewer of this computer.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.ShowEventLogCommand.BeginProcessing">
            <summary>
            Does the processing
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.NewEventLogCommand">
            <summary>
            This cmdlet creates the new event log .This cmdlet can also be used to 
            configure a new source for writing entries to an event log on the local 
            computer or a remote computer.
            You can create an event source for an existing event log or a new event log. 
            When you create a new source for a new event log, the system registers the 
            source for that log, but the log is not created until the first entry is 
            written to it.
            The operating system stores event logs as files. The associated file is 
            stored in the %SystemRoot%\System32\Config directory on the specified 
            computer. The file name is set by appending the first 8 characters of the 
            Log property with the ".evt" file name extension.
            You can register the event source with localized resource file(s) for your 
            event category and message strings. Your application can write event log 
            entries using resource identifiers, rather than specifying the actual 
            string. You can register a separate file for event categories, messages and 
            parameter insertion strings, or you can register the same resource file for 
            all three types of strings.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewEventLogCommand.CategoryResourceFile">
            <summary>
            The following is the definition of the input parameter "CategoryResourceFile".
            Specifies the path of the resource file that contains category strings for 
            the source
            Resource File is expected to be present in Local/Remote Machines
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewEventLogCommand.ComputerName">
            <summary>
            The following is the definition of the input parameter "ComputerName".
            Specify the Computer Name. The default is local computer
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewEventLogCommand.LogName">
            <summary>
            The following is the definition of the input parameter "LogName".
            Specifies the name of the log
            
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewEventLogCommand.MessageResourceFile">
            <summary>
            The following is the definition of the input parameter "MessageResourceFile".
            Specifies the path of the message resource file that contains message 
            formatting strings for the source
            Resource File is expected to be present in Local/Remote Machines
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewEventLogCommand.ParameterResourceFile">
            <summary>
            The following is the definition of the input parameter "ParameterResourceFile".
            Specifies the path of the resource file that contains message parameter 
            strings for the source
            Resource File is expected to be present in Local/Remote Machines
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewEventLogCommand.Source">
            <summary>
            The following is the definition of the input parameter "Source".
            Specifies the Source of the EventLog
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NewEventLogCommand.BeginProcessing">
            <summary>
            BeginProcessing method.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RemoveEventLogCommand">
            <summary>
            This cmdlet is used to delete the specified event log from the specified 
            computer. This can also be used to Clear the entries of the specified event 
            log and also to unregister the Source associated with the eventlog.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveEventLogCommand.ComputerName">
            <summary>
            The following is the definition of the input parameter "ComputerName".
            Specifies the Computer Name
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveEventLogCommand.LogName">
            <summary>
            The following is the definition of the input parameter "LogName".
            Specifies the Event Log Name
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveEventLogCommand.Source">
            <summary>
            The following is the definition of the input parameter "RemoveSource".
            Specifies either to remove the event log and and associated source or 
            source. alone.
            When this parameter is not specified, the cmdlet uses Delete Method which 
            clears the eventlog and also the source associated with it. 
            When this parameter value is true, then this cmdlet uses DeleteEventSource 
            Method to delete the Source alone.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RemoveEventLogCommand.BeginProcessing">
            <summary>
            BeginProcessing method.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetWmiObjectCommand">
            <summary>
            A command to get WMI Objects
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetWmiObjectCommand.Class">
            <summary>
            The WMI class to query
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetWmiObjectCommand.Recurse">
            <summary>
            To specify whether to get the results recursively
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetWmiObjectCommand.Property">
            <summary>
            The WMI properties to retrieve
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetWmiObjectCommand.Filter">
            <summary>
            The filter to be used in the search
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetWmiObjectCommand.Amended">
            <summary>
            If Amended qualifier to use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetWmiObjectCommand.DirectRead">
            <summary>
            If Enumerate Deep flag to use. When 'list' parameter is specified 'EnumerateDeep' parameter is ignored.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetWmiObjectCommand.List">
            <summary>
            The list of classes
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetWmiObjectCommand.Query">
            <summary>
            The query string to search for objects
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetWmiObjectCommand.GetQueryString">
            <summary>
            Uses this.filter, this.wmiClass and this.property to retrieve the filter
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetWmiObjectCommand.GetFilterClassName">
            <summary>
            Uses filter table to convert the class into WMI understandable language.
                       Character   Description Example Match   Comment
                        *   Matches zero or more characters starting at the specified position  A*  A,ag,Apple  Supported by PowerShell.
                         ?   Matches any character at the specified position ?n  An,in,on (does not match ran)   Supported by PowerShell.
                         _   Matches any character at the specified position    _n  An,in,on (does not match ran)   Supperted by WMI
                        %   Matches zero or more characters starting at the specified position   A%  A,ag,Apple  Supperted by WMI
                        []  Matches a range of characters  [a-l]ook    Book,cook,look (does not match took)    Supported by WMI and powershell
                         []  Matches specified characters   [bc]ook Book,cook, (does not match look)    Supported by WMI and powershell
                         ^   Does not Match specified characters. [^bc]ook    Look, took (does not match book, cook)  Supported by WMI.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetWmiObjectCommand.GetObjectList(System.Management.ManagementScope)">
            <summary>
            Gets the ManagementObjectSearcher object
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetWmiObjectCommand.BeginProcessing">
            <summary>
            Gets the properties of an item at the specified path
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetWmiObjectCommand.GetClassNameFromQuery(System.String)">
            <summary>
            Get the class name from a query string
            </summary>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.InvokeWmiMethod">
            <summary>
            A command to Invoke WMI Method
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.InvokeWmiMethod.InputObject">
            <summary>
            The WMI Object to use
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.InvokeWmiMethod.Path">
            <summary>
            The WMI Path to use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.InvokeWmiMethod.Class">
            <summary>
            The WMI class to use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.InvokeWmiMethod.Name">
            <summary>
            The WMI Method to execute
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.InvokeWmiMethod.ArgumentList">
            <summary>
            The parameters to the method specified by MethodName
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.InvokeWmiMethod.ProcessRecord">
            <summary>
            Invoke WMI method given either path,class name or pipeline input.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.InvokeWmiMethod.MakeBaseObjectArray(System.Object)">
            <summary>
            Ensure that the argument is a collection containing no PSObjects.
            </summary>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RemoveWmiObject">
            <summary>
            A command to Remove WMI Object
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveWmiObject.InputObject">
            <summary>
            The WMI Object to use
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveWmiObject.Path">
            <summary>
            The WMI Path to use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RemoveWmiObject.Class">
            <summary>
            The WMI class to use
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RemoveWmiObject.ProcessRecord">
            <summary>
            Remove an object given either path,class name or pipeline input.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.RegisterWmiEventCommand">
            <summary>
            Registers for an event on an object.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RegisterWmiEventCommand.Namespace">
            <summary>
            The WMI namespace to use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RegisterWmiEventCommand.Credential">
            <summary>
            The credential to use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RegisterWmiEventCommand.ComputerName">
            <summary>
            The ComputerName in which to query
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RegisterWmiEventCommand.Class">
            <summary>
            The WMI class to use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RegisterWmiEventCommand.Query">
            <summary>
            The query string to search for objects
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.RegisterWmiEventCommand.Timeout">
            <summary>
            Timeout in milliseconds
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RegisterWmiEventCommand.GetSourceObject">
            <summary>
            Returns the object that generates events to be monitored
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RegisterWmiEventCommand.GetSourceObjectEventName">
            <summary>
            Returns the event name to be monitored on the input object
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.RegisterWmiEventCommand.EndProcessing">
            <summary>
            Processes the event subscriber after the base class has registered.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.SetWmiInstance">
            <summary>
            A command to Set WMI Instance
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetWmiInstance.InputObject">
            <summary>
            The WMI Object to use
            </summary>
            
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetWmiInstance.Path">
            <summary>
            The WMI Path to use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetWmiInstance.Class">
            <summary>
            The WMI class to use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetWmiInstance.Arguments">
            <summary>
            The property name /value pair
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.SetWmiInstance.PutType">
            <summary>
            The Flag to use
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.SetWmiInstance.ProcessRecord">
            <summary>
            Create or modify WMI Instance given either path,class name or pipeline input.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetTransactionCommand">
            <summary>
            A command that gets the active transaction.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetTransactionCommand.EndProcessing">
            <summary>
            Creates a new transaction.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.StartTransactionCommand">
            <summary>
            A command that begins a transaction.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StartTransactionCommand.Timeout">
            <summary>
            The time, in minutes, before this transaction is rolled back
            automatically.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StartTransactionCommand.Independent">
            <summary>
            Gets or sets the flag to determine if this transaction can
            be committed or rolled back independently of other transactions.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.StartTransactionCommand.RollbackPreference">
            <summary>
            Gets or sets the rollback preference for this transaction.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.StartTransactionCommand.EndProcessing">
            <summary>
            Creates a new transaction.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.CompleteTransactionCommand">
            <summary>
            A command that commits a transaction.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.CompleteTransactionCommand.EndProcessing">
            <summary>
            Commits the current transaction
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.UndoTransactionCommand">
            <summary>
            A command that rolls back a transaction.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.UndoTransactionCommand.EndProcessing">
            <summary>
            Rolls the current transaction back.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.UseTransactionCommand">
            <summary>
            A command that commits a transaction.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.UseTransactionCommand.TransactedScript">
            <summary>
            This parameter specifies the script block to run in the current
            PowerShell transaction
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.UseTransactionCommand.EndProcessing">
            <summary>
            Commits the current transaction
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.AsyncCmdletHelper">
            <summary>
            Base class for all WMI helper classes. This is an abstract class
            and the helpers need to derive from this
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.AsyncCmdletHelper.InternalException">
            <summary>
            Exception raised internally when any method of this class
            is executed
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WmiAsyncCmdletHelper">
            <summary>
            This class is responsible for creating WMI connection for getting objects and notifications
            from WMI asynchronously. This spawns a new thread to connect to WMI on remote machine.
            This allows the main thread to return faster and not blocked on network hops.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WmiAsyncCmdletHelper.#ctor(Microsoft.PowerShell.Commands.PSWmiChildJob,System.Management.Automation.Cmdlet,System.String,System.Management.ManagementOperationObserver)">
            <summary>
            Internal Constructor
            </summary>
            <param name="childJob">Job associated with this operation</param>
            <param name="wmiObject">object associated with this operation</param>
            <param name="computerName"> computer on which the operation is invoked </param>
            <param name="results"> sink to get wmi objects </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WmiAsyncCmdletHelper.#ctor(Microsoft.PowerShell.Commands.PSWmiChildJob,System.Management.Automation.Cmdlet,System.String,System.Management.ManagementOperationObserver,System.Int32)">
            <summary>
            Internal Constructor.  This variant takes a count parameter that determines how many times 
            the WMI command is executed.
            </summary>
            <param name="childJob">Job associated with this operation</param>
            <param name="wmiObject">Object associated with this operation</param>
            <param name="computerName">Computer on which the operation is invoked</param>
            <param name="results">Sink to return wmi objects</param>
            <param name="count">Number of times the WMI command is executed</param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WmiAsyncCmdletHelper.State">
            <summary>
            current operation state
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WmiAsyncCmdletHelper.StopOperation">
            <summary>
            Cancel WMI connection
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WmiAsyncCmdletHelper.GetWmiQueryString">
            <summary>
            Uses this.filter, this.wmiClass and this.property to retrieve the filter
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WmiAsyncCmdletHelper.StartOperation">
            <summary>
            Do WMI connection by creating another thread based on type of request and return immediately.
            </summary>
        </member>
        <member name="E:Microsoft.PowerShell.Commands.WmiAsyncCmdletHelper.OperationComplete">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WmiAsyncCmdletHelper.RaiseOperationCompleteEvent(System.EventArgs,System.Management.Automation.Remoting.OperationState)">
            <summary>
            Raise operation completion event
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WmiAsyncCmdletHelper.RaiseWmiOperationState(System.EventArgs,Microsoft.PowerShell.Commands.WmiState)">
            <summary>
             Raise WMI state changed event
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WmiAsyncCmdletHelper.ConnectSetWmi">
            <summary>
            Do the actual connection to remote machine for Set-WMIInstance cmdlet and raise operation complete event.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WmiAsyncCmdletHelper.ConnectInvokeWmi">
            <summary>
            Do the actual connection to remote machine for Invokd-WMIMethod cmdlet and raise operation complete event.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WmiAsyncCmdletHelper.NeedToEnablePrivilege(System.String,System.String,System.Boolean@)">
            <summary>
            Check if we need to enable the shutdown privilege
            </summary>
            <param name="computer"></param>
            <param name="methodName"></param>
            <param name="isLocal"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WmiAsyncCmdletHelper.ConnectRemoveWmi">
            <summary>
            Do the actual connection to remote machine for Remove-WMIObject cmdlet and raise operation complete event.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WmiAsyncCmdletHelper.ConnectGetWMI">
            <summary>
            Do the actual connection to remote machine for Get-WMIObject cmdlet and raise operation complete event.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WmiJobStateEventArgs">
            <summary>
             Event which will be triggered when WMI state is changed.
             Currently it is to notify Jobs that state has changed to running.
             Other states are notified via OperationComplete.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WmiJobStateEventArgs.WmiState">
            <summary>
             WMI state
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WmiState">
            <summary>
            Enumerated type defining the state of the WMI operation
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WmiState.NotStarted">
            <summary>
            The operation has not been started
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WmiState.Running">
            <summary>
            The operation is executing
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WmiState.Stopping">
            <summary>
            The operation is stoping execution.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WmiState.Stopped">
            <summary>
            The operation is completed due to a stop request.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WmiState.Completed">
            <summary>
            The operation has completed.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WmiState.Failed">
            <summary>
            The operation completed abnormally due to an error.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.WmiBaseCmdlet">
            <summary>
            A class to set WMI connection options
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WmiBaseCmdlet.AsJob">
            <summary>
            Perform Async operation
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WmiBaseCmdlet.Impersonation">
            <summary>
            The Impersonation level to use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WmiBaseCmdlet.Authentication">
            <summary>
            The Authentication level to use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WmiBaseCmdlet.Locale">
            <summary>
            The Locale to use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WmiBaseCmdlet.EnableAllPrivileges">
            <summary>
            If all Privileges are enabled
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WmiBaseCmdlet.Authority">
            <summary>
            The Authority to use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WmiBaseCmdlet.Credential">
            <summary>
            The credential to use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WmiBaseCmdlet.ThrottleLimit">
            <summary>
            The credential to use
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WmiBaseCmdlet.ComputerName">
            <summary>
            The ComputerName in which to query
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.WmiBaseCmdlet.Namespace">
            <summary>
            The WMI namespace to use
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WmiBaseCmdlet.computerName">
            <summary>
            The computer to query.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WmiBaseCmdlet.nameSpace">
            <summary>
            WMI namespace
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WmiBaseCmdlet.namespaceSpecified">
            <summary>
            Specify if namespace was specified or not.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WmiBaseCmdlet.serverNameSpecified">
            <summary>
            Specify if server name was specified or not.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WmiBaseCmdlet.credential">
            <summary>
            The credential to use
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WmiBaseCmdlet.impersonationLevel">
            <summary>
            The Impersonation level to use
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WmiBaseCmdlet.authenticationLevel">
            <summary>
            The Authentication level to use
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WmiBaseCmdlet.locale">
            <summary>
            The Locale to use
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WmiBaseCmdlet.enableAllPrivileges">
            <summary>
            If all Privileges are enabled
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WmiBaseCmdlet.authority">
            <summary>
            The Authority to use
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WmiBaseCmdlet.async">
            <summary>
            To perform async operation
            </summary>        
        </member>
        <member name="F:Microsoft.PowerShell.Commands.WmiBaseCmdlet.throttleLimit">
            <summary>
            Set throttle limit
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WmiBaseCmdlet.GetConnectionOption">
            <summary>
            Get connection options
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WmiBaseCmdlet.SetWmiInstanceGetObject(System.Management.ManagementPath,System.String)">
            <summary>
            Set wmi instance helper
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WmiBaseCmdlet.SetWmiInstanceBuildManagementPath">
            <summary>
            Set wmi instance helper for building management path
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WmiBaseCmdlet.SetWmiInstanceGetPipelineObject">
            <summary>
            Set wmi instance helper for pipeline input
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.WmiBaseCmdlet.RunAsJob(System.String)">
            <summary>
            Start this cmdlet as a WMI job...
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.PSWmiJob">
            <summary>
            A class to perform async operations for WMI cmdlets
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSWmiJob.#ctor(System.Management.Automation.Cmdlet,System.String[],System.Int32,System.String)">
             <summary>
            Internal constructor for initializing WMI jobs
             </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSWmiJob.#ctor(System.Management.Automation.Cmdlet,System.String[],System.Int32,System.String,System.Int32)">
            <summary>
            Internal constructor for initializing WMI jobs, where WMI command is executed a variable
            number of times.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSWmiJob.HandleChildJobStateChanged(System.Object,System.Management.Automation.JobStateEventArgs)">
            <summary>
            Handles the StateChanged event from each of the child job objects
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PSWmiJob.StatusMessage">
            <summary>
            Message indicating status of the job
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSWmiJob.SetStatusMessage">
            <summary>
            Checks the status of remote command execution
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PSWmiJob.HasMoreData">
            <summary>
            indicates if more data is available
            </summary>
            <remarks>
            This has more data if any of the child jobs have more data.
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PSWmiJob.Location">
            <summary>
            Computers on which this job is running
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSWmiJob.StopJob">
            <summary>
            Stop Job 
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSWmiJob.Dispose(System.Boolean)">
            <summary>
            Release all the resources. 
            </summary>
            <param name="disposing">
            if true, release all the managed objects.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSWmiJob.CommonInit(System.Int32)">
            <summary>
            Initialization common to both constructors
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSWmiJob.HandleJobUnblocked(System.Object,System.EventArgs)">
            <summary>
            Handles JobUnblocked event from a child job and decrements
            count of blocked child jobs. When count reaches 0, sets the
            state of the parent job to running
            </summary>
            <param name="sender">sender of this event, unused</param>
            <param name="eventArgs">event arguments, should be empty in this
            case</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.PSWmiChildJob">
            <summary>
            Class for WmiChildJob object. This job object Execute wmi cmdlet
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSWmiChildJob.#ctor(System.Management.Automation.Cmdlet,System.String,System.Management.Automation.Remoting.ThrottleManager)">
            <summary>
            Internal constructor for initializing WMI jobs
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSWmiChildJob.#ctor(System.Management.Automation.Cmdlet,System.String,System.Management.Automation.Remoting.ThrottleManager,System.Int32)">
            <summary>
            Internal constructor for initializing WMI jobs, where WMI command is executed a variable
            number of times.
            </summary>
        </member>
        <member name="E:Microsoft.PowerShell.Commands.PSWmiChildJob.JobUnblocked">
            <summary>
            Event raised by this job to indicate to its parent that
            its now unblocked by the user
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSWmiChildJob.UnblockJob">
            <summary>
            Set the state of the current job from blocked to
            running and raise an event indicating to this
            parent job that this job is unblocked
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSWmiChildJob.NewObject(System.Object,System.Management.ObjectReadyEventArgs)">
            <summary>
            it recieves Management objects
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSWmiChildJob.JobDone(System.Object,System.Management.CompletedEventArgs)">
            <summary>
            It is called when WMI job is done.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSWmiChildJob.JobDoneForWin32Shutdown(System.Object,System.EventArgs)">
            <summary>
            It is called when the call to Win32shutdown is successfully completed
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PSWmiChildJob.StatusMessage">
            <summary>
            Message indicating status of the job
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PSWmiChildJob.HasMoreData">
            <summary>
            Indicates if there is more data available in
            this Job
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.PSWmiChildJob.Location">
            <summary>
            Returns the computer on which this command is
            running
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSWmiChildJob.StopJob">
            <summary>
            Stops the job
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSWmiChildJob.Dispose(System.Boolean)">
            <summary>
            Release all the resources. 
            </summary>
            <param name="disposing">
            if true, release all the managed objects.
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSWmiChildJob.HandleOperationComplete(System.Object,System.Management.Automation.Remoting.OperationStateEventArgs)">
            <summary>
            Handles operation complete event
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSWmiChildJob.HandleWMIState(System.Object,Microsoft.PowerShell.Commands.WmiJobStateEventArgs)">
            <summary>
            Handles WMI state changed
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.PSWmiChildJob.HandleThrottleComplete(System.Object,System.EventArgs)">
            <summary>
            Handle a throttle complete event
            </summary>
            <param name="sender">sender of this event</param>
            <param name="eventArgs">not used in this method</param>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.NewWebServiceProxy">
            <summary>
            Cmdlet for new-WebService Proxy
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewWebServiceProxy.Uri">
            <summary>
            URI of the web service
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewWebServiceProxy.Class">
            <summary>
            Parameter Class name
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewWebServiceProxy.Namespace">
            <summary>
            namespace
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewWebServiceProxy.Credential">
            <summary>
            Credential
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.NewWebServiceProxy.UseDefaultCredential">
            <summary>
            use default credential..
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NewWebServiceProxy.UriCache">
            <summary>
            Cache for storing URIs.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NewWebServiceProxy.srccodeCache">
            <summary>
            Cache for storing sourcecodehashes.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NewWebServiceProxy.sourceHash">
            <summary>
            holds the hash code of the source generated.
            </summary>
        </member>
        <member name="F:Microsoft.PowerShell.Commands.NewWebServiceProxy.cachelock">
            <summary>
            Random class
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NewWebServiceProxy.BeginProcessing">
            <summary>
            BeginProcessing code
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NewWebServiceProxy.GenerateRandomName">
            <summary>
            Generates a random name
            </summary>
            <returns>string </returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NewWebServiceProxy.GenerateWebServiceProxyAssembly(System.String,System.String)">
            <summary>
            Generates the Assembly
            </summary>
            <param name="NameSpace"></param>
            <param name="ClassName"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NewWebServiceProxy.GetReferencedAssemblies(System.Reflection.Assembly,System.CodeDom.Compiler.CompilerParameters)">
            <summary>
            Function to add all the assemblies required to generate the web proxy
            </summary>
            <param name="assembly"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.NewWebServiceProxy.InstantinateWebServiceProxy(System.Reflection.Assembly)">
            <summary>
            Instantiates the object
             if a type of WebServiceBindingAttribute is not found, throw an exception
            </summary>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.PowerShell.Commands.GetHotFixCommand">
            <summary>
            Cmdlet for Get-Hotfix Proxy
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetHotFixCommand.Id">
            <summary>
            Specifies the HotFixID. Unique identifier associated with a particular update.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetHotFixCommand.Description">
            <summary>
            To search on description of Hotfixes
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetHotFixCommand.ComputerName">
            <summary>
            Parameter to pass the Computer Name
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Commands.GetHotFixCommand.Credential">
            <summary>
            Parameter to pass the Credentials.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetHotFixCommand.BeginProcessing">
            <summary>
            Get the List of HotFixes installed on the Local Machine.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetHotFixCommand.StopProcessing">
            <summary>
            to implement ^C
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetHotFixCommand.Dispose">
            <summary>
            Dispose Method
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Commands.GetHotFixCommand.Dispose(System.Boolean)">
            <summary>
            Dispose Method.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:Microsoft.PowerShell.PSManagementPSSnapIn">
            <summary>
            
            MshManagementMshSnapin (or MshManagementMshSnapinInstaller) is a class for facilitating registry 
            of necessary information for monad management mshsnapin. 
            
            This class will be built with monad management dll 
            
            </summary>
            
        </member>
        <member name="M:Microsoft.PowerShell.PSManagementPSSnapIn.#ctor">
            <summary>
            Create an instance of this class. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.PSManagementPSSnapIn.Name">
            <summary>
            Get name of this mshsnapin.
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.PSManagementPSSnapIn.Vendor">
            <summary>
            Get the default vendor string for this mshsnapin. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.PSManagementPSSnapIn.VendorResource">
            <summary>
            Get resource information for vendor. This is a string of format: resourceBaseName,resourceName. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.PSManagementPSSnapIn.Description">
            <summary>
            Get the default description string for this mshsnapin. 
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.PSManagementPSSnapIn.DescriptionResource">
            <summary>
            Get resource information for description. This is a string of format: resourceBaseName,resourceName. 
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Cmdletization.SessionBasedCmdletAdapter`2">
            <summary>
            Provides common code for processing session-based object models.  The common code
            Session, ThrottleLimit, AsJob parameters and delegates creation of jobs to derived classes.
            </summary>
            <typeparam name="TObjectInstance">Type that represents instances of objects from the wrapped object model</typeparam>
            <typeparam name="TSession">Type representing remote sessions</typeparam>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.SessionBasedCmdletAdapter`2.Dispose">
            <summary>
            Releases resources associated with this object
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.SessionBasedCmdletAdapter`2.Dispose(System.Boolean)">
            <summary>
            Releases resources associated with this object
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Cmdletization.SessionBasedCmdletAdapter`2.Session">
            <summary>
            Session to operate on
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Cmdletization.SessionBasedCmdletAdapter`2.AsJob">
            <summary>
            Whether to wrap and emit the whole operation as a background job
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Cmdletization.SessionBasedCmdletAdapter`2.ThrottleLimit">
            <summary>
            Maximum number of remote connections that can remain active at any given time.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.SessionBasedCmdletAdapter`2.CreateQueryJob(`1,Microsoft.PowerShell.Cmdletization.QueryBuilder)">
            <summary>
            Creates a <see cref="T:System.Management.Automation.Job"/> object that performs a query against the wrapped object model.
            </summary>
            <param name="session">Remote session to query</param>
            <param name="query">Query parameters</param>
            <remarks>
            <para>
            This method shouldn't do any processing or interact with the remote session.
            Doing so will interfere with ThrottleLimit functionality.
            </para>
            <para>
            <see cref="M:System.Management.Automation.Job.WriteObject(System.Object)" /> (and other methods returning job results) will block to support throttling and flow-control.
            Implementations of Job instance returned from this method should make sure that implementation-specific flow-control mechanism pauses further procesing,
            until calls from <see cref="M:System.Management.Automation.Job.WriteObject(System.Object)" /> (and other methods returning job results) return.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.SessionBasedCmdletAdapter`2.CreateInstanceMethodInvocationJob(`1,`0,Microsoft.PowerShell.Cmdletization.MethodInvocationInfo,System.Boolean)">
            <summary>
            Creates a <see cref="T:System.Management.Automation.Job"/> object that invokes an instance method in the wrapped object model.
            </summary>
            <param name="session">Remote session to invoke the method in</param>
            <param name="objectInstance">The object on which to invoke the method</param>
            <param name="methodInvocationInfo">Method invocation details</param>
            <param name="passThru"><c>true</c> if successful method invocations should emit downstream the <paramref name="objectInstance"/> being operated on</param>
            <remarks>
            <para>
            This method shouldn't do any processing or interact with the remote session.
            Doing so will interfere with ThrottleLimit functionality.
            </para>
            <para>
            <see cref="M:System.Management.Automation.Job.WriteObject(System.Object)" /> (and other methods returning job results) will block to support throttling and flow-control.
            Implementations of Job instance returned from this method should make sure that implementation-specific flow-control mechanism pauses further procesing,
            until calls from <see cref="M:System.Management.Automation.Job.WriteObject(System.Object)" /> (and other methods returning job results) return.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.SessionBasedCmdletAdapter`2.CreateStaticMethodInvocationJob(`1,Microsoft.PowerShell.Cmdletization.MethodInvocationInfo)">
            <summary>
            Creates a <see cref="T:System.Management.Automation.Job"/> object that invokes a static method in the wrapped object model.
            </summary>
            <param name="session">Remote session to invoke the method in</param>
            <param name="methodInvocationInfo">Method invocation details</param>
            <remarks>
            <para>
            This method shouldn't do any processing or interact with the remote session.
            Doing so will interfere with ThrottleLimit functionality.
            </para>
            <para>
            <see cref="M:System.Management.Automation.Job.WriteObject(System.Object)" /> (and other methods returning job results) will block to support throttling and flow-control.
            Implementations of Job instance returned from this method should make sure that implementation-specific flow-control mechanism pauses further procesing,
            until calls from <see cref="M:System.Management.Automation.Job.WriteObject(System.Object)" /> (and other methods returning job results) return.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.PowerShell.Cmdletization.SessionBasedCmdletAdapter`2.DefaultSession">
            <summary>
            Returns default sessions to use when the user doesn't specify the -Session cmdlet parameter.
            </summary>
            <returns>Default sessions to use when the user doesn't specify the -Session cmdlet parameter</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.SessionBasedCmdletAdapter`2.GenerateParentJobName">
            <summary>
            A new job name to use for the parent job that handles throttling of the child jobs that actually perform querying and method invocation.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.SessionBasedCmdletAdapter`2.ProcessRecord(Microsoft.PowerShell.Cmdletization.QueryBuilder)">
            <summary>
            Queries for object instances in the object model.
            </summary>
            <param name="query">Query parameters</param>
            <returns>A lazy evaluated collection of object instances</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.SessionBasedCmdletAdapter`2.ProcessRecord(Microsoft.PowerShell.Cmdletization.QueryBuilder,Microsoft.PowerShell.Cmdletization.MethodInvocationInfo,System.Boolean)">
            <summary>
            Queries for instance and invokes an instance method
            </summary>
            <param name="query">Query parameters</param>
            <param name="methodInvocationInfo">Method invocation details</param>
            <param name="passThru"><c>true</c> if successful method invocations should emit downstream the object instance being operated on</param>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.SessionBasedCmdletAdapter`2.ProcessRecord(`0,Microsoft.PowerShell.Cmdletization.MethodInvocationInfo,System.Boolean)">
            <summary>
            Invokes an instance method in the object model.
            </summary>
            <param name="objectInstance">The object on which to invoke the method</param>
            <param name="methodInvocationInfo">Method invocation details</param>
            <param name="passThru"><c>true</c> if successful method invocations should emit downstream the <paramref name="objectInstance"/> being operated on</param>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.SessionBasedCmdletAdapter`2.ProcessRecord(Microsoft.PowerShell.Cmdletization.MethodInvocationInfo)">
            <summary>
            Invokes a static method in the object model.
            </summary>
            <param name="methodInvocationInfo">Method invocation details</param>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.SessionBasedCmdletAdapter`2.BeginProcessing">
            <summary>
            Performs initialization of cmdlet execution.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.SessionBasedCmdletAdapter`2.EndProcessing">
            <summary>
            Performs cleanup after cmdlet execution.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.SessionBasedCmdletAdapter`2.StopProcessing">
            <summary>
            Stops the parent job when called.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Cmdletization.Cim.CimCmdletAdapter">
            <summary>
            CIM-specific ObjectModelWrapper
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Cmdletization.Cim.CimCmdletAdapter.CimSession">
            <summary>
            CimSession to operate on
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Cmdletization.Cim.CimCmdletAdapter.ThrottleLimit">
            <summary>
            Maximum number of remote connections that can remain active at any given time.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.Cim.CimCmdletAdapter.GetQueryBuilder">
            <summary>
            Creates a query builder for CIM OM
            </summary>
            <returns>Query builder for CIM OM</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.Cim.CimCmdletAdapter.GenerateParentJobName">
            <summary>
            Returns a new job name to use for the parent job that handles throttling of the child jobs that actually perform querying and method invocation.
            </summary>
            <returns>Job name</returns>
        </member>
        <member name="P:Microsoft.PowerShell.Cmdletization.Cim.CimCmdletAdapter.DefaultSession">
            <summary>
            Returns default sessions to use when the user doesn't specify the -Session cmdlet parameter.
            </summary>
            <returns>Default sessions to use when the user doesn't specify the -Session cmdlet parameter</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.Cim.CimCmdletAdapter.CreateQueryJob(Microsoft.Management.Infrastructure.CimSession,Microsoft.PowerShell.Cmdletization.QueryBuilder)">
            <summary>
            Creates a <see cref="T:System.Management.Automation.Job"/> object that performs a query against the wrapped object model.
            </summary>
            <param name="session">Remote session to query</param>
            <param name="baseQuery">Query parameters</param>
            <returns><see cref="T:System.Management.Automation.Job"/> object that performs a query against the wrapped object model</returns>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.Cim.CimCmdletAdapter.CreateInstanceMethodInvocationJob(Microsoft.Management.Infrastructure.CimSession,Microsoft.Management.Infrastructure.CimInstance,Microsoft.PowerShell.Cmdletization.MethodInvocationInfo,System.Boolean)">
            <summary>
            Creates a <see cref="T:System.Management.Automation.Job"/> object that invokes an instance method in the wrapped object model.
            </summary>
            <param name="session">Remote session to invoke the method in</param>
            <param name="objectInstance">The object on which to invoke the method</param>
            <param name="methodInvocationInfo">Method invocation details</param>
            <param name="passThru"><c>true</c> if successful method invocations should emit downstream the <paramref name="objectInstance"/> being operated on</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.Cim.CimCmdletAdapter.CreateStaticMethodInvocationJob(Microsoft.Management.Infrastructure.CimSession,Microsoft.PowerShell.Cmdletization.MethodInvocationInfo)">
            <summary>
            Creates a <see cref="T:System.Management.Automation.Job"/> object that invokes a static method 
            (of the class named by <see cref="P:Microsoft.PowerShell.Cmdletization.CmdletAdapter`1.ClassName"/>) 
            in the wrapped object model.
            </summary>
            <param name="session">Remote session to invoke the method in</param>
            <param name="methodInvocationInfo">Method invocation details</param>
        </member>
        <member name="T:Microsoft.PowerShell.Cmdletization.Cim.CimQuery">
            <summary>
            CimQuery supports building of queries against CIM object model
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.Cim.CimQuery.FilterByProperty(System.String,System.Collections.IEnumerable,System.Boolean,Microsoft.PowerShell.Cmdletization.BehaviorOnNoMatch)">
            <summary>
            Modifies the query, so that it only returns objects with a given property value
            </summary>
            <param name="propertyName">Property name to query on</param>
            <param name="allowedPropertyValues">Property values to accept in the query</param>
            <param name="wildcardsEnabled">
              <c>true</c> if <paramref name="allowedPropertyValues"/> should be treated as a <see cref="T:System.String"/> containing a wildcard pattern; 
              <c>false otherwise</c>
            </param>
            <param name="behaviorOnNoMatch">
            Describes how to handle filters that didn't match any objects
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.Cim.CimQuery.ExcludeByProperty(System.String,System.Collections.IEnumerable,System.Boolean,Microsoft.PowerShell.Cmdletization.BehaviorOnNoMatch)">
            <summary>
            Modifies the query, so that it does not return objects with a given property value
            </summary>
            <param name="propertyName">Property name to query on</param>
            <param name="excludedPropertyValues">Property values to reject in the query</param>
            <param name="wildcardsEnabled">
            <c>true</c> if <paramref name="excludedPropertyValues"/> should be treated as a <see cref="T:System.String"/> containing a wildcard pattern; 
            <c>false otherwise</c>
            </param>
            <param name="behaviorOnNoMatch">
            Describes how to handle filters that didn't match any objects
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.Cim.CimQuery.FilterByMinPropertyValue(System.String,System.Object,Microsoft.PowerShell.Cmdletization.BehaviorOnNoMatch)">
            <summary>
            Modifies the query, so that it returns only objects that have a property value greater than or equal to a <paramref name="minPropertyValue"/> threshold
            </summary>
            <param name="propertyName">Property name to query on</param>
            <param name="minPropertyValue">Minimum property value</param>
            <param name="behaviorOnNoMatch">
            Describes how to handle filters that didn't match any objects
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.Cim.CimQuery.FilterByMaxPropertyValue(System.String,System.Object,Microsoft.PowerShell.Cmdletization.BehaviorOnNoMatch)">
            <summary>
            Modifies the query, so that it returns only objects that have a property value less than or equal to a <paramref name="maxPropertyValue"/> threshold
            </summary>
            <param name="propertyName">Property name to query on</param>
            <param name="maxPropertyValue">Maximum property value</param>
            <param name="behaviorOnNoMatch">
            Describes how to handle filters that didn't match any objects
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.Cim.CimQuery.FilterByAssociatedInstance(System.Object,System.String,System.String,System.String,Microsoft.PowerShell.Cmdletization.BehaviorOnNoMatch)">
            <summary>
            Modifies the query, so that it returns only objects associated with <paramref name="associatedInstance"/>
            </summary>
            <param name="associatedInstance">object that query results have to be associated with</param>
            <param name="associationName">name of the association</param>
            <param name="resultRole">name of the role that <paramref name="associatedInstance"/> has in the association</param>
            <param name="sourceRole">name of the role that query results have in the association</param>
            <param name="behaviorOnNoMatch">
            Describes how to handle filters that didn't match any objects
            </param>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.Cim.CimQuery.AddQueryOption(System.String,System.Object)">
            <summary>
            Sets a query option
            </summary>
            <param name="optionName"></param>
            <param name="optionValue"></param>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.Cim.CimQuery.ToString">
            <summary>
            Returns a string that represents the current CIM query
            </summary>
            <returns>A string that represents the current CIM query</returns>
        </member>
        <member name="T:Microsoft.PowerShell.Cmdletization.Cim.ClientSideQuery">
            <summary>
            Client-side filtering for 
            1) filtering that cannot be translated into a server-side query (i.e. when CimQuery.WildcardToWqlLikeOperand reports that it cannot translate into WQL)
            2) detecting if all expected results have been received and giving friendly user errors otherwise (i.e. could not find process with name='foo';  details in Windows 8 Bugs: #60926)
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Cmdletization.Cim.CimJobException">
            <summary>
            Represents an error during execution of a CIM job
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.Cim.CimJobException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Cmdletization.Cim.CimJobException"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.Cim.CimJobException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Cmdletization.Cim.CimJobException"/> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.Cim.CimJobException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Cmdletization.Cim.CimJobException"/> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="inner">The exception that is the cause of the current exception, or a null reference if no inner exception is specified.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.Cim.CimJobException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.PowerShell.Cmdletization.Cim.CimJobException"/> class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.Cim.CimJobException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the SerializationInfo with information about the exception.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:Microsoft.PowerShell.Cmdletization.Cim.CimJobException.ErrorRecord">
            <summary>
            <see cref="P:Microsoft.PowerShell.Cmdletization.Cim.CimJobException.ErrorRecord"/> which provides additional information about the error.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Cmdletization.Cim.CimChildJobBase`1">
            <summary>
            Base class for all child jobs that wrap CIM operations
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Cmdletization.Cim.CimChildJobBase`1.Location">
            <summary>
            Indicates a location where this job is running
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Cmdletization.Cim.CimChildJobBase`1.StatusMessage">
            <summary>
            Status message associated with the Job
            </summary>
        </member>
        <member name="P:Microsoft.PowerShell.Cmdletization.Cim.CimChildJobBase`1.HasMoreData">
            <summary>
            Indicates if job has more data available.
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Cmdletization.Cim.CimChildJobBase`1.StopJob">
            <summary>
            Stops this job.
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Cmdletization.Cim.QueryJobBase">
            <summary>
            Base job for queries
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Cmdletization.Cim.QueryInstancesJob">
            <summary>
            Job that handles executing a WQL (in the future CQL?) query on a remote CIM server
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Cmdletization.Cim.EnumerateAssociatedInstancesJob">
            <summary>
            Job that handles executing a WQL (in the future CQL?) query on a remote CIM server
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Cmdletization.Cim.MethodInvocationJobBase`1">
            <summary>
            Job wrapping invocation of an extrinsic CIM method
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Cmdletization.Cim.PropertySettingJob`1">
            <summary>
            Job wrapping invocation of a CreateInstance or ModifyInstance intrinsic CIM method
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Cmdletization.Cim.CreateInstanceJob">
            <summary>
            Job wrapping invocation of a CreateInstance intrinsic CIM method
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Cmdletization.Cim.ModifyInstanceJob">
            <summary>
            Job wrapping invocation of a ModifyInstance intrinsic CIM method
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Cmdletization.Cim.DeleteInstanceJob">
            <summary>
            Job wrapping invocation of a DeleteInstance intrinsic CIM method
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Cmdletization.Cim.ExtrinsicMethodInvocationJob">
            <summary>
            Job wrapping invocation of an extrinsic CIM method
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Cmdletization.Cim.InstanceMethodInvocationJob">
            <summary>
            Job wrapping invocation of an extrinsic CIM method
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Cmdletization.Cim.StaticMethodInvocationJob">
            <summary>
            Job wrapping invocation of a static CIM method
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Cmdletization.Cim.TerminatingErrorTracker">
            <summary>
            Tracks (per-session) terminating errors in a given cmdlet invocation
            </summary>
        </member>
        <member name="T:Microsoft.PowerShell.Cmdletization.Cim.CimOperationOptionsHelper">
            <summary>
            CimQuery supports building of queries against CIM object model
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Cim.CimSensitiveValueConverter.SensitiveString.Dispose">
            <summary>
            Releases resources associated with this object
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Cim.CimSensitiveValueConverter.SensitiveString.Dispose(System.Boolean)">
            <summary>
            Releases resources associated with this object
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Cim.CimSensitiveValueConverter.Dispose">
            <summary>
            Releases resources associated with this object
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Cim.CimSensitiveValueConverter.Dispose(System.Boolean)">
            <summary>
            Releases resources associated with this object
            </summary>
        </member>
        <member name="M:Microsoft.PowerShell.Cim.CimValueConverter.ConvertFromDotNetToCim(System.Object)">
            <exception cref="T:System.Management.Automation.PSInvalidCastException">The only kind of exception this method can throw</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Cim.CimValueConverter.ConvertFromCimToDotNet(System.Object,System.Type)">
            <exception cref="T:System.Management.Automation.PSInvalidCastException">The only kind of exception this method can throw</exception>
        </member>
        <member name="M:Microsoft.PowerShell.Cim.CimValueConverter.GetConvertibleCimType(System.Type)">
            <summary>
            Returns a type of CIM representation if conversion from/to CIM can be done purely with LanguagePrimitives.ConvertTo
            </summary>
            <param name="dotNetType"></param>
            <returns></returns>
        </member>
        <member name="M:Extensions.CIMExtensions.QueryInstances(Microsoft.Management.Infrastructure.CimSession,System.String,System.String)">
            <summary>
            An "overload" of the
            <see cref="T:Microsoft.Management.Infrastructure.CimSession"/>.QueryInstances
            method that takes only the namespace and query string as a parameters
            </summary>
            <param name="session">The CimSession to be queried</param>
            <param name="nameSpace">A string containing the namespace to run the query against</param>
            <param name="query">A string containing the query to be run</param>
            <returns>
            An IEnumerable interface that can be used to enumerate the instances
            </returns>
        </member>
        <member name="M:Extensions.CIMExtensions.QueryFirstInstance(Microsoft.Management.Infrastructure.CimSession,System.String,System.String)">
            <summary>
            Execute a CIM query and return only the first intance in the result.
            </summary>
            <param name="session">The CimSesson to be queried</param>
            <param name="nameSpace">A string containing the namespace to run the query against</param>
            <param name="query">A string containing the query to be run</param>
            <returns>
            A <see cref="T:Microsoft.Management.Infrastructure.CimInstance"/> object
            representing the first instance in a query result if successful, null
            otherwise.
            </returns>
        </member>
        <member name="M:Extensions.CIMExtensions.QueryFirstInstance(Microsoft.Management.Infrastructure.CimSession,System.String)">
            <summary>
            Execute a CIM query and return only the first intance in the result.
            </summary>
            <param name="session">The CimSesson to be queried</param>
            <param name="query">A string containing the query to be run</param>
            <returns>
            A <see cref="T:Microsoft.Management.Infrastructure.CimInstance"/> object
            representing the first instance in a query result if successful, null
            otherwise.
            </returns>
        </member>
        <member name="T:NavigationResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:NavigationResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:NavigationResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:NavigationResources.AddContentAction">
            <summary>
              Looks up a localized string similar to Add Content.
            </summary>
        </member>
        <member name="P:NavigationResources.AddContentTarget">
            <summary>
              Looks up a localized string similar to Path: {0}.
            </summary>
        </member>
        <member name="P:NavigationResources.CommitAction">
            <summary>
              Looks up a localized string similar to Commit.
            </summary>
        </member>
        <member name="P:NavigationResources.CopyToExistingPrompt">
            <summary>
              Looks up a localized string similar to Cannot copy because the specified destination already exists. Do you want to overwrite the existing content?.
            </summary>
        </member>
        <member name="P:NavigationResources.CreateAction">
            <summary>
              Looks up a localized string similar to Begin.
            </summary>
        </member>
        <member name="P:NavigationResources.DeleteHasChildrenPrompt">
            <summary>
              Looks up a localized string similar to The specified path is a container that has child items. Do you want to delete this container and its child items?.
            </summary>
        </member>
        <member name="P:NavigationResources.DeletePrompt">
            <summary>
              Looks up a localized string similar to Do you want to delete the specified item?.
            </summary>
        </member>
        <member name="P:NavigationResources.ItemNotFound">
            <summary>
              Looks up a localized string similar to An object at the specified path {0} does not exist, or has been filtered by the -Include or -Exclude parameter..
            </summary>
        </member>
        <member name="P:NavigationResources.MoveItemDoesntExist">
            <summary>
              Looks up a localized string similar to Cannot move item because the item at &apos;{0}&apos; does not exist..
            </summary>
        </member>
        <member name="P:NavigationResources.MoveItemInUse">
            <summary>
              Looks up a localized string similar to Cannot move item because the item at &apos;{0}&apos; is in use..
            </summary>
        </member>
        <member name="P:NavigationResources.NewDriveConfirmAction">
            <summary>
              Looks up a localized string similar to New drive.
            </summary>
        </member>
        <member name="P:NavigationResources.NewDriveConfirmResourceTemplate">
            <summary>
              Looks up a localized string similar to Name: {0} Provider: {1} Root: {2}.
            </summary>
        </member>
        <member name="P:NavigationResources.ParsePathFormatError">
            <summary>
              Looks up a localized string similar to Cannot parse path because path &apos;{0}&apos; does not have a qualifier specified..
            </summary>
        </member>
        <member name="P:NavigationResources.RemoveDriveConfirmAction">
            <summary>
              Looks up a localized string similar to Remove Drive.
            </summary>
        </member>
        <member name="P:NavigationResources.RemoveDriveConfirmResourceTemplate">
            <summary>
              Looks up a localized string similar to Name: {0} Provider: {1} Root: {2}.
            </summary>
        </member>
        <member name="P:NavigationResources.RemoveDriveInUse">
            <summary>
              Looks up a localized string similar to Cannot remove drive &apos;{0}&apos; because it is in use..
            </summary>
        </member>
        <member name="P:NavigationResources.RemoveItemInUse">
            <summary>
              Looks up a localized string similar to Cannot remove the item at &apos;{0}&apos; because it is in use..
            </summary>
        </member>
        <member name="P:NavigationResources.RemoveItemWithChildren">
            <summary>
              Looks up a localized string similar to The item at {0} has children and the Recurse parameter was not specified. If you continue, all children will be removed with the item. Are you sure you want to continue?.
            </summary>
        </member>
        <member name="P:NavigationResources.RenamedItemInUse">
            <summary>
              Looks up a localized string similar to Cannot rename the item at &apos;{0}&apos; because it is in use..
            </summary>
        </member>
        <member name="P:NavigationResources.RenameItemDoesntExist">
            <summary>
              Looks up a localized string similar to Cannot rename because item at &apos;{0}&apos; does not exist..
            </summary>
        </member>
        <member name="P:NavigationResources.RollbackAction">
            <summary>
              Looks up a localized string similar to Rollback.
            </summary>
        </member>
        <member name="P:NavigationResources.SetContentAction">
            <summary>
              Looks up a localized string similar to Set Content.
            </summary>
        </member>
        <member name="P:NavigationResources.SetContentTarget">
            <summary>
              Looks up a localized string similar to Path: {0}.
            </summary>
        </member>
        <member name="P:NavigationResources.TransactionResource">
            <summary>
              Looks up a localized string similar to Current transaction.
            </summary>
        </member>
        <member name="T:CmdletizationResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:CmdletizationResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:CmdletizationResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimCmdletAdapter_DebugInquire">
            <summary>
              Looks up a localized string similar to The cmdlet does not fully support the Inquire action for debug messages.  Cmdlet operation will continue during the prompt.  Select a different action preference via -Debug switch or $DebugPreference variable, and try again..
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimCmdletAdapter_RemoteDcomDoesntSupportExtendedSemantics">
            <summary>
              Looks up a localized string similar to {0}: A CimSession to the CIM server uses the DCOM protocol, which does not support the {1} switch..
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimCmdletAdapter_WarningInquire">
            <summary>
              Looks up a localized string similar to The cmdlet does not fully support the Inquire action for warnings.  Cmdlet operation will continue during the prompt.  Select a different action preference via -WarningAction parameter or $WarningPreference variable, and try again..
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimCmdletAdapter_WarningStop">
            <summary>
              Looks up a localized string similar to The cmdlet does not fully support the Stop action for warnings.  Cmdlet operation will be stopped with a delay.  Select a different action preference via -WarningAction parameter or $WarningPreference variable, and try again..
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimConversion_CimIntrinsicValue">
            <summary>
              Looks up a localized string similar to CIM intrinsic type.
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimConversion_WqlQuery">
            <summary>
              Looks up a localized string similar to WQL literal.
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimJob_AssociationDescription">
            <summary>
              Looks up a localized string similar to CIM query for enumerating instances of the {0} class on the {1} CIM server, that are associated with the following instance: {2}.
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimJob_BrokenSession">
            <summary>
              Looks up a localized string similar to Cannot connect to CIM server. {0}.
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimJob_ComputerNameConcatenationTemplate">
            <summary>
              Looks up a localized string similar to {0}: {1}.
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimJob_ErrorCodeFromMethod">
            <summary>
              Looks up a localized string similar to The CIM method returned the following error code: {0}.
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimJob_GenericCimFailure">
            <summary>
              Looks up a localized string similar to Failed to run {1}.  {0}.
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimJob_InvalidClassName">
            <summary>
              Looks up a localized string similar to Cannot find the {0} class on the {1} CIM server.  Verify the value of the ClassName xml attribute in Cmdlet Definition XML and retry. Valid class name example: ROOT\cimv2\Win32_Process..
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimJob_InvalidOutputParameterName">
            <summary>
              Looks up a localized string similar to Cannot find the {2} output parameter of the {1} method of the {0} CIM object.  Verify the value of the ParameterName attribute in Cmdlet Definition XML and retry..
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimJob_MethodDescription">
            <summary>
              Looks up a localized string similar to CIM method {1} on the {0} CIM object.
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimJob_MismatchedTypeOfPropertyReturnedByQuery">
            <summary>
              Looks up a localized string similar to Type of {0} property ({1}) doesn&apos;t match the CIM type ({2}) associated with the type declared in Cmdlet Definition XML..
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimJob_NotFound_ComplexCase">
            <summary>
              Looks up a localized string similar to No matching {1} objects found by {0}. Verify query parameters and retry..
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimJob_NotFound_SimpleGranularCase_Equality">
            <summary>
              Looks up a localized string similar to No {2} objects found with property &apos;{0}&apos; equal to &apos;{1}&apos;.  Verify the value of the property and retry..
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimJob_NotFound_SimpleGranularCase_Wildcard">
            <summary>
              Looks up a localized string similar to No {2} objects found with property &apos;{0}&apos; matching &apos;{1}&apos;.  Verify the value of the property and retry..
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimJob_SafeAssociationDescription">
            <summary>
              Looks up a localized string similar to CIM query for enumerating associated instance of the {0} class on the {1} CIM server.
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimJob_SafeMethodDescription">
            <summary>
              Looks up a localized string similar to The {2} CIM method exposed by the {0} class on the {1} CIM server.
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimJob_SafeQueryDescription">
            <summary>
              Looks up a localized string similar to CIM query for instances of the {0} class on the {1} CIM server: {2}.
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimJob_SleepAndRetryVerboseMessage">
            <summary>
              Looks up a localized string similar to The {0} command cannot complete, because the {1} server is currently busy.  The command will be automatically resumed in {2:f2} seconds..
            </summary>
        </member>
        <member name="P:CmdletizationResources.CimJob_VerboseExecutionMessage">
            <summary>
              Looks up a localized string similar to Running the following operation: {0}..
            </summary>
        </member>
        <member name="P:CmdletizationResources.SessionBasedWrapper_ShouldProcessVsJobConflict">
            <summary>
              Looks up a localized string similar to CIM cmdlets do not support the {0} parameter together with the AsJob parameter.  Remove one of these parameters and retry..
            </summary>
        </member>
        <member name="P:CmdletizationResources.Xml_cmdletsOverObjectsXsd">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
            &lt;!-- ##################################################################
            Copyright (c) Microsoft Corporation.  All rights reserved.
            ################################################################### --&gt;
            &lt;!DOCTYPE schema [
              &lt;!ENTITY csharpIdentifierLetterCharacterRegex &quot;\p{Lu}\p{Ll}\p{Lt}\p{Lm}\p{Lo}\p{Nl}&quot;&gt;
              &lt;!ENTITY csharpIdentifierFirstCharacterRegex &quot;&amp;csharpIdentifierLetterCharacterRegex;_&quot;&gt;
              &lt;!ENTITY csharpIdentifierOtherCharacterRegex &quot;&amp;csharpIdentifierL [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="T:ProcessResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ProcessResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ProcessResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ProcessResources.AttachDebuggerReturnCode2">
            <summary>
              Looks up a localized string similar to The user does not have access to the requested information..
            </summary>
        </member>
        <member name="P:ProcessResources.AttachDebuggerReturnCode21">
            <summary>
              Looks up a localized string similar to The specified parameter is not valid..
            </summary>
        </member>
        <member name="P:ProcessResources.AttachDebuggerReturnCode3">
            <summary>
              Looks up a localized string similar to The user does not have sufficient privilege..
            </summary>
        </member>
        <member name="P:ProcessResources.AttachDebuggerReturnCode8">
            <summary>
              Looks up a localized string similar to Unknown failure..
            </summary>
        </member>
        <member name="P:ProcessResources.AttachDebuggerReturnCode9">
            <summary>
              Looks up a localized string similar to The path specified does not exist..
            </summary>
        </member>
        <member name="P:ProcessResources.CannotStarttheProcess">
            <summary>
              Looks up a localized string similar to This command cannot be run completely because the system cannot find all the information required..
            </summary>
        </member>
        <member name="P:ProcessResources.ConfirmStopProcess">
            <summary>
              Looks up a localized string similar to Are you sure you want to perform the Stop-Process operation on the following item: {0}({1})?.
            </summary>
        </member>
        <member name="P:ProcessResources.ContradictParametersSpecified">
            <summary>
              Looks up a localized string similar to Parameters &quot;{0}&quot; and &quot;{1}&quot; cannot be specified at the same time..
            </summary>
        </member>
        <member name="P:ProcessResources.CouldNotDebugProcess">
            <summary>
              Looks up a localized string similar to Cannot debug process &quot;{0} ({1})&quot; because of the following error: {2}.
            </summary>
        </member>
        <member name="P:ProcessResources.CouldnotEnumerateFileVer">
            <summary>
              Looks up a localized string similar to Cannot enumerate the file version information of the &quot;{0}&quot; process..
            </summary>
        </member>
        <member name="P:ProcessResources.CouldnotEnumerateModuleFileVer">
            <summary>
              Looks up a localized string similar to Cannot enumerate the modules and the file version information of the &quot;{0}&quot; process..
            </summary>
        </member>
        <member name="P:ProcessResources.CouldnotEnumerateModules">
            <summary>
              Looks up a localized string similar to Cannot enumerate the modules of the &quot;{0}&quot; process..
            </summary>
        </member>
        <member name="P:ProcessResources.CouldNotStopProcess">
            <summary>
              Looks up a localized string similar to Cannot stop process &quot;{0} ({1})&quot; because of the following error: {2}.
            </summary>
        </member>
        <member name="P:ProcessResources.DebuggerError">
            <summary>
              Looks up a localized string similar to This command cannot attach the debugger to the process due to {0} because no default debugger is available..
            </summary>
        </member>
        <member name="P:ProcessResources.DuplicateEntry">
            <summary>
              Looks up a localized string similar to This command cannot be run because &quot;{0}&quot; and &quot;{1}&quot; are same. Give different inputs and Run your command again..
            </summary>
        </member>
        <member name="P:ProcessResources.IncludeUserNameRequiresElevation">
            <summary>
              Looks up a localized string similar to The &apos;IncludeUserName&apos; parameter requires elevated user rights. Try running the command again in a session that has been opened with elevated user rights (that is, Run as Administrator)..
            </summary>
        </member>
        <member name="P:ProcessResources.InvalidApplication">
            <summary>
              Looks up a localized string similar to This command cannot be run because the input &quot;{0}&quot; is not a valid Application.  Give a valid application and run your command again..
            </summary>
        </member>
        <member name="P:ProcessResources.InvalidInput">
            <summary>
              Looks up a localized string similar to This command cannot be run because either the parameter &quot;{0}&quot; has a value that is not valid or cannot be used with this command. Give a valid input and Run your command again..
            </summary>
        </member>
        <member name="P:ProcessResources.InvalidStartProcess">
            <summary>
              Looks up a localized string similar to This command cannot be run due to the error: {0}..
            </summary>
        </member>
        <member name="P:ProcessResources.InvalidUserError">
            <summary>
              Looks up a localized string similar to This command cannot be run due to error 1783. The possible cause of this error can be using of a non-existing user &quot;{0}&quot;. Please give a valid user and run your command again..
            </summary>
        </member>
        <member name="P:ProcessResources.JoinNetworkFailed">
            <summary>
              Looks up a localized string similar to Error adding &apos;{0}&apos; to the network: {1}.
            </summary>
        </member>
        <member name="P:ProcessResources.NoComputerNameWithFileVersion">
            <summary>
              Looks up a localized string similar to Exception getting &quot;Modules&quot; or &quot;FileVersion&quot;: &quot;This feature is not supported for remote computers.&quot;..
            </summary>
        </member>
        <member name="P:ProcessResources.NoDebuggerFound">
            <summary>
              Looks up a localized string similar to This command cannot be run because the debugger cannot be attached to the process &quot;{0} ({1})&quot;. Specify another process and Run your command..
            </summary>
        </member>
        <member name="P:ProcessResources.NoProcessFoundForGivenId">
            <summary>
              Looks up a localized string similar to Cannot find a process with the process identifier {1}..
            </summary>
        </member>
        <member name="P:ProcessResources.NoProcessFoundForGivenName">
            <summary>
              Looks up a localized string similar to Cannot find a process with the name &quot;{0}&quot;. Verify the process name and call the cmdlet again..
            </summary>
        </member>
        <member name="P:ProcessResources.ParameterNotSupported">
            <summary>
              Looks up a localized string similar to The parameter &apos;{0}&apos; is not supported for the cmdlet &apos;{1}&apos; on this edition of Windows..
            </summary>
        </member>
        <member name="P:ProcessResources.Process_is_not_terminated">
            <summary>
              Looks up a localized string similar to This command stopped operation of &quot;{0} ({1})&quot; because of the following error: {2}..
            </summary>
        </member>
        <member name="P:ProcessResources.ProcessNameForConfirmation">
            <summary>
              Looks up a localized string similar to {0} ({1}).
            </summary>
        </member>
        <member name="P:ProcessResources.ProcessNotTerminated">
            <summary>
              Looks up a localized string similar to This command stopped operation because process &quot;{0} ({1})&quot; is not stopped in the specified time-out..
            </summary>
        </member>
        <member name="P:ProcessResources.RedirectionParams">
            <summary>
              Looks up a localized string similar to This command cannot be run because Redirection parameters cannot be used with UseShellExecute parameter.
            </summary>
        </member>
        <member name="P:ProcessResources.RemoveFailed">
            <summary>
              Looks up a localized string similar to Error removing &apos;{0}&apos; from the network: {1}.
            </summary>
        </member>
        <member name="P:ProcessResources.RenameFailed">
            <summary>
              Looks up a localized string similar to Error renaming &apos;{0}&apos;: {1}.
            </summary>
        </member>
        <member name="P:ProcessResources.UseShell">
            <summary>
              Looks up a localized string similar to The specified path is not a valid win32 application. Try again with the UseShellExecute..
            </summary>
        </member>
        <member name="P:ProcessResources.WaitOnIdleProcess">
            <summary>
              Looks up a localized string similar to This command stopped operation because it cannot wait on &apos;System Idle&apos; process. Specify another process and Run your command again..
            </summary>
        </member>
        <member name="P:ProcessResources.WaitOnItself">
            <summary>
              Looks up a localized string similar to This command stopped operation because it cannot wait on itself. Specify another process and Run your command again..
            </summary>
        </member>
        <member name="T:ServiceResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ServiceResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ServiceResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ServiceResources.ComputerAccessDenied">
            <summary>
              Looks up a localized string similar to The command cannot be used to configure the service &apos;{0}&apos; because access to computer &apos;{1}&apos; is denied. Run Windows PowerShell as admin and run your command again..
            </summary>
        </member>
        <member name="P:ServiceResources.CouldNotAccessDependentServices">
            <summary>
              Looks up a localized string similar to &apos;Cannot access dependent services of &apos;{1} ({0})&apos;.
            </summary>
        </member>
        <member name="P:ServiceResources.CouldNotNewService">
            <summary>
              Looks up a localized string similar to Service &apos;{1} ({0})&apos; cannot be created due to the following error: {2}.
            </summary>
        </member>
        <member name="P:ServiceResources.CouldNotNewServiceDescription">
            <summary>
              Looks up a localized string similar to Service &apos;{1} ({0})&apos; was created, but its description cannot be configured due to the following error: {2}.
            </summary>
        </member>
        <member name="P:ServiceResources.CouldNotResumeService">
            <summary>
              Looks up a localized string similar to Service &apos;{1} ({0})&apos; cannot be resumed due to the following error: {2}.
            </summary>
        </member>
        <member name="P:ServiceResources.CouldNotResumeServiceNotRunning">
            <summary>
              Looks up a localized string similar to Service &apos;{1} ({0})&apos; cannot be resumed because it is not currently running..
            </summary>
        </member>
        <member name="P:ServiceResources.CouldNotResumeServiceNotSupported">
            <summary>
              Looks up a localized string similar to Service &apos;{1} ({0})&apos; cannot be resumed because the service does not support being suspended or resumed..
            </summary>
        </member>
        <member name="P:ServiceResources.CouldNotSetService">
            <summary>
              Looks up a localized string similar to Service &apos;{1} ({0})&apos; cannot be configured due to the following error: {2}.
            </summary>
        </member>
        <member name="P:ServiceResources.CouldNotSetServiceDescription">
            <summary>
              Looks up a localized string similar to Service &apos;{1} ({0})&apos; description cannot be configured due to the following error: {2}.
            </summary>
        </member>
        <member name="P:ServiceResources.CouldNotStartService">
            <summary>
              Looks up a localized string similar to Service &apos;{1} ({0})&apos; cannot be started due to the following error: {2}.
            </summary>
        </member>
        <member name="P:ServiceResources.CouldNotStopService">
            <summary>
              Looks up a localized string similar to Service &apos;{1} ({0})&apos; cannot be stopped due to the following error: {2}.
            </summary>
        </member>
        <member name="P:ServiceResources.CouldNotSuspendService">
            <summary>
              Looks up a localized string similar to Service &apos;{1} ({0})&apos; cannot be suspended due to the following error: {2}.
            </summary>
        </member>
        <member name="P:ServiceResources.CouldNotSuspendServiceNotRunning">
            <summary>
              Looks up a localized string similar to Service &apos;{1} ({0})&apos; cannot be suspended because it is not currently running..
            </summary>
        </member>
        <member name="P:ServiceResources.CouldNotSuspendServiceNotSupported">
            <summary>
              Looks up a localized string similar to Service &apos;{1} ({0})&apos; cannot be suspended because the service does not support being suspended or resumed..
            </summary>
        </member>
        <member name="P:ServiceResources.NoServiceFoundForGivenDisplayName">
            <summary>
              Looks up a localized string similar to Cannot find any service with display name &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:ServiceResources.NoServiceFoundForGivenName">
            <summary>
              Looks up a localized string similar to Cannot find any service with service name &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:ServiceResources.ResumeServiceFailed">
            <summary>
              Looks up a localized string similar to Service &apos;{1} ({0})&apos; resume failed..
            </summary>
        </member>
        <member name="P:ServiceResources.ResumingService">
            <summary>
              Looks up a localized string similar to Waiting for service &apos;{1} ({0})&apos; to resume....
            </summary>
        </member>
        <member name="P:ServiceResources.ServiceHasDependentServices">
            <summary>
              Looks up a localized string similar to Cannot stop service &apos;{1} ({0})&apos; because it has dependent services. It can only be stopped if the Force flag is set..
            </summary>
        </member>
        <member name="P:ServiceResources.ServiceHasDependentServicesNoForce">
            <summary>
              Looks up a localized string similar to Cannot stop service &apos;{1} ({0})&apos; because it has dependent services..
            </summary>
        </member>
        <member name="P:ServiceResources.ServiceIsDependentOnNoForce">
            <summary>
              Looks up a localized string similar to Cannot stop service &apos;{1} ({0})&apos; because it is dependent on other services..
            </summary>
        </member>
        <member name="P:ServiceResources.ServiceNameForConfirmation">
            <summary>
              Looks up a localized string similar to {0} ({1}).
            </summary>
        </member>
        <member name="P:ServiceResources.StartingService">
            <summary>
              Looks up a localized string similar to Waiting for service &apos;{1} ({0})&apos; to start....
            </summary>
        </member>
        <member name="P:ServiceResources.StartServiceFailed">
            <summary>
              Looks up a localized string similar to Failed to start service &apos;{1} ({0})&apos;..
            </summary>
        </member>
        <member name="P:ServiceResources.StoppingService">
            <summary>
              Looks up a localized string similar to Waiting for service &apos;{1} ({0})&apos; to stop....
            </summary>
        </member>
        <member name="P:ServiceResources.StopServiceFailed">
            <summary>
              Looks up a localized string similar to Service &apos;{1} ({0})&apos; stop failed..
            </summary>
        </member>
        <member name="P:ServiceResources.SuspendingService">
            <summary>
              Looks up a localized string similar to Waiting for service &apos;{1} ({0})&apos; to suspend....
            </summary>
        </member>
        <member name="P:ServiceResources.SuspendServiceFailed">
            <summary>
              Looks up a localized string similar to Service &apos;{1} ({0})&apos; suspend failed..
            </summary>
        </member>
        <member name="T:ComputerResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ComputerResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ComputerResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ComputerResources.AddComputerActionDomain">
            <summary>
              Looks up a localized string similar to Join in domain &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:ComputerResources.AddComputerActionWorkgroup">
            <summary>
              Looks up a localized string similar to Join in workgroup &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:ComputerResources.AddComputerToSameDomain">
            <summary>
              Looks up a localized string similar to Cannot add computer &apos;{0}&apos; to domain &apos;{1}&apos; because it is already in that domain..
            </summary>
        </member>
        <member name="P:ComputerResources.AddComputerToSameWorkgroup">
            <summary>
              Looks up a localized string similar to Cannot add computer &apos;{0}&apos; to workgroup &apos;{1}&apos; because it is already in that workgroup..
            </summary>
        </member>
        <member name="P:ComputerResources.CannotCreateRestorePointWarning">
            <summary>
              Looks up a localized string similar to A new system restore point cannot be created because one has already been created within the past {0} minutes. The frequency of restore point creation can be changed by creating the DWORD value &apos;SystemRestorePointCreationFrequency&apos; under the registry key &apos;HKLM\Software\Microsoft\Windows NT\CurrentVersion\SystemRestore&apos;. The value of this registry key indicates the necessary time interval (in minutes) between two restore point creation. The default value is 1440 minutes (24 hours)..
            </summary>
        </member>
        <member name="P:ComputerResources.CannotFindMachineAccountFromDomain">
            <summary>
              Looks up a localized string similar to Cannot find the computer account for the local computer in the domain {0}..
            </summary>
        </member>
        <member name="P:ComputerResources.CannotFindMachineAccountFromServer">
            <summary>
              Looks up a localized string similar to Cannot find the computer account for the local computer from the domain controller {0}..
            </summary>
        </member>
        <member name="P:ComputerResources.CannotGetOperatingSystemObject">
            <summary>
              Looks up a localized string similar to The Win32_OperatingSystem WMI object cannot be retrieved..
            </summary>
        </member>
        <member name="P:ComputerResources.CannotRenameMultipleComputers">
            <summary>
              Looks up a localized string similar to Cannot rename multiple computers. The NewName parameter is valid only if a single computer is specified..
            </summary>
        </member>
        <member name="P:ComputerResources.CannotResolveComputerName">
            <summary>
              Looks up a localized string similar to Computer name {0} cannot be resolved with the exception: {1}..
            </summary>
        </member>
        <member name="P:ComputerResources.CannotResolveServerName">
            <summary>
              Looks up a localized string similar to The specified server name {0} cannot be resolved..
            </summary>
        </member>
        <member name="P:ComputerResources.CannotWaitLocalComputer">
            <summary>
              Looks up a localized string similar to Cannot wait for the local computer to restart. The local computer is ignored when the Wait parameter is specified..
            </summary>
        </member>
        <member name="P:ComputerResources.ComputerNamesAreEqual">
            <summary>
              Looks up a localized string similar to The value specified for the NewComputerName parameter is the same as the value of the ComputerName parameter. Provide a different value for the NewComputerName parameter..
            </summary>
        </member>
        <member name="P:ComputerResources.ComputerNotInDomain">
            <summary>
              Looks up a localized string similar to Cannot remove computer &apos;{0}&apos; because it is not in a domain..
            </summary>
        </member>
        <member name="P:ComputerResources.DoubleComputerName">
            <summary>
              Looks up a localized string similar to {0} ({1}).
            </summary>
        </member>
        <member name="P:ComputerResources.FailToConnectToComputer">
            <summary>
              Looks up a localized string similar to Cannot establish the WMI connection to the computer &apos;{0}&apos; with the following error message: {1}..
            </summary>
        </member>
        <member name="P:ComputerResources.FailToGetDomainInformation">
            <summary>
              Looks up a localized string similar to Cannot get domain information about the local computer because of the following exception: {0}..
            </summary>
        </member>
        <member name="P:ComputerResources.FailToJoinDomainFromWorkgroup">
            <summary>
              Looks up a localized string similar to Computer &apos;{0}&apos; failed to join domain &apos;{1}&apos; from its current workgroup &apos;{2}&apos; with following error message: {3}..
            </summary>
        </member>
        <member name="P:ComputerResources.FailToJoinNewDomainAfterUnjoinOldDomain">
            <summary>
              Looks up a localized string similar to Computer &apos;{0}&apos; was successfully unjoined from domain &apos;{1}&apos;, but failed to join the new domain &apos;{2}&apos; with the following error message: {3}..
            </summary>
        </member>
        <member name="P:ComputerResources.FailToJoinWorkGroup">
            <summary>
              Looks up a localized string similar to Failed to join computer &apos;{0}&apos; to workgroup &apos;{1}&apos; with the following error message: {2}.
            </summary>
        </member>
        <member name="P:ComputerResources.FailToRename">
            <summary>
              Looks up a localized string similar to Fail to rename computer &apos;{0}&apos; to &apos;{1}&apos; due to the following exception: {2}..
            </summary>
        </member>
        <member name="P:ComputerResources.FailToRenameAfterJoinDomain">
            <summary>
              Looks up a localized string similar to Computer &apos;{0}&apos; was successfully joined to the new domain &apos;{1}&apos;, but renaming it to &apos;{2}&apos; failed with the following error message: {3}..
            </summary>
        </member>
        <member name="P:ComputerResources.FailToRenameAfterJoinWorkgroup">
            <summary>
              Looks up a localized string similar to Computer &apos;{0}&apos; successfully joined the workgroup &apos;{1}&apos;, but could not be renamed to &apos;{2}&apos; with the following error message: {3}..
            </summary>
        </member>
        <member name="P:ComputerResources.FailToResetPasswordOnDomain">
            <summary>
              Looks up a localized string similar to Cannot reset the secure channel password for the computer account in the domain. Operation failed with the following exception: {0}..
            </summary>
        </member>
        <member name="P:ComputerResources.FailToResetPasswordOnLocalMachine">
            <summary>
              Looks up a localized string similar to Resetting the secure channel password for the local computer failed with the following error message: {0}..
            </summary>
        </member>
        <member name="P:ComputerResources.FailToRetrieveLastRestorePoint">
            <summary>
              Looks up a localized string similar to Cannot validate the time interval for restore point creation. It failed to retrieve the last restore point with the following error message: {0}..
            </summary>
        </member>
        <member name="P:ComputerResources.FailToSwitchFromDomainToWorkgroup">
            <summary>
              Looks up a localized string similar to Computer &apos;{0}&apos; was successfully unjoined from the domain &apos;{1}&apos;, but it failed to join the workgroup &apos;{2}&apos; with the following error message: {3}..
            </summary>
        </member>
        <member name="P:ComputerResources.FailToTestSecureChannel">
            <summary>
              Looks up a localized string similar to Cannot verify the secure channel for the local computer. Operation failed with the following exception: {0}..
            </summary>
        </member>
        <member name="P:ComputerResources.FailToUnjoinDomain">
            <summary>
              Looks up a localized string similar to Failed to unjoin computer &apos;{0}&apos; from domain &apos;{1}&apos; with the following error message: {2}..
            </summary>
        </member>
        <member name="P:ComputerResources.IncorrectNewNameNumber">
            <summary>
              Looks up a localized string similar to The number of new names is not equal to the number of target computers..
            </summary>
        </member>
        <member name="P:ComputerResources.InvalidComputerNameFormat">
             <summary>
               Looks up a localized string similar to The following computer name is not valid: {0}. Make sure that the computer name is not longer than 255 characters, that it does not contain two or more consecutive dots, that it does not begin with a dot, that it does not contain only numeric characters, and that it does not contain any of the following characters:  
            {{|}}~[\]^:;&lt;=&gt;?@!&quot;#$%^`()+/,.
             </summary>
        </member>
        <member name="P:ComputerResources.InvalidDomainNameFormat">
            <summary>
              Looks up a localized string similar to The domain in computer name &apos;{0}&apos; is not valid. Make sure that the domain exists and that the name is a valid domain name..
            </summary>
        </member>
        <member name="P:ComputerResources.InvalidDrive">
            <summary>
              Looks up a localized string similar to The command cannot turn on the restore computer infrastructure on the specified computer because the supplied drive is not valid. Enter a valid drive in the Drive parameter, and then try again..
            </summary>
        </member>
        <member name="P:ComputerResources.InvalidJoinOptions">
            <summary>
              Looks up a localized string similar to The flag &apos;{0}&apos; is valid only if flag &apos;{1}&apos; is specified..
            </summary>
        </member>
        <member name="P:ComputerResources.InvalidNewName">
            <summary>
              Looks up a localized string similar to Skip computer &apos;{0}&apos; with new name &apos;{1}&apos; because the new name is not valid. The new computer name entered is not properly formatted. Standard names may contain letters (a-z, A-Z), numbers (0-9), and hyphens (-), but no spaces or periods (.). The name may not consist entirely of digits, and may not be longer than 63 characters..
            </summary>
        </member>
        <member name="P:ComputerResources.InvalidParameterDCOMNotSupported">
            <summary>
              Looks up a localized string similar to DcomAuthentication is not supported. Please use WsmanAuthentication instead..
            </summary>
        </member>
        <member name="P:ComputerResources.InvalidParameterForCoreClr">
            <summary>
              Looks up a localized string similar to The {0} parameter is not supported for CoreCLR..
            </summary>
        </member>
        <member name="P:ComputerResources.InvalidParameterForDCOM">
            <summary>
              Looks up a localized string similar to Parameter WsmanAuthentication should not be specified when the DCOM protocol is in use. {0}.
            </summary>
        </member>
        <member name="P:ComputerResources.InvalidParameterForWSMan">
            <summary>
              Looks up a localized string similar to Parameters DcomAuthentication and Impersonation should not be specified when the WSMan protocol is in use. {0}.
            </summary>
        </member>
        <member name="P:ComputerResources.InvalidParameterSetAsJob">
            <summary>
              Looks up a localized string similar to The AsJob Parameter Set is not supported..
            </summary>
        </member>
        <member name="P:ComputerResources.InvalidRestorePoint">
            <summary>
              Looks up a localized string similar to The command cannot restore the computer because &quot;{0}&quot; has not been set as valid restore point. Enter a valid restore point in the RestorePoint parameter, and then try again..
            </summary>
        </member>
        <member name="P:ComputerResources.LocalShutdownPrivilege">
            <summary>
              Looks up a localized string similar to Local shutdown access rights.
            </summary>
        </member>
        <member name="P:ComputerResources.NeedAdminPrivilegeToResetPassword">
            <summary>
              Looks up a localized string similar to Administrator rights are required to reset the secure channel password on the local computer. Access is denied..
            </summary>
        </member>
        <member name="P:ComputerResources.NetworkDown">
            <summary>
              Looks up a localized string similar to Cannot remove computer(s) from the domain because the local network is down..
            </summary>
        </member>
        <member name="P:ComputerResources.NetworkPathNotFound">
             <summary>
               Looks up a localized string similar to Try below options and Run the command again.
            1. Verify that the target computer(&apos;{0}&apos;) is running.
            2. Specify full computer name of the target computer(&apos;{0}&apos;)..
             </summary>
        </member>
        <member name="P:ComputerResources.NewNameIsOldName">
            <summary>
              Looks up a localized string similar to Skip computer &apos;{0}&apos; with new name &apos;{1}&apos; because the new name is the same as the current name..
            </summary>
        </member>
        <member name="P:ComputerResources.NoPingResult">
            <summary>
              Looks up a localized string similar to Testing connection to computer &apos;{0}&apos; failed: {1}.
            </summary>
        </member>
        <member name="P:ComputerResources.NoResorePoint">
            <summary>
              Looks up a localized string similar to The command cannot locate the &quot;{0}&quot; restore point. Verify the &quot;{0}&quot; sequence number, and then try the command again..
            </summary>
        </member>
        <member name="P:ComputerResources.NoSupportForCombinedServiceType">
            <summary>
              Looks up a localized string similar to The combined service types are not supported for now..
            </summary>
        </member>
        <member name="P:ComputerResources.NoSystemDrive">
            <summary>
              Looks up a localized string similar to Include System Drive in the list of Drives..
            </summary>
        </member>
        <member name="P:ComputerResources.NotDisabled">
            <summary>
              Looks up a localized string similar to The command cannot disable System Restore on the {0} drive. You may not have sufficient permissions to perform this operation..
            </summary>
        </member>
        <member name="P:ComputerResources.NotEnabled">
            <summary>
              Looks up a localized string similar to Could not enable drive {0}..
            </summary>
        </member>
        <member name="P:ComputerResources.NotSupported">
            <summary>
              Looks up a localized string similar to This functionality is not supported on this operating system..
            </summary>
        </member>
        <member name="P:ComputerResources.NotValidDrive">
            <summary>
              Looks up a localized string similar to The command cannot turn off the restore computer infrastructure because the supplied drive is not valid. Enter a valid drive in the Drive parameter, and then try again..
            </summary>
        </member>
        <member name="P:ComputerResources.OperationFailed">
            <summary>
              Looks up a localized string similar to This command cannot be run on target computer(&apos;{1}&apos;) due to following error: {0}.{2}.
            </summary>
        </member>
        <member name="P:ComputerResources.ParameterConfliction">
            <summary>
              Looks up a localized string similar to Parameter WsmanAuthentication should not be specified with DcomAuthentication and Impersonation at the same time. {0}.
            </summary>
        </member>
        <member name="P:ComputerResources.ParameterUsage">
            <summary>
              Looks up a localized string similar to Parameter WsmanAuthentication is valid only if the WSMan protocol is used. Parameters DcomAuthentication (Authentication) and Impersonation are valid only if the DCOM protocol is used..
            </summary>
        </member>
        <member name="P:ComputerResources.PrivilegeNotEnabled">
            <summary>
              Looks up a localized string similar to Failed to restart the computer {0}. Access rights {1} cannot be enabled for the calling process..
            </summary>
        </member>
        <member name="P:ComputerResources.ProgressActivity">
            <summary>
              Looks up a localized string similar to Creating a system restore point ....
            </summary>
        </member>
        <member name="P:ComputerResources.ProgressStatusCompleted">
            <summary>
              Looks up a localized string similar to Completed..
            </summary>
        </member>
        <member name="P:ComputerResources.ProgressStatusCreatingRestorePoint">
            <summary>
              Looks up a localized string similar to Creating a system restore point... {0}% Completed..
            </summary>
        </member>
        <member name="P:ComputerResources.RemoteShutdownPrivilege">
            <summary>
              Looks up a localized string similar to Remote shutdown access rights.
            </summary>
        </member>
        <member name="P:ComputerResources.RemoveComputerConfirm">
            <summary>
              Looks up a localized string similar to After you leave the domain, you will need to know the password of the local Administrator account to log onto this computer. Do you wish to continue?.
            </summary>
        </member>
        <member name="P:ComputerResources.RenameCommandWsmanAuthParamConflict">
            <summary>
              Looks up a localized string similar to Parameter WsmanAuthentication cannot be specified with the DCOM protocol. Parameter WSManAuthentication is valid only when the WSMan protocol is used..
            </summary>
        </member>
        <member name="P:ComputerResources.RepairSecureChannelFail">
            <summary>
              Looks up a localized string similar to The attempt to repair the secure channel between the local computer and the domain {0} has failed..
            </summary>
        </member>
        <member name="P:ComputerResources.RepairSecureChannelSucceed">
            <summary>
              Looks up a localized string similar to The secure channel between the local computer and the domain {0} was successfully repaired..
            </summary>
        </member>
        <member name="P:ComputerResources.ResetComputerMachinePassword">
            <summary>
              Looks up a localized string similar to &quot;The password of the secure channel between &apos;{0}&apos; and &apos;{1}&apos; has been reset.&quot;.
            </summary>
        </member>
        <member name="P:ComputerResources.ResetComputerNotInDomain">
            <summary>
              Looks up a localized string similar to Cannot reset the secure channel password for the account of the local computer. The local computer is not currently part of a domain..
            </summary>
        </member>
        <member name="P:ComputerResources.RestartComplete">
            <summary>
              Looks up a localized string similar to Restart is complete.
            </summary>
        </member>
        <member name="P:ComputerResources.RestartComputerAction">
            <summary>
              Looks up a localized string similar to Enable the {0} and restart the computer..
            </summary>
        </member>
        <member name="P:ComputerResources.RestartcomputerFailed">
            <summary>
              Looks up a localized string similar to Failed to restart the computer {0} with the following error message: {1}..
            </summary>
        </member>
        <member name="P:ComputerResources.RestartComputerInvalidParameter">
            <summary>
              Looks up a localized string similar to The parameters Timeout, For, and Delay are valid only when the parameter Wait is specified..
            </summary>
        </member>
        <member name="P:ComputerResources.RestartComputerSkipped">
            <summary>
              Looks up a localized string similar to The computer {0} is skipped. Fail to retrieve its LastBootUpTime via the WMI service with the following error message: {1}..
            </summary>
        </member>
        <member name="P:ComputerResources.RestartMultipleComputersActivity">
            <summary>
              Looks up a localized string similar to  Restarting computers....
            </summary>
        </member>
        <member name="P:ComputerResources.RestartNeeded">
            <summary>
              Looks up a localized string similar to The changes will take effect after you restart the computer {1}..
            </summary>
        </member>
        <member name="P:ComputerResources.RestartSingleComputerActivity">
            <summary>
              Looks up a localized string similar to  Restarting computer {0}.
            </summary>
        </member>
        <member name="P:ComputerResources.RestoreFailed">
            <summary>
              Looks up a localized string similar to The last attempt to restore the computer failed..
            </summary>
        </member>
        <member name="P:ComputerResources.RestoreInterrupted">
            <summary>
              Looks up a localized string similar to The last attempt to restore the computer was interrupted..
            </summary>
        </member>
        <member name="P:ComputerResources.RestorePointNotCreated">
            <summary>
              Looks up a localized string similar to The system restore infrastructure cannot create a restore point..
            </summary>
        </member>
        <member name="P:ComputerResources.RestoreSuceess">
            <summary>
              Looks up a localized string similar to The computer has been restored to the specified restore point..
            </summary>
        </member>
        <member name="P:ComputerResources.SecureChannelAlive">
            <summary>
              Looks up a localized string similar to The secure channel between the local computer and the domain {0} is in good condition..
            </summary>
        </member>
        <member name="P:ComputerResources.SecureChannelBroken">
            <summary>
              Looks up a localized string similar to The secure channel between the local computer and the domain {0} is broken..
            </summary>
        </member>
        <member name="P:ComputerResources.ServiceDisabled">
            <summary>
              Looks up a localized string similar to SystemRestore service is disabled..
            </summary>
        </member>
        <member name="P:ComputerResources.StopCommandAuthProtcolConflict">
            <summary>
              Looks up a localized string similar to Parameters DcomAuthentication and Impersonation cannot be specified with the WSMan protocol. {0}.
            </summary>
        </member>
        <member name="P:ComputerResources.StopCommandParamMessage">
            <summary>
              Looks up a localized string similar to Parameter WsmanAuthentication is valid only when the WSMan protocol is used. Parameters DcomAuthentication and Impersonation are valid only when the DCOM protocol is used..
            </summary>
        </member>
        <member name="P:ComputerResources.StopCommandParamWSManAuthConflict">
            <summary>
              Looks up a localized string similar to Parameter WsmanAuthentication cannot be specified with DcomAuthentication or Impersonation parameters. {0}.
            </summary>
        </member>
        <member name="P:ComputerResources.StopCommandWSManAuthProtcolConflict">
            <summary>
              Looks up a localized string similar to Parameter WsmanAuthentication cannot be specified with the DCOM protocol. {0}.
            </summary>
        </member>
        <member name="P:ComputerResources.StopcomputerFailed">
            <summary>
              Looks up a localized string similar to Failed to stop the computer {0} with the following error message: {1}..
            </summary>
        </member>
        <member name="P:ComputerResources.SystemRestoreNotSupported">
            <summary>
              Looks up a localized string similar to The operation cannot be performed because the system restore APIs are not supported on the Advanced RISC Machine (ARM) platform..
            </summary>
        </member>
        <member name="P:ComputerResources.SystemRestoreServiceDisabled">
            <summary>
              Looks up a localized string similar to This command cannot be run due to the following error: the service cannot be started because it is disabled or does not have enabled devices associated with it..
            </summary>
        </member>
        <member name="P:ComputerResources.TestComputerNotInDomain">
            <summary>
              Looks up a localized string similar to Cannot verify the secure channel password for the local computer. The local computer is not currently part of a domain..
            </summary>
        </member>
        <member name="P:ComputerResources.TimeoutError">
            <summary>
              Looks up a localized string similar to The computer did not finish restarting within the specified time-out period..
            </summary>
        </member>
        <member name="P:ComputerResources.TruncateNetBIOSName">
            <summary>
              Looks up a localized string similar to The NetBIOS name of the computer is limited to 15 bytes, which is 15 characters in this case. The NetBIOS name will be shortened to &quot;{0}&quot;, which may cause conflicts under NetBIOS name resolution. Do you wish to continue?.
            </summary>
        </member>
        <member name="P:ComputerResources.TruncateNetBIOSNameCaption">
            <summary>
              Looks up a localized string similar to NetBIOS name will be truncated..
            </summary>
        </member>
        <member name="P:ComputerResources.VerifyRebootStage">
            <summary>
              Looks up a localized string similar to Verifying that the computer has been restarted....
            </summary>
        </member>
        <member name="P:ComputerResources.WaitForMultipleComputers">
            <summary>
              Looks up a localized string similar to Completed: {0}/{1}..
            </summary>
        </member>
        <member name="P:ComputerResources.WaitForPowerShell">
            <summary>
              Looks up a localized string similar to Waiting for Windows PowerShell connectivity....
            </summary>
        </member>
        <member name="P:ComputerResources.WaitForRestartToBegin">
            <summary>
              Looks up a localized string similar to Waiting for the restart to begin....
            </summary>
        </member>
        <member name="P:ComputerResources.WaitForWinRM">
            <summary>
              Looks up a localized string similar to Waiting for WinRM connectivity....
            </summary>
        </member>
        <member name="P:ComputerResources.WaitForWMI">
            <summary>
              Looks up a localized string similar to Waiting for WMI connectivity....
            </summary>
        </member>
        <member name="T:ComputerInfoResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ComputerInfoResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ComputerInfoResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ComputerInfoResources.LoadingBiosInfo">
            <summary>
              Looks up a localized string similar to Loading BIOS information.
            </summary>
        </member>
        <member name="P:ComputerInfoResources.LoadingComputerInfo">
            <summary>
              Looks up a localized string similar to Loading Computer information.
            </summary>
        </member>
        <member name="P:ComputerInfoResources.LoadingHotPatchInfo">
            <summary>
              Looks up a localized string similar to Loading hot-patch information.
            </summary>
        </member>
        <member name="P:ComputerInfoResources.LoadingMotherboardInfo">
            <summary>
              Looks up a localized string similar to Loading motherboard information.
            </summary>
        </member>
        <member name="P:ComputerInfoResources.LoadingNetworkAdapterInfo">
            <summary>
              Looks up a localized string similar to Loading network adapter information.
            </summary>
        </member>
        <member name="P:ComputerInfoResources.LoadingOperationSystemInfo">
            <summary>
              Looks up a localized string similar to Loading operating system information.
            </summary>
        </member>
        <member name="P:ComputerInfoResources.LoadingProcessorInfo">
            <summary>
              Looks up a localized string similar to Loading processor information.
            </summary>
        </member>
        <member name="P:ComputerInfoResources.LoadingRegistryInfo">
            <summary>
              Looks up a localized string similar to Loading registry information.
            </summary>
        </member>
        <member name="T:TimeZoneResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:TimeZoneResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:TimeZoneResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:TimeZoneResources.MultipleMatchingTimeZones">
            <summary>
              Looks up a localized string similar to Cannot set the local time zone because the name &apos;{0}&apos; resolves to multiple entries..
            </summary>
        </member>
        <member name="P:TimeZoneResources.TimeZoneNameNotFound">
            <summary>
              Looks up a localized string similar to The time zone name &apos;{0}&apos; was not found on the local computer..
            </summary>
        </member>
        <member name="T:EventlogResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:EventlogResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:EventlogResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:EventlogResources.AccessDenied">
            <summary>
              Looks up a localized string similar to The registry key for the log &quot;{0}&quot; for source &quot;{2}&quot; could not be opened..
            </summary>
        </member>
        <member name="P:EventlogResources.AccessIsDenied">
            <summary>
              Looks up a localized string similar to Access is denied. Try running the command again in a session that has been opened with elevated user rights (that is, Run as Administrator)..
            </summary>
        </member>
        <member name="P:EventlogResources.ClearEventLogWarning">
            <summary>
              Looks up a localized string similar to Do you want to clear the &quot;{0}&quot; log on the computer &quot;{1}&quot;?.
            </summary>
        </member>
        <member name="P:EventlogResources.InvalidArgument">
            <summary>
              Looks up a localized string similar to Specify a valid value for the number of retention days..
            </summary>
        </member>
        <member name="P:EventlogResources.InvalidOverflowAction">
            <summary>
              Looks up a localized string similar to Retention days is valid only if the overflow action is &quot;OverwriteOlder&quot;. Please change  and try again..
            </summary>
        </member>
        <member name="P:EventlogResources.LimitEventLogWarning">
            <summary>
              Looks up a localized string similar to Do you want to change the properties of the &quot;{0}&quot; log on the &quot;{1}&quot; computer?.
            </summary>
        </member>
        <member name="P:EventlogResources.LogDoesNotExist">
            <summary>
              Looks up a localized string similar to The Log name &quot;{0}&quot; does not exist in the computer &quot;{1}&quot;..
            </summary>
        </member>
        <member name="P:EventlogResources.LogReadError">
            <summary>
              Looks up a localized string similar to Log &quot;{0}&quot; could not be read to completion due to the following error. This may have occurred because the log was cleared while still being read. {1}.
            </summary>
        </member>
        <member name="P:EventlogResources.NoAccess">
            <summary>
              Looks up a localized string similar to Access to the &quot;{1}&quot; computer is denied..
            </summary>
        </member>
        <member name="P:EventlogResources.NoEntriesFound">
            <summary>
              Looks up a localized string similar to No matches found.
            </summary>
        </member>
        <member name="P:EventlogResources.NotSupported">
            <summary>
              Looks up a localized string similar to The command is not supported in this version of the operating system..
            </summary>
        </member>
        <member name="P:EventlogResources.OSWritingError">
            <summary>
              Looks up a localized string similar to The operating system reported an error when writing the event entry to the event log. A Windows error code is not available..
            </summary>
        </member>
        <member name="P:EventlogResources.PathDoesNotExist">
            <summary>
              Looks up a localized string similar to The path to the &quot;{1}&quot; computer cannot be found..
            </summary>
        </member>
        <member name="P:EventlogResources.PermissionDenied">
            <summary>
              Looks up a localized string similar to The registry key for the log &quot;{0}&quot; could not be opened on the computer &quot;{1}&quot;..
            </summary>
        </member>
        <member name="P:EventlogResources.RemoveEventLogWarning">
            <summary>
              Looks up a localized string similar to Do you want to remove the &quot;{0}&quot; log from the &quot;{1}&quot; computer?.
            </summary>
        </member>
        <member name="P:EventlogResources.RemoveSourceWarning">
            <summary>
              Looks up a localized string similar to Do you want to remove the &quot;{0}&quot; source from the &quot;{1}&quot; computer?.
            </summary>
        </member>
        <member name="P:EventlogResources.SourceDoesNotExist">
            <summary>
              Looks up a localized string similar to The source name &quot;{2}&quot; does not exist on computer &quot;{1}&quot;..
            </summary>
        </member>
        <member name="P:EventlogResources.SourceExistInComp">
            <summary>
              Looks up a localized string similar to The &quot;{2}&quot; source is already registered on the &quot;{1}&quot; computer..
            </summary>
        </member>
        <member name="P:EventlogResources.SourceExistWithLog">
            <summary>
              Looks up a localized string similar to The &quot;{2}&quot; source is already registered with the &quot;{0}&quot; log..
            </summary>
        </member>
        <member name="P:EventlogResources.ValueOutofRange">
            <summary>
              Looks up a localized string similar to The value supplied for MaximumSize parameter has to be in the range of 64 KB to 4GB with an increment of 64 KB. Please enter a proper value and then retry..
            </summary>
        </member>
        <member name="T:TransactionResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:TransactionResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:TransactionResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:TransactionResources.TransactionTimedOut">
            <summary>
              Looks up a localized string similar to Cannot use transaction. The transaction has timed out..
            </summary>
        </member>
        <member name="T:WebServiceResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:WebServiceResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:WebServiceResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:WebServiceResources.InvalidUri">
            <summary>
              Looks up a localized string similar to The Uniform Resource Identifier (URI) cannot be null or empty. Provide a valid URI..
            </summary>
        </member>
        <member name="P:WebServiceResources.NotSupported">
            <summary>
              Looks up a localized string similar to The command is not supported on this operating system..
            </summary>
        </member>
        <member name="T:HotFixResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:HotFixResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:HotFixResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:HotFixResources.NoEntriesFound">
            <summary>
              Looks up a localized string similar to Cannot find the requested hotfix on the &apos;{0}&apos; computer. Verify the input and run the command again..
            </summary>
        </member>
        <member name="T:ControlPanelResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ControlPanelResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ControlPanelResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ControlPanelResources.ControlPanelItemCmdletNotSupported">
            <summary>
              Looks up a localized string similar to The {0} cmdlet is not supported on this version of Windows..
            </summary>
        </member>
        <member name="P:ControlPanelResources.NoControlPanelItemFoundForGivenCanonicalName">
            <summary>
              Looks up a localized string similar to Cannot find any Control Panel item with the given canonical name {0}..
            </summary>
        </member>
        <member name="P:ControlPanelResources.NoControlPanelItemFoundForGivenCanonicalNameWithCategory">
            <summary>
              Looks up a localized string similar to Cannot find any control panel item with the given canonical name {0} that satisfies the specified category..
            </summary>
        </member>
        <member name="P:ControlPanelResources.NoControlPanelItemFoundForGivenCategory">
            <summary>
              Looks up a localized string similar to Cannot find any control panel item with the given category {0}..
            </summary>
        </member>
        <member name="P:ControlPanelResources.NoControlPanelItemFoundForGivenInstance">
            <summary>
              Looks up a localized string similar to Cannot find the Control Panel item based on the given instance of type {0}..
            </summary>
        </member>
        <member name="P:ControlPanelResources.NoControlPanelItemFoundForGivenName">
            <summary>
              Looks up a localized string similar to Cannot find any control panel item with the given name {0}..
            </summary>
        </member>
        <member name="P:ControlPanelResources.NoControlPanelItemFoundForGivenNameWithCategory">
            <summary>
              Looks up a localized string similar to Cannot find any Control Panel item with the given name {0} that satisfies the specified category..
            </summary>
        </member>
        <member name="P:ControlPanelResources.NoControlPanelItemFoundWithNullCanonicalName">
            <summary>
              Looks up a localized string similar to Cannot find any control panel item that has a canonical name..
            </summary>
        </member>
        <member name="P:ControlPanelResources.NoControlPanelItemFoundWithNullCanonicalNameWithCategory">
            <summary>
              Looks up a localized string similar to Cannot find any Control Panel item that satisfies the specified category and has a canonical name..
            </summary>
        </member>
        <member name="P:ControlPanelResources.VerbActionOpen">
            <summary>
              Looks up a localized string similar to &amp;Open.
            </summary>
        </member>
        <member name="T:WmiResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:WmiResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:WmiResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:WmiResources.WmiFilterInvalidClass">
            <summary>
              Looks up a localized string similar to The class name {0} is invalid. Valid class names consist of letters, digits, &apos;_&apos;, &apos;?&apos;, &apos;*&apos;, &apos;-&apos; and &quot;[]&quot;..
            </summary>
        </member>
        <member name="P:WmiResources.WmiInvalidClass">
            <summary>
              Looks up a localized string similar to Could not register for event. The class name is invalid. Valid class names consist of letters, digits and the underscore character..
            </summary>
        </member>
        <member name="P:WmiResources.WmiMethodNameForConfirmation">
            <summary>
              Looks up a localized string similar to {0} ({1}).
            </summary>
        </member>
        <member name="P:WmiResources.WmiNamespaceConnect">
            <summary>
              Looks up a localized string similar to Could not get objects from namespace {0}. {1}.
            </summary>
        </member>
        <member name="P:WmiResources.WmiParameterMissing">
            <summary>
              Looks up a localized string similar to Parameter {0} should be specified to compose the query..
            </summary>
        </member>
        <member name="P:WmiResources.WmiQueryFailure">
            <summary>
              Looks up a localized string similar to {0}&quot;{1}&quot;.
            </summary>
        </member>
        <member name="T:ManagementMshSnapInResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ManagementMshSnapInResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ManagementMshSnapInResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ManagementMshSnapInResources.Description">
            <summary>
              Looks up a localized string similar to This Windows PowerShell Snap-In contains management cmdlets that are used to manage Windows components.  .
            </summary>
        </member>
        <member name="P:ManagementMshSnapInResources.Name">
            <summary>
              Looks up a localized string similar to Management PSSnapIn.
            </summary>
        </member>
        <member name="P:ManagementMshSnapInResources.Vendor">
            <summary>
              Looks up a localized string similar to Microsoft Corporation.
            </summary>
        </member>
        <member name="T:ClearRecycleBinResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ClearRecycleBinResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ClearRecycleBinResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ClearRecycleBinResources.ClearRecycleBinContent">
            <summary>
              Looks up a localized string similar to All of the contents of the Recycle Bin.
            </summary>
        </member>
        <member name="P:ClearRecycleBinResources.ClearRecycleBinContentForDrive">
            <summary>
              Looks up a localized string similar to All of the contents of the Recycle Bin for the &apos;{0}&apos; drive.
            </summary>
        </member>
        <member name="P:ClearRecycleBinResources.ClearRecycleBinProgressActivity">
            <summary>
              Looks up a localized string similar to Clearing Recycle Bin.
            </summary>
        </member>
        <member name="P:ClearRecycleBinResources.ClearRecycleBinStatusDescriptionByDrive">
            <summary>
              Looks up a localized string similar to for the &apos;{0}&apos; drive.
            </summary>
        </member>
        <member name="P:ClearRecycleBinResources.ClearRecycleBinStatusDescriptionForAllDrives">
            <summary>
              Looks up a localized string similar to for all drives.
            </summary>
        </member>
        <member name="P:ClearRecycleBinResources.DriveNotFound">
            <summary>
              Looks up a localized string similar to Cannot find drive. A drive with the name &apos;{0}&apos; does not exist. Please run the &apos;{1}&apos; cmdlet to see the available Fixed drives in the system..
            </summary>
        </member>
        <member name="P:ClearRecycleBinResources.InvalidDriveNameFormat">
            <summary>
              Looks up a localized string similar to Invalid input. The following formats are supported: &apos;{0}&apos;, &apos;{1}&apos; or &apos;{2}&apos;..
            </summary>
        </member>
        <member name="P:ClearRecycleBinResources.InvalidDriveType">
            <summary>
              Looks up a localized string similar to The drive with the name &apos;{0}&apos; is not a Fixed drive and does not support the Recyle Bin. Please run the &apos;{1}&apos; cmdlet to see the available Fixed drives in the system..
            </summary>
        </member>
        <member name="T:ClipboardResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ClipboardResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ClipboardResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:ClipboardResources.AppendClipboardContent">
            <summary>
              Looks up a localized string similar to Append string &apos;{0}&apos; to the clipboard..
            </summary>
        </member>
        <member name="P:ClipboardResources.AppendMultipleFilesToClipboard">
            <summary>
              Looks up a localized string similar to Append {0} files to the clipboard..
            </summary>
        </member>
        <member name="P:ClipboardResources.AppendSingleFileToClipboard">
            <summary>
              Looks up a localized string similar to Append file &apos;{0}&apos; to the clipboard..
            </summary>
        </member>
        <member name="P:ClipboardResources.ClipboardCleared">
            <summary>
              Looks up a localized string similar to The Clipboard has been cleared..
            </summary>
        </member>
        <member name="P:ClipboardResources.InvalidHtmlCombine">
            <summary>
              Looks up a localized string similar to Html can only be combined with Html Text format..
            </summary>
        </member>
        <member name="P:ClipboardResources.InvalidRawCombine">
            <summary>
              Looks up a localized string similar to Raw can only be combined with Text or FileDropList format..
            </summary>
        </member>
        <member name="P:ClipboardResources.InvalidTypeCombine">
            <summary>
              Looks up a localized string similar to TextFormatType can only be combined with Text format..
            </summary>
        </member>
        <member name="P:ClipboardResources.NoAppendableClipboardContent">
            <summary>
              Looks up a localized string similar to There&apos;s no content in Clipboard or the content format is not compatible. Set input object to the Clipboard..
            </summary>
        </member>
        <member name="P:ClipboardResources.SetClipboardContent">
            <summary>
              Looks up a localized string similar to Set string &apos;{0}&apos; to the clipboard..
            </summary>
        </member>
        <member name="P:ClipboardResources.SetMultipleFilesToClipboard">
            <summary>
              Looks up a localized string similar to Set {0} files to the clipboard..
            </summary>
        </member>
        <member name="P:ClipboardResources.SetSingleFileToClipboard">
            <summary>
              Looks up a localized string similar to Set file &apos;{0}&apos; to the clipboard..
            </summary>
        </member>
    </members>
</doc>
